0001   0000             ;Replacement 8080A cpu board for ALTAIR/IMSAI
0002   0000             ;Monitor program for 8080A based computer.
0003   0000             ;Written by Josh Bensadon
0004   0000             ;Free for public use, following all the shareware policies & disclaimers.
0005   0000             ;
0006   0000             ;CONSOLE BIOS is near end of file, can be modified to talk to any UART
0007   0000             ;FLOPPY DISK BIOS is also near end of file
0008   0000             ;
0009   0000             ;The boot loader in the EPROM will load this file automatically if this file
0010   0000             ;is renamed to BIOS.HEX.  The batch file to assemble this file will do this.
0011   0000             ;
0012   0000             ;
0013   0000             ;Version 1.0 - Josh Bensadon.  Reused all code from previous Monitor program ver 1.7
0014   0000             ;1.1	-JB. Corrected problem with BIOS DISK read/write by changing to my own temp stack
0015   0000             ;	-Corrected hidden problem with Drive Parameter Table
0016   0000             ;1.2	-Set Stack to high RAM
0017   0000             ;	-Corrected problem with Sectors starting at 0
0018   0000             ;2.0	-Created a more elaborate Boot Loader to be installed in EPROM.
0019   0000             ;	-This System ROM can now be loaded via the BIOS.HEX file on the SD Card
0020   0000             ;2.1	-Fixed an issue with output to both Propeller and UART Com-port
0021   0000             ;2.2	-Dropped UART Com-Port to observe a 33% console speed increase
0022   0000             ;2.3	-Resuming from v2.1 (dual support).  Corrected firmware for configuration 
0023   0000             ;	-when Propeller I/O board is NOT present.
0024   0000             ;2.4	-Added Config File to select the default disk files and DPB settins for various sized disk images
0025   0000             ;2.5
0026   0000             ;2.6	-Made Track handle 16 bit
0027   0000             ;2.7	-includes patch code jumped to by the CCP to:
0028   0000             ;          1) Display the user number in the prompt (e.g., "A3>").
0029   0000             ;          2) Look on drive A with current user, then drive A user 0 for the
0030   0000             ;	      typed command if it fails to open on the default drive.
0031   0000             ;	   The CCP is patched as well in order to jump to the patch code
0032   0000             ;	   in this BIOS. Search for "prompt" and "user0" in the code below.
0033   0000             ;	   Taken from Mike Douglas' 8MB FDC+ CP/M BIOS.
0034   0000             ;2.8	-Expanded the Alocation Vectors to 512 bytes for BIG disks
0035   0000             ;
0036   0000             ;
0037   0000             
0038   0000             
0039   0000             ;Monitor for the IMSAI 8080
0040   0000             ;Functions:
0041   0000             ; -Dump, Edit & Execute Memory.
0042   0000             ; -Input Port and Output Port.
0043   0000             ; -RAM Test
0044   0000             ; -ASCII Upload text file
0045   0000             ; -XMODEM up/down load to Memory
0046   0000             ; -XMODEM up/down load to Disk
0047   0000             ;
0048   0000             ; AA8080.ASM works with the Standard Console port of the Altair (Port 0=Status, Port 1=RX/TX)
0049   0000             ; Tested on the Solid State Music Computer Systems IO4 Serial/Parallel interface board installed on an IMSAI 8080
0050   0000             ; Floppy functions work with the Tarbell 1101 (using the Western Digital FD1771 Floppy Disk Controller chip).
0051   0000             ;
0052   0000             ; D XXXX YYYY	Dump memory from XXXX to YYYY
0053   0000             ; E XXXX	Edit memory starting at XXXX (type an X and press enter to exit entry)
0054   0000             ; G XXXX	GO starting at address XXXX (Monitor program address left on stack)
0055   0000             ; I XX		Input from I/O port XX and display as hex
0056   0000             ; O XX YY	Output to I/O port XX byte YY
0057   0000             ; X U XXXX	XMODEM Upload to memory at XXXX (CRC or CHECKSUM)
0058   0000             ; X D XXXX CCCC	XMODEM Download from memory at XXXX for CCCC number of 128 byte blocks
0059   0000             ; :ssHHLLttDDDDDD...CS   -ASCII UPLOAD Intel HEX file to Memory.  Monitor auto downloads with the reception of a colon.
0060   0000             ; F 		Floppy commands
0061   0000             ; R XX YY	RAM TEST from pages XX to YY
0062   0000             
0063   0000             ;
0064   0000             ; Search for BIOS sections to adapt to other systems
0065   0000             
0066   0000             
0067   0000             
0068   0000             		.CSEG
0069   0000             
0070   0000             ;----------------------------;
0071   0000             CCPMOD          .EQU 1	     ; Enable CCP Patch Code
0072   0000             ;----------------------------;
0073   0000             
0074   0000             ;----------------------------; IMSAI CONSOLE PORTS
0075   0000             FPLED		.EQU 255	;Front Panel LED
0076   0000             FPSW		.EQU 255	;Front Panel Switches
0077   0000             ;----------------------------;
0078   0000             
0079   0000             PROPELLERS	.EQU 0		;Propeller Console Status Port
0080   0000             PROPELLERD	.EQU 1		;Propeller Console Data Port
0081   0000             
0082   0000             CPU_IO		.EQU 20H	;Base address for onboard CPU I/O
0083   0000             UART0		.EQU CPU_IO
0084   0000             UART1		.EQU CPU_IO+8H
0085   0000             SPI		.EQU CPU_IO+10H
0086   0000             SPI_SS		.EQU SPI+1
0087   0000             PORT2		.EQU CPU_IO+18H
0088   0000             
0089   0000             DEBUG		.EQU 00000000B
0090   0000             		;1 = CP/M BIOS
0091   0000             		;2 = LOW level SD Card
0092   0000             		;80h = UART1
0093   0000             
0094   0000             
0095   0000             CPM_DSK_BUFF	.EQU 80H	;Default CPM Buffer of 128 Bytes
0096   0000             
0097   D300             		.ORG 0D300H
0098   D300 31 00 FD    CODE_START	LXI	SP,HIGHSTACK ;128 Bytes of stack available.
0099   D303 3E 80       		MVI	A,80H	;Set baud rate
0100   D305 D3 23       		OUT	UART0+3
0101   D307 D3 2B       		OUT	UART1+3
0102   D309 3E 0C       		MVI	A,12	;12=9600 baud
0103   D30B D3 20       		OUT	UART0
0104   D30D D3 28       		OUT	UART1
0105   D30F 3E 00       		MVI	A,0
0106   D311 D3 21       		OUT	UART0+1
0107   D313 D3 29       		OUT	UART1+1
0108   D315 3E 03       		MVI	A,3	;Set 8 data bits, no parity, 1 stop
0109   D317 D3 23       		OUT	UART0+3
0110   D319 D3 2B       		OUT	UART1+3
0111   D31B             
0112   D31B 3E FF       		MVI	A,0FFh
0113   D31D 32 82 FD    		STA	PROP_CHECK
0114   D320             
0115   D320 CD E7 E8    		CALL	PRINTI		;System Start, Display Welcome Message
0116   D323 0D0A414C5441 		.text "\r\nALTAIR/IMSAI 8080 CPU BOARD - Josh Bensadon v2.8 (Nov 2023)\r\n\000"
0116   D329 49522F494D53414920383038302043505520424F415244202D204A6F73682042656E7361646F6E2076322E3820284E6F762032303233290D0A00
0117   D363             
0118   D363 CD F2 EB    		CALL	INIT_FAT
0119   D366 CD E7 E8    		CALL	PRINTI	
0120   D369 0D 0A 00    		.text "\r\n\000"
0121   D36C             
0122   D36C             		
0123   D36C 21 00 00    		LXI	H,0
0124   D36F 22 99 FD    		SHLD	LOGICAL_SEC
0125   D372             		
0126   D372 21 40 D5    		LXI	H,FCB_CONFIG
0127   D375 22 83 FD    		SHLD	FCB_PTR
0128   D378 CD A0 EB    		CALL	SD_OPEN
0129   D37B C2 95 D3    		JNZ	FILEOK
0130   D37E CD E7 E8    GO_HALT		CALL	PRINTI
0131   D381 202D2048414C 		.text " - HALT\000"
0131   D387 5400
0132   D389 76          		HLT
0133   D38A C3 89 D3    		JMP	$-1
0134   D38D             		
0135   D38D 06 0C       INPUT_NAME	MVI	B,12
0136   D38F CD 2C F1    		CALL	COPY_RAM
0137   D392 23          		INX	H
0138   D393 23          		INX	H
0139   D394 C9          		RET
0140   D395             		
0141   D395 2A DC FD    FILEOK		LHLD	FILESIZE	;Save file size of Config File
0142   D398 22 5C D5    		SHLD	CONFIGSIZE
0143   D39B CD 16 EA    		CALL	DISK_READ	;HL=Buffer
0144   D39E             		
0145   D39E 11 00 FD    		LXI	D,SDISKA	;Preload all SD_FCB's with file names for 4 disks
0146   D3A1 CD 8D D3    		CALL	INPUT_NAME
0147   D3A4 11 20 FD    		LXI	D,SDISKB
0148   D3A7 CD 8D D3    		CALL	INPUT_NAME
0149   D3AA 11 40 FD    		LXI	D,SDISKC
0150   D3AD CD 8D D3    		CALL	INPUT_NAME
0151   D3B0 11 60 FD    		LXI	D,SDISKD
0152   D3B3 CD 8D D3    		CALL	INPUT_NAME
0153   D3B6             
0154   D3B6             
0155   D3B6 CD E7 E8    BOOT_MENU	CALL	PRINTI		;BOOT Menu
0156   D3B9 0D0A0D0A4D20 		.text "\r\n\r\nM - Monitor"
0156   D3BF 2D204D6F6E69746F72
0157   D3C8 0D0A43202D20 		.text "\r\nC - Boot CP/M\000"
0157   D3CE 426F6F742043502F4D00
0158   D3D8             
0159   D3D8 AF          		XRA	A		;Loop through the 4 SD_FCB's and try to open/init the FCB's
0160   D3D9 F5          BMD_LP		PUSH	PSW
0161   D3DA 57          		MOV	D,A		;D=A=File (0 to 3) (D for printing)
0162   D3DB CD 87 E9    		CALL	SET_FCB_PTR
0163   D3DE 01 0A 00    		LXI	B,10
0164   D3E1 09          		DAD	B		
0165   D3E2 CD 35 F1    		CALL	LD_HL_HL
0166   D3E5 22 62 D5    		SHLD	DPBPTR		;Save the DPB location
0167   D3E8 CD E7 E8    		CALL	PRINTI
0168   D3EB 0D0A202000  		.text "\r\n  \000"		
0169   D3F0 7A          		MOV	A,D
0170   D3F1 3C          		INR	A
0171   D3F2 CD CE E8    		CALL	PUT_HEX
0172   D3F5 CD E7 E8    		CALL	PRINTI
0173   D3F8 202D20446973 		.text " - Disk \000"
0173   D3FE 6B2000
0174   D401 7A          		MOV	A,D
0175   D402 C6 41       		ADI	'A'
0176   D404 CD 3A E9    		CALL	PUT_CHAR
0177   D407 CD E7 E8    		CALL	PRINTI
0178   D40A 20 3D 20 00 		.text " = \000"
0179   D40E CD A0 EB    		CALL	SD_OPEN
0180   D411             		
0181   D411 21 DF FD    		LXI	H,FILESIZE+3		;Convert the 4 byte file size into 8 byte ASCII
0182   D414 11 E3 FD    		LXI	D,FILESIZEHEX+3
0183   D417 06 04       		MVI	B,4			;4 bytes
0184   D419 7E          FS2ASC_LP	MOV	A,M		
0185   D41A CD D4 E8    		CALL	BIN2HEX
0186   D41D 12          		STAX	D
0187   D41E 7E          		MOV	A,M
0188   D41F 0F          		RRC
0189   D420 0F          		RRC
0190   D421 0F          		RRC
0191   D422 0F          		RRC
0192   D423 CD D4 E8    		CALL	BIN2HEX
0193   D426 1B          		DCX	D
0194   D427 12          		STAX	D
0195   D428 1B          		DCX	D
0196   D429 2B          		DCX	H
0197   D42A 05          		DCR	B
0198   D42B C2 19 D4    		JNZ	FS2ASC_LP
0199   D42E             		
0200   D42E             
0201   D42E 21 00 00    		LXI	H,0		;Read Config file to find paramaters for a file of this size
0202   D431 22 99 FD    		SHLD	LOGICAL_SEC		
0203   D434 21 40 D5    		LXI	H,FCB_CONFIG
0204   D437 22 83 FD    		SHLD	FCB_PTR		
0205   D43A             
0206   D43A             					;Get Line
0207   D43A 01 64 D5    		LXI	B,LINE_BUFF
0208   D43D 2A 5C D5    		LHLD	CONFIGSIZE
0209   D440 22 5E D5    		SHLD	CONFIGSIZECNT
0210   D443 EB          		XCHG			;DE = CONFIG FILE SIZE
0211   D444             		
0212   D444 C5          GL_LP1		PUSH	B
0213   D445 D5          		PUSH	D
0214   D446 CD 16 EA    		CALL	DISK_READ	;HL=BUFF
0215   D449 D1          		POP	D		;DE=Count of Remaining Bytes in file
0216   D44A C1          		POP	B		;BC=LINE_BUF PTR
0217   D44B             		
0218   D44B 7E          GL_LP2		MOV	A,M		;Get a char
0219   D44C FE 20       		CPI	' '
0220   D44E DA 70 D4    		JC	GL_CTRL		;Jump out when a control char is found
0221   D451 02          		STAX	B		;Save char to Line Buff
0222   D452             		
0223   D452 3E E4       		MVI	A, LINE_BUFFEND & 0FFH ;If BC <> End of Line Buffer, then BC = BC + 1
0224   D454 B9          		CMP	C
0225   D455 CA 59 D4    		JZ	GL_BF
0226   D458 03          		INX	B
0227   D459 23          GL_BF		INX	H
0228   D45A 1B          		DCX	D
0229   D45B 7A          		MOV	A,D
0230   D45C B3          		ORA	E
0231   D45D CA C3 D4    		JZ	GL_EOF
0232   D460             		
0233   D460 AF          		XRA	A		
0234   D461 BC          		CMP	H		;IF HL <> End of Disk Buffer, then Loop back for next char
0235   D462 C2 4B D4    		JNZ	GL_LP2
0236   D465             
0237   D465 3A 99 FD    		LDA	LOGICAL_SEC	;Advance to next sector (4x128 = 512)
0238   D468 C6 04       		ADI	4
0239   D46A 32 99 FD    		STA	LOGICAL_SEC
0240   D46D C3 44 D4    		JMP	GL_LP1
0241   D470             		
0242   D470 AF          GL_CTRL		XRA	A		;Save 000 at end of line
0243   D471 02          		STAX	B
0244   D472 E5          		PUSH	H
0245   D473             		
0246   D473 01 DC FD    		LXI	B,FILESIZE
0247   D476 21 64 D5    		LXI	H,LINE_BUFF
0248   D479 0A          GLT_LP		LDAX	B
0249   D47A BE          		CMP	M
0250   D47B C2 BC D4    		JNZ	GLT_NOTEQ
0251   D47E 03          		INX	B
0252   D47F 23          		INX	H
0253   D480 3E 6C       		MVI	A, LINE_BUFF+8 & 0FFH
0254   D482 BD          		CMP	L
0255   D483 C2 79 D4    		JNZ	GLT_LP
0256   D486             					;HURRAY, WE HAVE FOUND THE RIGHT DISK SIZE
0257   D486             					;COPY DPB, PRINT MSG
0258   D486 23          		INX	H
0259   D487 EB          		XCHG
0260   D488 2A 62 D5    		LHLD	DPBPTR
0261   D48B 06 0F       		MVI	B,15
0262   D48D CD A7 D4    GTL_COPY_LP	CALL	GTL_GETHEX
0263   D490 07          		RLC	
0264   D491 07          		RLC	
0265   D492 07          		RLC	
0266   D493 07          		RLC		
0267   D494 77          		MOV	M,A
0268   D495 CD A7 D4    		CALL	GTL_GETHEX
0269   D498 B6          		ORA	M
0270   D499 77          		MOV	M,A
0271   D49A 23          		INX	H
0272   D49B             		
0273   D49B 05          		DCR	B
0274   D49C C2 8D D4    		JNZ	GTL_COPY_LP
0275   D49F EB          		XCHG
0276   D4A0 CD DD E8    		CALL	PRINT		;Print rest of line.		
0277   D4A3 E1          		POP	H
0278   D4A4 C3 DE D4    		JMP	BMD_NEXT
0279   D4A7             		
0280   D4A7 1A          GTL_GETHEX	LDAX	D
0281   D4A8 13          		INX	D
0282   D4A9 CD 24 DB    		CALL	ASC2HEX
0283   D4AC D0          		RNC
0284   D4AD CD E7 E8    		CALL	PRINTI
0285   D4B0 204241442048 		.text " BAD HEX\000"
0285   D4B6 455800
0286   D4B9 C3 7E D3    		JMP	GO_HALT		
0287   D4BC             
0288   D4BC             		
0289   D4BC E1          GLT_NOTEQ	POP	H
0290   D4BD 01 64 D5    		LXI	B,LINE_BUFF
0291   D4C0 C3 59 D4    		JMP	GL_BF
0292   D4C3             		
0293   D4C3 CD E7 E8    GL_EOF		CALL	PRINTI
0294   D4C6 202D20444953 		.text " - DISK SIZE NOT LISTED\000"
0294   D4CC 4B2053495A45204E4F54204C495354454400
0295   D4DE             		
0296   D4DE F1          BMD_NEXT	POP	PSW
0297   D4DF 3C          		INR	A
0298   D4E0 FE 04       		CPI	4
0299   D4E2 C2 D9 D3    		JNZ	BMD_LP
0300   D4E5             
0301   D4E5 21 80 00    		LXI	H,CPM_DSK_BUFF		;Default CPM DMAADD
0302   D4E8 22 E7 FD    		SHLD	DMAADD
0303   D4EB 21 00 FD    		LXI	H,SDISKA		;Default FCB_PTR for Disk-A
0304   D4EE 22 83 FD    		SHLD	FCB_PTR
0305   D4F1             
0306   D4F1 CD E7 E8     		CALL	PRINTI		;BOOT Menu
0307   D4F4 0D 0A 3E 00 		.text "\r\n\>\000"
0308   D4F8             
0309   D4F8 3E FF       		MVI	A,0FFH
0310   D4FA 32 81 FD    		STA	ECHO_ON		;TURN ON ECHO
0311   D4FD CD 27 E9    		CALL 	GET_CHAR	;get char
0312   D500 CD C8 F0    		CALL	TO_UPPER
0313   D503 FE 43       		CPI 	'C'		;Branch to Command entered
0314   D505 CA 00 E6    		JZ 	CBOOTV		; C = BOOT CP/M
0315   D508 FE 4D       		CPI 	'M'		;Branch to Command entered
0316   D50A CA E5 D5    		JZ 	MAIN_MENU	; C = BOOT CP/M
0317   D50D FE 31       		CPI	'1'
0318   D50F DA B6 D3    		JC	BOOT_MENU
0319   D512 FE 35       		CPI	'5'
0320   D514 D2 B6 D3    		JNC	BOOT_MENU
0321   D517 3D          		DCR	A
0322   D518 CD 87 E9    		CALL	SET_FCB_PTR
0323   D51B CD 3C F0    		CALL	INPUT_FNAME
0324   D51E 2A 83 FD    		LHLD	FCB_PTR
0325   D521 23          		INX	H		;FNAME
0326   D522 EB          		XCHG
0327   D523 21 C8 FD    		LXI	H,FILENAME
0328   D526 06 0B       		MVI	B,11
0329   D528 CD 2C F1    		CALL	COPY_RAM
0330   D52B C3 B6 D3    		JMP	BOOT_MENU
0331   D52E             		
0332   D52E             ;------------------------
0333   D52E E3          INIT_BLOCK	XTHL	;HL = Top of Stack
0334   D52F 5E          		MOV	E,M	;Fetch address of SD_FCB to DE
0335   D530 23          		INX	H
0336   D531 56          		MOV	D,M
0337   D532 23          		INX	H
0338   D533 7E          IB_LP		MOV	A,M	;Copy all data up to 0x00 to SD_FCB
0339   D534 23          		INX	H	;Inc HL, so on finding 0x00, exit to next instruction
0340   D535 B7          		ORA	A
0341   D536 CA 3E D5    		JZ	IB_RET
0342   D539 12          		STAX	D
0343   D53A 13          		INX	D
0344   D53B C3 33 D5    		JMP	IB_LP
0345   D53E E3          IB_RET		XTHL		;Move updated return address back to stack
0346   D53F C9          		RET
0347   D540             
0348   D540             ;LOCAL RAM SPACE
0349   D540             
0350   D540 00          FCB_CONFIG	.DB	0	;FSTAT		.BLOCK	1	;+0  Status of FCB, 00=File Not Open
0351   D541 43504D444953 		.text "CPMDISKSTXT"		;+1
0351   D547 4B53545854
0352   D54C             FCB_CONFIG_C1	.BLOCK	2	;AFClus0	;+12 First Cluster of File as given by the Directory Entry.
0353   D54E FF FF       		.DW	0FFFFH	;CRFClus	;+14 Current Relative Cluster location in file, (0 to F for a system with 32 Sectors per Cluster)
0354   D550 FF FF       		.DW	0FFFFH	;CAFClus	;+16 Current Absolute Cluster location in file, set to AFClus0, then updated with FAT
0355   D552 FF FF       		.DW	0FFFFH	;RFSec		;+18 Relative Sector being addressed (0 to 500, based 26 sectors per track and 77 tracks Divide by 4)
0356   D554 FF FF       		.DW	0FFFFH	;SSOC		;+20 Starting Sector of Cluster, this is the first Sector for that Cluster
0357   D556 FF FF       		.DW	0FFFFH
0358   D558 FF FF       		.DW	0FFFFH	;ABS_SEC	;+24 Absolute Sector of Current Relative Sector
0359   D55A FF FF       		.DW	0FFFFH	
0360   D55C             		
0361   D55C 00 00       CONFIGSIZE	.DW	0			;Size of Config File
0362   D55E 00 00       CONFIGSIZECNT	.DW	0
0363   D560 00 00       CONFIGPTR	.DW	0
0364   D562 7F E6       DPBPTR		.DW	DPB0
0365   D564             
0366   D564             LINE_BUFF	.BLOCK 128
0367   D5E4 00          LINE_BUFFEND	.DB	0
0368   D5E5             
0369   D5E5             
0370   D5E5             
0371   D5E5             ;----------------------------------------------------------------------------------------------------; MONITOR MAIN MENU
0372   D5E5             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
0373   D5E5             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
0374   D5E5             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
0375   D5E5             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
0376   D5E5             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
0377   D5E5             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
0378   D5E5             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
0379   D5E5             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
0380   D5E5             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
0381   D5E5             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
0382   D5E5             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
0383   D5E5             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
0384   D5E5             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
0385   D5E5             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
0386   D5E5             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
0387   D5E5             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
0388   D5E5             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
0389   D5E5             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
0390   D5E5             ;----------------------------------------------------------------------------------------------------; MAIN MENU
0391   D5E5 21 E5 D5    MAIN_MENU:	LXI	H, MAIN_MENU	;Push Mainmenu onto stack as default return address
0392   D5E8 E5          		PUSH	H
0393   D5E9 CD E7 E8    		CALL	PRINTI		;Monitor Start, Display Welcome Message
0394   D5EC 0D0A4D454E55 		.text "\r\nMENU>\000"
0394   D5F2 3E00
0395   D5F4 3E FF       		MVI	A,0FFH
0396   D5F6 32 81 FD    		STA	ECHO_ON		;TURN ON ECHO
0397   D5F9 CD 27 E9    		CALL 	GET_CHAR	;get char
0398   D5FC FE 3A       		CPI	':'
0399   D5FE CA 58 DB    		JZ 	GETHEXFILE	; : = START HEX FILE LOAD
0400   D601 E6 5F       		ANI 	5Fh		;to upper case
0401   D603 FE 44       		CPI 	'D'		;Branch to Command entered
0402   D605 CA FF D6    		JZ 	MEM_DUMP	; D = Memory Dump
0403   D608 FE 45       		CPI 	'E'
0404   D60A CA BE D7    		JZ 	MEM_EDIT	; E = Edit Memory
0405   D60D FE 47       		CPI 	'G'
0406   D60F CA E7 D7    		JZ 	MEM_EXEC	; G = Go (Execute at)
0407   D612 FE 4F       		CPI 	'O'
0408   D614 CA FC D7    		JZ 	PORT_OUT	; O = Output to port
0409   D617 FE 49       		CPI 	'I'
0410   D619 CA EC D7    		JZ 	PORT_INP	; I = Input from Port
0411   D61C FE 53       		CPI 	'S'
0412   D61E CA 11 D8    		JZ 	SD_MENU		; S = SD Card Functions
0413   D621 FE 58       		CPI 	'X'
0414   D623 CA C8 DB    		JZ 	XMODEM		; X = XMODEM
0415   D626 FE 52       		CPI 	'R'
0416   D628 CA 2A DE    		JZ	RAM_TEST	; R = RAM TEST
0417   D62B FE 55       		CPI 	'U'
0418   D62D CA E0 D6    		JZ	MEM_UNASM	; U = UNASSEMBLE
0419   D630 CD E7 E8    		CALL 	PRINTI		;Display Err when input is invalid
0420   D633 0D0A494E5641 		.text "\r\nINVALID CMD\000"
0420   D639 4C494420434D4400
0421   D641             
0422   D641 CD E7 E8    		CALL 	PRINTI		;Display Err when input is invalid
0423   D644 0D0A48454C50 		.text "\r\nHELP"
0424   D64A 0D0A44202D44 		.text "\r\nD -Dump"
0424   D650 756D70
0425   D653 0D0A45202D45 		.text "\r\nE -Edit"
0425   D659 646974
0426   D65C 0D0A47202D47 		.text "\r\nG -Go (Exec)"
0426   D662 6F20284578656329
0427   D66A 0D0A4F202D4F 		.text "\r\nO -Output to port"
0427   D670 757470757420746F20706F7274
0428   D67D 0D0A49202D49 		.text "\r\nI -Input to port"
0428   D683 6E70757420746F20706F7274
0429   D68F 0D0A53202D53 		.text "\r\nS -SD Card Functions"
0429   D695 4420436172642046756E6374696F6E73
0430   D6A5 0D0A58202D58 		.text "\r\nX -XModem Up/Down Load"
0430   D6AB 4D6F64656D2055702F446F776E204C6F6164
0431   D6BD 0D0A52202D52 		.text "\r\nR -RAM TEST"
0431   D6C3 414D2054455354
0432   D6CA 0D0A55202D55 		.text "\r\nU -Unassemble"
0432   D6D0 6E617373656D626C65
0433   D6D9 0D 0A 3E 00 		.text "\r\n>\000"
0434   D6DD C3 E5 D5    		JMP 	MAIN_MENU
0435   D6E0             
0436   D6E0             
0437   D6E0             ;=============================================================================
0438   D6E0             ;MEMORY UNASSEMBLE
0439   D6E0             ;-----------------------------------------------------------------------------
0440   D6E0 CD FF DA    MEM_UNASM:	CALL	SPACE_GET_WORD	;Input start address
0441   D6E3 EB          		XCHG			;HL = Start
0442   D6E4 CD 97 E8    		CALL	PUT_NEW_LINE
0443   D6E7 AF          		XRA	A
0444   D6E8 32 81 FD    		STA	ECHO_ON		;TURN OFF ECHO
0445   D6EB 06 0A       MU_LP1		MVI	B,10
0446   D6ED C5          MU_LP2		PUSH	B
0447   D6EE CD F9 E2    		CALL	DISASM
0448   D6F1 C1          		POP	B
0449   D6F2 05          		DCR	B
0450   D6F3 C2 ED D6    		JNZ	MU_LP2
0451   D6F6 CD 27 E9    		CALL	GET_CHAR
0452   D6F9 FE 1B       		CPI	27
0453   D6FB C2 EB D6    		JNZ	MU_LP1
0454   D6FE C9          		RET
0455   D6FF             
0456   D6FF             ;=============================================================================
0457   D6FF             ;MEMORY DUMP
0458   D6FF             ;-----------------------------------------------------------------------------
0459   D6FF CD FF DA    MEM_DUMP:	CALL	SPACE_GET_WORD	;Input start address
0460   D702 EB          		XCHG			;HL = Start
0461   D703 CD FF DA    		CALL	SPACE_GET_WORD	;Input end address (DE = end)
0462   D706             
0463   D706 CD 97 E8    MEM_DUMP_LP:	CALL	PUT_NEW_LINE
0464   D709 CD 40 D7    		CALL	DUMP_LINE	;Dump 16 byte lines (advances HL)
0465   D70C C8          		RZ			;RETURN WHEN HL=DE
0466   D70D 7D          		MOV	A,L
0467   D70E B7          		ORA	A
0468   D70F C2 06 D7    		JNZ	MEM_DUMP_LP	;Dump 1 Page, then prompt for continue
0469   D712 CD 18 D7    		CALL	GET_CONTINUE
0470   D715 C3 06 D7    		JMP	MEM_DUMP_LP
0471   D718             
0472   D718             
0473   D718 CD 97 E8    GET_CONTINUE	CALL	PUT_NEW_LINE
0474   D71B CD E7 E8    		CALL	PRINTI
0475   D71E 507265737320 		.text "Press any key to continue\000"
0475   D724 616E79206B657920746F20636F6E74696E756500
0476   D738 CD 27 E9    		CALL	GET_CHAR
0477   D73B FE 1B       		CPI	27
0478   D73D C0          		RNZ
0479   D73E E1          		POP	H		;Scrap return address
0480   D73F C9          		RET
0481   D740             
0482   D740             
0483   D740             ;-----------------------------------------------------------------------------
0484   D740             ;DUMP_LINE -- Dumps a line
0485   D740             ;xxx0:  <pre spaces> XX XX XX XX XX After spaces | ....ASCII....
0486   D740             ;-----------------------------------------------------------------------------
0487   D740 C5          DUMP_LINE:	PUSH	B		;+1
0488   D741 E5          		PUSH	H		;+2 Save H for 2nd part of display
0489   D742 E5          		PUSH	H		;+3 Start line with xxx0 address
0490   D743 7D          		MOV	A,L
0491   D744 E6 F0       		ANI	0F0h		;Mask FFF0
0492   D746 6F          		MOV	L,A
0493   D747 CD B4 E8    		CALL	PUT_HL		;Print Address
0494   D74A CD E7 E8    		CALL	PRINTI
0495   D74D 3A 20 00    		.text ": \000"
0496   D750 E1          		POP	H		;-3
0497   D751 7D          		MOV	A,L
0498   D752 E6 0F       		ANI	0Fh		;Fetch how many prespaces to print
0499   D754 4F          		MOV	C,A
0500   D755 47          		MOV	B,A		;Save count of prespaces for part 2 of display
0501   D756 CD B0 D7    		CALL	PUT_3C_SPACES
0502   D759             
0503   D759 CD 53 DB    DL_P1L		CALL	PUT_SPACE
0504   D75C 7E          		MOV	A,M
0505   D75D CD BF E8    		CALL	PUT_BYTE
0506   D760 CD AA D7    		CALL	CMP_HL_DE
0507   D763 CA 70 D7    		JZ	DL_P1E
0508   D766 23          		INX	H
0509   D767 7D          		MOV	A,L
0510   D768 E6 0F       		ANI	0Fh
0511   D76A C2 59 D7    		JNZ	DL_P1L
0512   D76D C3 78 D7    		JMP	DL_P2
0513   D770             
0514   D770 7D          DL_P1E		MOV	A,L
0515   D771 2F          		CMA
0516   D772 E6 0F       		ANI	0Fh
0517   D774 4F          		MOV	C,A
0518   D775 CD B0 D7    		CALL	PUT_3C_SPACES
0519   D778             
0520   D778 CD E7 E8    DL_P2		CALL	PRINTI		;Print Seperator between part 1 and part 2
0521   D77B 20 7C 20 00 		.text " | \000"
0522   D77F             
0523   D77F 78          DL_PSL2		MOV	A,B		;Print prespaces for part 2
0524   D780 B7          		ORA	A
0525   D781 CA 8B D7    		JZ	DL_PSE2
0526   D784 CD 53 DB    		CALL	PUT_SPACE
0527   D787 05          		DCR	B
0528   D788 C3 7F D7    		JMP	DL_PSL2
0529   D78B             DL_PSE2
0530   D78B E1          		POP	H		;-2
0531   D78C C1          		POP	B		;-1
0532   D78D 7E          DL_P2L		MOV	A,M
0533   D78E FE 20       		CPI	' '		;A - 20h	Test for Valid ASCII characters
0534   D790 F2 95 D7    		JP	DL_P2K1
0535   D793 3E 2E       		MVI	A,'.'				;Replace with . if not ASCII
0536   D795 FE 7F       DL_P2K1		CPI	07Fh		;A - 07Fh
0537   D797 FA 9C D7    		JM	DL_P2K2
0538   D79A 3E 2E       		MVI	A,'.'
0539   D79C CD 3A E9    DL_P2K2		CALL	PUT_CHAR
0540   D79F             
0541   D79F CD AA D7    		CALL	CMP_HL_DE
0542   D7A2 C8          		RZ
0543   D7A3 23          		INX	H
0544   D7A4 7D          		MOV	A,L
0545   D7A5 E6 0F       		ANI	0Fh
0546   D7A7 C2 8D D7    		JNZ	DL_P2L
0547   D7AA             
0548   D7AA             ;-----------------------------------------------------------------------------
0549   D7AA             ;Compare HL with DE
0550   D7AA             ;Exit:		Z=1 if HL=DE
0551   D7AA             ;		M=1 if DE > HL
0552   D7AA 7C          CMP_HL_DE	MOV	A,H
0553   D7AB BA          		CMP	D		;H-D
0554   D7AC C0          		RNZ			;M flag set if D > H
0555   D7AD 7D          		MOV	A,L
0556   D7AE BB          		CMP	E		;L-E
0557   D7AF C9          		RET
0558   D7B0             
0559   D7B0             
0560   D7B0 79          PUT_3C_SPACES	MOV	A,C		;Print 3C Spaces
0561   D7B1 B7          		ORA	A
0562   D7B2 C8          		RZ
0563   D7B3 0D          		DCR	C		;Count down Prespaces
0564   D7B4 CD E7 E8    		CALL	PRINTI		;Print pre spaces
0565   D7B7 20 20 20 00 		.text "   \000"
0566   D7BB C3 B0 D7    		JMP	PUT_3C_SPACES
0567   D7BE             
0568   D7BE             
0569   D7BE             ;-----------------------------------------------------------------------------
0570   D7BE             ;EDIT MEMORY
0571   D7BE             ;Edit memory from a starting address until X is pressed.
0572   D7BE             ;Display mem loc, contents, and results of write.
0573   D7BE             ;-----------------------------------------------------------------------------
0574   D7BE CD FF DA    MEM_EDIT:	CALL	SPACE_GET_WORD	;Input Address
0575   D7C1 EB          		XCHG			;HL = Address to edit
0576   D7C2 CD 97 E8    ME_LP		CALL	PUT_NEW_LINE
0577   D7C5 CD B4 E8    		CALL	PUT_HL		;Print current contents of memory
0578   D7C8 CD 53 DB    		CALL	PUT_SPACE
0579   D7CB 3E 3A       		MVI	A, ':'
0580   D7CD CD 3A E9    		CALL	PUT_CHAR
0581   D7D0 CD 53 DB    		CALL	PUT_SPACE
0582   D7D3 7E          		MOV	A, M
0583   D7D4 CD BF E8    		CALL	PUT_BYTE
0584   D7D7 CD CE DA    		CALL	SPACE_GET_BYTE	;Input new value or Exit if invalid
0585   D7DA D8          		RC			;Exit to Command Loop
0586   D7DB 77          		MOV	M, A		;or Save new value
0587   D7DC CD 53 DB    		CALL	PUT_SPACE
0588   D7DF 7E          		MOV	A, M
0589   D7E0 CD BF E8    		CALL	PUT_BYTE
0590   D7E3 23          		INX	H		;Advance to next location
0591   D7E4 C3 C2 D7    		JMP	ME_LP		;repeat input
0592   D7E7             
0593   D7E7             
0594   D7E7             ;=============================================================================
0595   D7E7             ;	MEM_EXEC - Execute at
0596   D7E7             ;	Get an address and jump to it
0597   D7E7             ;-----------------------------------------------------------------------------
0598   D7E7 CD FF DA    MEM_EXEC:	CALL	SPACE_GET_WORD	;Input address
0599   D7EA EB          		XCHG			;HL = Address
0600   D7EB E9          		PCHL			;Jump to HL
0601   D7EC             
0602   D7EC             
0603   D7EC             ;===============================================
0604   D7EC             ;Input from port, print contents
0605   D7EC CD CE DA    PORT_INP:	CALL	SPACE_GET_BYTE
0606   D7EF 47          		MOV	B, A
0607   D7F0 CD 53 DB    		CALL	PUT_SPACE
0608   D7F3 0E DB       		MVI	C, 0DBh
0609   D7F5 CD 05 D8    		CALL	GOBYTE
0610   D7F8 CD BF E8    		CALL	PUT_BYTE
0611   D7FB C9          		RET
0612   D7FC             
0613   D7FC             ;Get a port address, write byte out
0614   D7FC CD CE DA    PORT_OUT:	CALL	SPACE_GET_BYTE
0615   D7FF 47          		MOV	B, A
0616   D800 CD CE DA    		CALL	SPACE_GET_BYTE
0617   D803 0E D3       		MVI	C, 0D3h
0618   D805             
0619   D805             ;===============================================
0620   D805             ;GOBYTE -- Push a two-byte instruction and RET
0621   D805             ;         and jump to it
0622   D805             ;
0623   D805             ;pre: B register contains operand
0624   D805             ;pre: C register contains opcode
0625   D805             ;post: code executed, returns to caller
0626   D805             ;-----------------------------------------------
0627   D805 21 00 00    GOBYTE:		LXI	H, 0000
0628   D808 39          		DAD	SP	;HL = STACK
0629   D809 2B          		DCX	H
0630   D80A 36 C9       		MVI	M, 0C9h	;Stuff RET instruction in STACK RAM
0631   D80C 2B          		DCX	H
0632   D80D 70          		MOV	M, B	;Stuff Port
0633   D80E 2B          		DCX	H
0634   D80F 71          		MOV	M, C	;Stuff Input or Output instruction
0635   D810 E9          		PCHL
0636   D811             
0637   D811             
0638   D811             
0639   D811             ;=====================================================================================================
0640   D811             ;Monitor Section for the SD Memory Card.  Not required for BIOS
0641   D811             ;=====================================================================================================
0642   D811             
0643   D811             
0644   D811 CD E7 E8    SD_MENU:	CALL 	PRINTI		;Display Menu
0645   D814 0D0A2B202D53 		.text "\r\n+ -Select"
0645   D81A 656C656374
0646   D81F 0D0A2D202D44 		.text "\r\n- -Deselct"
0646   D825 6573656C6374
0647   D82B 0D0A43202D43 		.text "\r\nC -Clock/RX"
0647   D831 6C6F636B2F5258
0648   D838 0D0A58202D54 		.text "\r\nX -TX MSG"
0648   D83E 58204D5347
0649   D843 0D0A49202D49 		.text "\r\nI -Init"
0649   D849 6E6974
0650   D84C 0D0A53202D53 		.text "\r\nS -SET SECTOR"
0650   D852 455420534543544F52
0651   D85B 0D0A52202D52 		.text "\r\nR -READ SECTOR"
0651   D861 45414420534543544F52
0652   D86B 0D0A57202D57 		.text "\r\nW -WRITE SECTOR"
0652   D871 5249544520534543544F52
0653   D87C 0D0A46202D49 		.text "\r\nF -INITFAT"
0653   D882 4E4954464154
0654   D888 0D0A51202D46 		.text "\r\nQ -Find File"
0654   D88E 696E642046696C65
0655   D896 0D0A44202D44 		.text "\r\nD -Directory"
0655   D89C 69726563746F7279
0656   D8A4 0D0A4B202D52 		.text "\r\nK -READ LOG-D/F SECTOR"
0656   D8AA 454144204C4F472D442F4620534543544F52
0657   D8BC 0D0A4220202D 		.text "\r\nB  -Select FCB#"		
0657   D8C2 53656C6563742046434223
0658   D8CD 0D0A312D3420 		.text "\r\n1-4 -Open File #"
0658   D8D3 2D4F70656E2046696C652023
0659   D8DF 00          		.text "\000"
0660   D8E0 CD E7 E8    SD_MENUCMD:	CALL 	PRINTI		;Display Menu Prompt
0661   D8E3 0D0A53443E00 		.text "\r\nSD>\000"
0662   D8E9 3E FF       		MVI	A,0FFH
0663   D8EB 32 81 FD    		STA	ECHO_ON		;TURN ON ECHO
0664   D8EE CD 27 E9    		CALL 	GET_CHAR	;get char
0665   D8F1 FE 1B       		CPI	27		;<Esc>?
0666   D8F3 CA E5 D5    		JZ	MAIN_MENU
0667   D8F6 CD C8 F0    		CALL	TO_UPPER	;to upper case
0668   D8F9 FE 49       		CPI 	'I'		;Branch to Command entered
0669   D8FB CA AA DA    		JZ 	DO_INIT_SDCARD	; I = Init SD CARD
0670   D8FE FE 2B       		CPI 	'+'		;
0671   D900 CA B0 DA    		JZ 	DO_SD_SELECT	; + = Select SD CARD
0672   D903 FE 2D       		CPI 	'-'		;
0673   D905 CA B6 DA    		JZ 	DO_SD_DESELECT	; - = Deselect SD CARD
0674   D908 FE 43       		CPI 	'C'		;
0675   D90A CA BC DA    		JZ 	DO_SD_CLK	; C = Clock SD CARD
0676   D90D FE 58       		CPI 	'X'		;
0677   D90F CA 86 DA    		JZ 	DO_SD_TXM	; T = TX MSG SD CARD
0678   D912 FE 53       		CPI 	'S'		;
0679   D914 CA DB D9    		JZ 	DO_SD_PARAM	; S = SET SECTOR
0680   D917 FE 52       		CPI 	'R'		;
0681   D919 CA 2D DA    		JZ 	DO_SD_READSEC	; R = READ SECTOR
0682   D91C FE 57       		CPI 	'W'		;
0683   D91E CA 1B DA    		JZ 	DO_SD_WRITESEC	; W = WRITE SECTOR
0684   D921 FE 46       		CPI 	'F'		;
0685   D923 CA 97 D9    		JZ 	DO_SD_IFAT	; F = INIT FAT
0686   D926 FE 51       		CPI 	'Q'		;
0687   D928 CA 8B D9    		JZ 	DO_SD_FINDFILE	; Q = FIND FILE
0688   D92B FE 44       		CPI 	'D'		;
0689   D92D CA 76 D9    		JZ 	DO_DIR		; D = DIRECTORY
0690   D930 FE 4B       		CPI 	'K'		;
0691   D932 CA 52 DA    		JZ 	DO_DK_READSEC	; K = READ LOGICAL DISK SECTOR
0692   D935 FE 42       		CPI 	'B'		;
0693   D937 CA 9D D9    		JZ 	DO_SEL_FCB	; B = SELECT FCB#
0694   D93A 21 00 FD    		LXI	H,SDISKA
0695   D93D FE 31       		CPI 	'1'		;
0696   D93F CA 5D D9    		JZ 	DO_OPEN		; 1 = OPEN 1
0697   D942 21 20 FD    		LXI	H,SDISKB
0698   D945 FE 32       		CPI 	'2'		;
0699   D947 CA 5D D9    		JZ 	DO_OPEN		; 2 = OPEN 2
0700   D94A 21 40 FD    		LXI	H,SDISKC
0701   D94D FE 33       		CPI 	'3'		;
0702   D94F CA 5D D9    		JZ 	DO_OPEN		; 3 = OPEN 3
0703   D952 21 60 FD    		LXI	H,SDISKD
0704   D955 FE 34       		CPI 	'4'		;
0705   D957 CA 5D D9    		JZ 	DO_OPEN		; 4 = OPEN 4
0706   D95A C3 11 D8    		JMP 	SD_MENU
0707   D95D             
0708   D95D             
0709   D95D             ;-------------------------------------------------
0710   D95D 22 83 FD    DO_OPEN		SHLD	FCB_PTR
0711   D960 CD 3C F0    		CALL	INPUT_FNAME
0712   D963 2A 83 FD    		LHLD	FCB_PTR
0713   D966 23          		INX	H		;FNAME
0714   D967 EB          		XCHG
0715   D968 21 C8 FD    		LXI	H,FILENAME
0716   D96B 06 0B       		MVI	B,11
0717   D96D CD 2C F1    		CALL	COPY_RAM
0718   D970 CD A0 EB    		CALL	SD_OPEN
0719   D973 C3 E0 D8    		JMP	SD_MENUCMD
0720   D976             
0721   D976             ;-------------------------------------------------
0722   D976 CD 97 E8    DO_DIR		CALL	PUT_NEW_LINE
0723   D979 CD A7 E9    		CALL	SD_LDIR1
0724   D97C CA E0 D8    SDLF_LP 	JZ	SD_MENUCMD		;End of list
0725   D97F CD 75 F0    		CALL	PRINT_FILENAME
0726   D982 CD 97 E8    		CALL	PUT_NEW_LINE
0727   D985 CD BD E9    		CALL	SD_LDIRN
0728   D988 C3 7C D9    		JMP	SDLF_LP
0729   D98B             
0730   D98B             ;-------------------------------------------------
0731   D98B CD 3C F0    DO_SD_FINDFILE	CALL	INPUT_FNAME
0732   D98E DA 11 D8    		JC	SD_MENU		;ABORT ON <ESC>
0733   D991 CD E5 E9    		CALL	SDV_FIND_FILE1
0734   D994 C3 E0 D8    		JMP	SD_MENUCMD
0735   D997             
0736   D997             ;-------------------------------------------------
0737   D997 CD F2 EB    DO_SD_IFAT	CALL	INIT_FAT
0738   D99A C3 11 D8    		JMP 	SD_MENU
0739   D99D             
0740   D99D             ;-------------------------------------------------
0741   D99D CD E7 E8    DO_SEL_FCB	CALL 	PRINTI		;
0742   D9A0 0D0A46434223 		.text "\r\nFCB#\000"
0742   D9A6 00
0743   D9A7 CD 27 E9    		CALL	GET_CHAR
0744   D9AA FE 31       		CPI 	'1'		;
0745   D9AC DA E0 D8    		JC	SD_MENUCMD
0746   D9AF FE 35       		CPI 	'5'		;
0747   D9B1 D2 E0 D8    		JNC	SD_MENUCMD
0748   D9B4 3D          		DCR	A
0749   D9B5 CD 87 E9    		CALL	SET_FCB_PTR
0750   D9B8 E5          		PUSH	H
0751   D9B9 CD E7 E8    		CALL 	PRINTI		;
0752   D9BC 204643425F50 		.text " FCB_PTR:\000"
0752   D9C2 54523A00
0753   D9C6 2A 83 FD    		LHLD	FCB_PTR
0754   D9C9 CD B4 E8    		CALL	PUT_HL
0755   D9CC E1          		POP	H
0756   D9CD CD E7 E8    		CALL 	PRINTI		;
0757   D9D0 20484C3A00  		.text " HL:\000"
0758   D9D5 CD B4 E8    		CALL	PUT_HL
0759   D9D8 C3 E0 D8    		JMP	SD_MENUCMD
0760   D9DB             
0761   D9DB             ;-------------------------------------------------
0762   D9DB CD E7 E8    DO_SD_PARAM	CALL 	PRINTI		;
0763   D9DE 0D 0A 3C 00 		.text "\r\n<\000"
0764   D9E2 21 D3 FD    		LXI	H,SEC_PTR
0765   D9E5 CD D1 F0    		CALL	MOV_32_HL
0766   D9E8 CD 9E E8    		CALL	PUT_BC
0767   D9EB CD A9 E8    		CALL	PUT_DE
0768   D9EE CD E7 E8    		CALL 	PRINTI		;
0769   D9F1 3E20456E7465 		.text "> Enter 4 BYTE SECTOR#> \000"
0769   D9F7 722034204259544520534543544F52233E2000
0770   DA0A 06 04       		MVI	B,4
0771   DA0C CD D1 DA    GDW_LP		CALL	GET_BYTE
0772   DA0F 77          		MOV	M,A
0773   DA10 05          		DCR	B
0774   DA11 CA 11 D8    		JZ	SD_MENU
0775   DA14 2B          		DCX	H
0776   DA15 CD 53 DB    		CALL	PUT_SPACE
0777   DA18 C3 0C DA    		JMP	GDW_LP
0778   DA1B             
0779   DA1B             ;-------------------------------------------------
0780   DA1B CD 25 EE    DO_SD_WRITESEC	CALL	SD_WRITE_SEC
0781   DA1E C2 44 DA    		JNZ	DSDR_FAIL
0782   DA21 CD E7 E8    		CALL 	PRINTI		;
0783   DA24 0D0A2D4F4B00 		.text "\r\n-OK\000"
0784   DA2A C3 11 D8    		JMP	SD_MENU
0785   DA2D             
0786   DA2D             ;-------------------------------------------------
0787   DA2D 21 D3 FD    DO_SD_READSEC	LXI	H,SEC_PTR
0788   DA30 CD D1 F0    		CALL	MOV_32_HL	;Fetch SEC_PTR to 32bit BCDE
0789   DA33 37          		STC			;Set Carry to force Read
0790   DA34 CD BB ED    		CALL	SD_READ_SEC
0791   DA37 C2 44 DA    		JNZ	DSDR_FAIL
0792   DA3A EB          		XCHG			;Set end of buffer
0793   DA3B 21 00 FE    		LXI	H,SD_RAM_BUFFER	;Set buffer space
0794   DA3E CD 06 D7    		CALL	MEM_DUMP_LP
0795   DA41 C3 E0 D8    		JMP	SD_MENUCMD
0796   DA44 CD E7 E8    DSDR_FAIL	CALL 	PRINTI		;
0797   DA47 2D4641494C45 		.text "-FAILED\000"
0797   DA4D 4400
0798   DA4F C3 11 D8    		JMP	SD_MENU
0799   DA52             
0800   DA52             ;-------------------------------------------------
0801   DA52 CD E7 E8    DO_DK_READSEC	CALL 	PRINTI		;
0802   DA55 0D0A456E7465 		.text "\r\nEnter Log-Sector> \000"
0802   DA5B 72204C6F672D536563746F723E2000
0803   DA6A CD FF DA    		CALL	SPACE_GET_WORD
0804   DA6D FE 1B       		CPI	27
0805   DA6F CA E0 D8    		JZ	SD_MENUCMD	;On Abort...EXIT
0806   DA72 EB          		XCHG
0807   DA73 22 99 FD    		SHLD	LOGICAL_SEC
0808   DA76 CD 16 EA    		CALL	DISK_READ	;HL = Quarter Buffer
0809   DA79 E5          		PUSH	H
0810   DA7A D1          		POP	D		;DE = Quarter Buffer
0811   DA7B 01 80 00    		LXI	B,128
0812   DA7E 09          		DAD	B		;HL = Quarter Buffer +128
0813   DA7F EB          		XCHG			;HL=START, DE=STOP of Dump
0814   DA80 CD 06 D7    		CALL	MEM_DUMP_LP
0815   DA83 C3 E0 D8    		JMP	SD_MENUCMD
0816   DA86             
0817   DA86             ;-------------------------------------------------
0818   DA86 CD E7 E8    DO_SD_TXM	CALL 	PRINTI		;
0819   DA89 0D0A456E7465 		.text "\r\nEnter HEX> \000"
0819   DA8F 72204845583E2000
0820   DA97 CD D1 DA    DST_LP		CALL	GET_BYTE
0821   DA9A DA 11 D8    		JC	SD_MENU
0822   DA9D D3 30       		OUT	SPI
0823   DA9F 3E 2E       		MVI	A,'.'
0824   DAA1 CD 3A E9    		CALL	PUT_CHAR
0825   DAA4 CD 53 DB    		CALL	PUT_SPACE
0826   DAA7 C3 97 DA    		JMP	DST_LP
0827   DAAA             
0828   DAAA             ;-------------------------------------------------
0829   DAAA CD B9 EE    DO_INIT_SDCARD	CALL	INIT_SDCARD
0830   DAAD C3 E0 D8    		JMP	SD_MENUCMD
0831   DAB0             
0832   DAB0             ;-------------------------------------------------
0833   DAB0 CD AD EF    DO_SD_SELECT	CALL	SD_SELECT
0834   DAB3 C3 E0 D8    		JMP	SD_MENUCMD
0835   DAB6             
0836   DAB6             ;-------------------------------------------------
0837   DAB6 CD A6 EF    DO_SD_DESELECT	CALL	SD_DESELECT
0838   DAB9 C3 E0 D8    		JMP	SD_MENUCMD
0839   DABC             
0840   DABC             ;-------------------------------------------------
0841   DABC 06 08       DO_SD_CLK	MVI	B,08H
0842   DABE CD 53 DB    DSC_0		CALL	PUT_SPACE
0843   DAC1 CD 04 F0    		CALL	SPI_RX
0844   DAC4 CD BF E8    		CALL	PUT_BYTE
0845   DAC7 05          		DCR	B
0846   DAC8 C2 BE DA    		JNZ	DSC_0
0847   DACB C3 E0 D8    		JMP	SD_MENUCMD
0848   DACE             
0849   DACE             
0850   DACE             ;=============================================================================
0851   DACE CD 53 DB    SPACE_GET_BYTE	CALL	PUT_SPACE
0852   DAD1             
0853   DAD1             ;=============================================================================
0854   DAD1             ;GET_BYTE -- Get byte from console as hex
0855   DAD1             ;
0856   DAD1             ;in:	Nothing
0857   DAD1             ;out:	A = Byte (if CY=0)
0858   DAD1             ;	A = non-hex char input (if CY=1)
0859   DAD1             ;-----------------------------------------------------------------------------
0860   DAD1 CD 21 DB    GET_BYTE:	CALL	GET_HEX_CHAR	;Get 1st HEX CHAR
0861   DAD4 D2 DE DA    		JNC	GB_1
0862   DAD7 FE 20       		CPI	' '		;Exit if not HEX CHAR (ignoring SPACE)
0863   DAD9 CA D1 DA    		JZ	GET_BYTE	;Loop back if first char is a SPACE
0864   DADC 37          		STC			;Set Carry
0865   DADD C9          		RET			;or EXIT with delimiting char
0866   DADE D5          GB_1		PUSH	D		;Process 1st HEX CHAR
0867   DADF 07          		RLC
0868   DAE0 07          		RLC
0869   DAE1 07          		RLC
0870   DAE2 07          		RLC
0871   DAE3 E6 F0       		ANI	0F0h
0872   DAE5 57          		MOV	D,A
0873   DAE6 CD 21 DB    		CALL	GET_HEX_CHAR
0874   DAE9 D2 F4 DA    		JNC	GB_2		;If 2nd char is HEX CHAR
0875   DAEC FE 20       		CPI	' '
0876   DAEE CA F7 DA    		JZ	GB_UNDO		;If 2nd char is SPACE, Move 1st back to lower nibble
0877   DAF1 37          		STC			;Set Carry
0878   DAF2 D1          		POP	D
0879   DAF3 C9          		RET			;or EXIT with delimiting char
0880   DAF4 B2          GB_2		ORA	D
0881   DAF5 D1          		POP	D
0882   DAF6 C9          		RET
0883   DAF7 7A          GB_UNDO		MOV	A,D		;Move 1st back to lower nibble
0884   DAF8 0F          		RRC
0885   DAF9 0F          		RRC
0886   DAFA 0F          		RRC
0887   DAFB 0F          		RRC
0888   DAFC B7          GB_RET		ORA	A
0889   DAFD D1          		POP	D
0890   DAFE C9          		RET
0891   DAFF             
0892   DAFF             
0893   DAFF             ;=============================================================================
0894   DAFF CD 53 DB    SPACE_GET_WORD	CALL	PUT_SPACE
0895   DB02             
0896   DB02             ;=============================================================================
0897   DB02             ;GET_WORD -- Get word from console as hex
0898   DB02             ;
0899   DB02             ;in:	Nothing
0900   DB02             ;out:	A = non-hex char input
0901   DB02             ;	DE = Word
0902   DB02             ;-----------------------------------------------------------------------------
0903   DB02 11 00 00    GET_WORD:	LXI	D,0
0904   DB05 CD 21 DB    		CALL	GET_HEX_CHAR	;Get 1st HEX CHAR
0905   DB08 D2 12 DB    		JNC	GW_LP
0906   DB0B FE 20       		CPI	' '		;Exit if not HEX CHAR (ignoring SPACE)
0907   DB0D CA 02 DB    		JZ	GET_WORD	;Loop back if first char is a SPACE
0908   DB10 B7          		ORA	A		;Clear Carry
0909   DB11 C9          		RET			;or EXIT with delimiting char
0910   DB12 5F          GW_LP		MOV	E,A
0911   DB13 CD 21 DB    		CALL	GET_HEX_CHAR
0912   DB16 D8          		RC			;EXIT when a delimiting char is entered
0913   DB17 EB          		XCHG			;Else, shift new HEX Char Value into DE
0914   DB18 29          		DAD	H
0915   DB19 29          		DAD	H
0916   DB1A 29          		DAD	H
0917   DB1B 29          		DAD	H
0918   DB1C EB          		XCHG
0919   DB1D B3          		ORA	E
0920   DB1E C3 12 DB    		JMP	GW_LP
0921   DB21             
0922   DB21             
0923   DB21             
0924   DB21             ;===============================================
0925   DB21             ;Get HEX CHAR
0926   DB21             ;in:	Nothing
0927   DB21             ;out:	A = Value of HEX Char when CY=0
0928   DB21             ;	A = Received (non-hex) char when CY=1
0929   DB21             ;-----------------------------------------------
0930   DB21 CD 27 E9    GET_HEX_CHAR:	CALL	GET_CHAR
0931   DB24 FE 30       ASC2HEX		CPI	'0'
0932   DB26 FA 42 DB    		JM	GHC_NOT_RET
0933   DB29 FE 3A       		CPI	'9'+1
0934   DB2B FA 46 DB    		JM	GHC_NRET
0935   DB2E FE 41       		CPI	'A'
0936   DB30 FA 42 DB    		JM	GHC_NOT_RET
0937   DB33 FE 47       		CPI	'F'+1
0938   DB35 FA 44 DB    		JM	GHC_ARET
0939   DB38 FE 61       		CPI	'a'
0940   DB3A FA 42 DB    		JM	GHC_NOT_RET
0941   DB3D FE 67       		CPI	'f'+1
0942   DB3F FA 44 DB    		JM	GHC_ARET
0943   DB42 37          GHC_NOT_RET	STC
0944   DB43 C9          		RET
0945   DB44 D6 07       GHC_ARET	SUI	07h
0946   DB46 E6 0F       GHC_NRET	ANI	0Fh
0947   DB48 C9          		RET
0948   DB49             
0949   DB49             
0950   DB49             
0951   DB49             
0952   DB49             ;===============================================
0953   DB49             ;ASCHEX -- Convert ASCII coded hex to nibble
0954   DB49             ;
0955   DB49             ;pre:	A register contains ASCII coded nibble
0956   DB49             ;post:	A register contains nibble
0957   DB49             ;-----------------------------------------------
0958   DB49 D6 30       ASCHEX:		SUI	30h
0959   DB4B FE 0A       		CPI	0Ah
0960   DB4D F8          		RM
0961   DB4E E6 5F       		ANI	5Fh
0962   DB50 D6 07       		SUI	07h
0963   DB52 C9          		RET
0964   DB53             
0965   DB53             
0966   DB53             
0967   DB53             
0968   DB53             
0969   DB53             
0970   DB53             ;===============================================
0971   DB53             ;PUT_SPACE -- Print a space to the console
0972   DB53             ;
0973   DB53             ;pre: none
0974   DB53             ;post: 0x20 printed to console
0975   DB53             ;-----------------------------------------------
0976   DB53 3E 20       PUT_SPACE:	MVI	A, ' '
0977   DB55 C3 3A E9    		JMP	PUT_CHAR
0978   DB58             
0979   DB58             
0980   DB58             
0981   DB58             
0982   DB58             
0983   DB58             ;----------------------------------------------------------------------------------------------------; ASCII HEXFILE TRANSFER
0984   DB58             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
0985   DB58             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
0986   DB58             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
0987   DB58             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
0988   DB58             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
0989   DB58             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
0990   DB58             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
0991   DB58             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
0992   DB58             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
0993   DB58             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
0994   DB58             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
0995   DB58             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
0996   DB58             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
0997   DB58             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
0998   DB58             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
0999   DB58             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1000   DB58             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1001   DB58             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1002   DB58             ;----------------------------------------------------------------------------------------------------; ASCII HEXFILE TRANSFER
1003   DB58 3E 00       GETHEXFILE	MVI	A,0
1004   DB5A 5F          		MOV	E,A		;ZERO ERROR COUNTER
1005   DB5B 32 81 FD    		STA	ECHO_ON		;TURN OFF ECHO
1006   DB5E C3 69 DB    		JMP	GHDOLINE
1007   DB61             
1008   DB61 CD 27 E9    GHWAIT		CALL	GET_CHAR
1009   DB64 FE 3A       		CPI	':'
1010   DB66 C2 61 DB    		JNZ	GHWAIT
1011   DB69             
1012   DB69 CD D1 DA    GHDOLINE	CALL	GET_BYTE	;GET BYTE COUNT
1013   DB6C 4F          		MOV	C,A		;BYTE COUNTER
1014   DB6D 57          		MOV	D,A		;CHECKSUM
1015   DB6E             
1016   DB6E CD D1 DA    		CALL	GET_BYTE	;GET HIGH ADDRESS
1017   DB71 67          		MOV	H,A
1018   DB72 82          		ADD	D
1019   DB73 57          		MOV	D,A
1020   DB74             
1021   DB74 CD D1 DA    		CALL	GET_BYTE	;GET LOW ADDRESS
1022   DB77 6F          		MOV	L,A
1023   DB78 82          		ADD	D
1024   DB79 57          		MOV	D,A
1025   DB7A             
1026   DB7A CD D1 DA    		CALL	GET_BYTE	;GET RECORD TYPE
1027   DB7D FE 01       		CPI	1
1028   DB7F CA 9E DB    		JZ	GHEND	;IF RECORD TYPE IS 01 THEN END
1029   DB82 82          		ADD	D
1030   DB83 57          		MOV	D,A
1031   DB84             
1032   DB84 CD D1 DA    GHLOOP		CALL	GET_BYTE	;GET DATA
1033   DB87 77          		MOV	M,A
1034   DB88 82          		ADD	D
1035   DB89 57          		MOV	D,A
1036   DB8A 23          		INX	H
1037   DB8B             
1038   DB8B 0D          		DCR	C
1039   DB8C C2 84 DB    		JNZ	GHLOOP
1040   DB8F             
1041   DB8F CD D1 DA    		CALL	GET_BYTE	;GET CHECKSUM
1042   DB92 82          		ADD	D
1043   DB93 CA 61 DB    		JZ	GHWAIT
1044   DB96 1C          		INR	E
1045   DB97 C2 61 DB    		JNZ	GHWAIT
1046   DB9A 1D          		DCR	E
1047   DB9B C3 61 DB    		JMP	GHWAIT
1048   DB9E             
1049   DB9E CD E7 E8    GHEND		CALL	PRINTI
1050   DBA1 0D0A48455820 		.text "\r\nHEX TRANSFER COMPLETE ERRORS=\000"
1050   DBA7 5452414E5346455220434F4D504C455445204552524F52533D00
1051   DBC1 7B          		MOV	A,E
1052   DBC2 CD BF E8    		CALL	PUT_BYTE
1053   DBC5 C3 21 DE    		JMP	PURGE
1054   DBC8             
1055   DBC8             
1056   DBC8             ;----------------------------------------------------------------------------------------------------; XMODEM ROUTINES
1057   DBC8             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1058   DBC8             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1059   DBC8             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1060   DBC8             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1061   DBC8             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1062   DBC8             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1063   DBC8             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1064   DBC8             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1065   DBC8             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1066   DBC8             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1067   DBC8             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1068   DBC8             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1069   DBC8             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1070   DBC8             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1071   DBC8             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1072   DBC8             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1073   DBC8             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1074   DBC8             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1075   DBC8             ;----------------------------------------------------------------------------------------------------; XMODEM ROUTINES
1076   DBC8             
1077   DBC8             SOH	.equ	1	;Start of Header
1078   DBC8             EOT	.equ	4	;End of Transmission
1079   DBC8             ACK	.equ	6
1080   DBC8             DLE	.equ	16
1081   DBC8             DC1	.equ	17	; (X-ON)
1082   DBC8             DC3	.equ	19	; (X-OFF)
1083   DBC8             NAK	.equ	21
1084   DBC8             SYN	.equ	22
1085   DBC8             CAN	.equ	24	;(Cancel)
1086   DBC8             
1087   DBC8             ;---------------------------------------------------------------------------------
1088   DBC8             ;XMODEM MENU
1089   DBC8             ;ENTRY:	TOP OF STACK HOLDS RETURN ADDRESS (EXIT MECHANISM IF XMODEM IS CANCELLED)
1090   DBC8             ;---------------------------------------------------------------------------------
1091   DBC8 CD 53 DB    XMODEM		CALL	PUT_SPACE
1092   DBCB CD 27 E9    		CALL	GET_CHAR	;get char
1093   DBCE E6 5F       		ANI	5Fh		;to upper case
1094   DBD0 FE 44       		CPI	'D'
1095   DBD2 CA E0 DB    		JZ	XMDN		; D = DOWNLOAD
1096   DBD5 FE 55       		CPI	'U'
1097   DBD7 CA FC DB    		JZ	XMUP		; U = UPLOAD
1098   DBDA CD E7 E8    		CALL 	PRINTI
1099   DBDD 3F 00       		.text "?\000"
1100   DBDF C9          		RET
1101   DBE0             
1102   DBE0             ;---------------------------------------------------------------------------------
1103   DBE0             ;XMDN - XMODEM DOWNLOAD (send file from IMSAI to Terminal)
1104   DBE0             ;INPUT STARTING ADDRESS AND COUNT OF BLOCKS (WORD)
1105   DBE0             ;WAIT FOR 'C' OR NAK FROM HOST TO START CRC/CS TRANSFER
1106   DBE0             ;---------------------------------------------------------------------------------
1107   DBE0 CD FF DA    XMDN		CALL	SPACE_GET_WORD	;Input Address
1108   DBE3 EB          		XCHG			;HL = Address to SAVE DATA
1109   DBE4 CD FF DA    		CALL	SPACE_GET_WORD	;Input #Blocks to Send
1110   DBE7             					;DE = Count of Blocks
1111   DBE7             
1112   DBE7 7A          		MOV	A,D
1113   DBE8 B3          		ORA	E
1114   DBE9 C8          		RZ			;Exit if Block Count = 0
1115   DBEA             
1116   DBEA             	;HL = Address of data to send from the IMSAI 8080
1117   DBEA             	;DE = Count of Blocks to send.
1118   DBEA             
1119   DBEA CD 0C DC    		CALL	XMS_INIT	;Starts the Seq, Sets the CS/CRC format
1120   DBED             					;Cancelled Transfers will cause a RET
1121   DBED             
1122   DBED CD 34 DC    XMDN_LP		CALL	XMS_SEND	;Sends the packet @HL, Resends if NAK
1123   DBF0             					;Cancelled Transfers will cause a RET
1124   DBF0 1B          		DCX	D
1125   DBF1 7A          		MOV	A,D
1126   DBF2 B3          		ORA	E
1127   DBF3 C2 ED DB    		JNZ	XMDN_LP
1128   DBF6             
1129   DBF6 CD 8B DC    		CALL	XMS_EOT		;Send End of Transmission
1130   DBF9 C3 21 DE    		JMP	PURGE
1131   DBFC             
1132   DBFC             
1133   DBFC             ;---------------------------------------------------------------------------------
1134   DBFC             ;XMUP - XMODEM UPLOAD (receive file from Terminal to IMSAI 8080)
1135   DBFC             ;INPUT STARTING ADDRESS
1136   DBFC             ;SEND 'C' OR NAK TO HOST TO START CRC/CS TRANSFER
1137   DBFC             ;---------------------------------------------------------------------------------
1138   DBFC CD FF DA    XMUP		CALL	SPACE_GET_WORD	;Input Address
1139   DBFF EB          		XCHG			;HL = Address to SAVE DATA
1140   DC00             
1141   DC00             	;HL = Address of where data is to be received
1142   DC00             
1143   DC00 CD E1 DC    		CALL	XMR_INIT	;Starts the transfer & Receives first PACKET
1144   DC03             					;Cancelled Transfers will cause a RET
1145   DC03             
1146   DC03 CD 1D DD    XMUP_LP		CALL	XMR_RECV	;Receives the next packet @HL, Resends if NAK
1147   DC06             					;Cancelled Transfers will cause a RET
1148   DC06 DA 03 DC    		JC	XMUP_LP		;Jump until EOT Received
1149   DC09 C3 21 DE    		JMP	PURGE
1150   DC0C             
1151   DC0C             
1152   DC0C             
1153   DC0C             ;---------------------------------------------------------------------------------
1154   DC0C             ;INIT FOR SENDING XMODEM PROTOCOL, GET NAK OR 'C', SAVE THE XMTYPE
1155   DC0C             ;---------------------------------------------------------------------------------
1156   DC0C 3E 01       XMS_INIT	MVI	A,1		;First SEQ number
1157   DC0E 32 87 FD    		STA	XMSEQ
1158   DC11             
1159   DC11 06 0A       		MVI	B,10		;10 retries for initiating the transfer
1160   DC13 3E 2D       XMS_INIT_LP	MVI	A,45		;GET CHAR, 45 SECONDS TIMEOUT (EXPECT C OR NAK)
1161   DC15 CD 00 DE    		CALL	TIMED_GETCHAR
1162   DC18 DA BD DC    		JC	XM_CANCEL	;Cancel if Host Timed out
1163   DC1B             
1164   DC1B FE 15       		CPI	NAK		;If NAK, Start Checksum Download
1165   DC1D CA 2C DC    		JZ	XMS_DO
1166   DC20 FE 43       		CPI	'C'		;If C, Start CRC Download
1167   DC22 CA 2C DC    		JZ	XMS_DO
1168   DC25 05          		DCR	B		;Count down Retries
1169   DC26 C2 13 DC    		JNZ	XMS_INIT_LP
1170   DC29 C3 BD DC    		JMP	XM_CANCEL	;Cancel XModem if all retries exhausted
1171   DC2C             
1172   DC2C 32 88 FD    XMS_DO		STA	XMTYPE
1173   DC2F C9          		RET
1174   DC30             
1175   DC30             ;---------------------------------------------------------------------------------
1176   DC30             ;SEND A PACKET (RESEND UPON NAK)
1177   DC30             ;---------------------------------------------------------------------------------
1178   DC30 01 80 FF    XMS_RESEND	LXI	B,0FF80h
1179   DC33 09          		DAD	B
1180   DC34 D5          XMS_SEND	PUSH	D
1181   DC35 3E 01       		MVI	A,SOH		;SEND THE HEADER FOR CRC OR CHECKSUM
1182   DC37 CD 3A E9    		CALL	PUT_CHAR
1183   DC3A 3A 87 FD    		LDA	XMSEQ
1184   DC3D CD 3A E9    		CALL	PUT_CHAR
1185   DC40 2F          		CMA
1186   DC41 CD 3A E9    		CALL	PUT_CHAR
1187   DC44 11 00 00    		LXI	D,0000H		;Init DE=0000 (CRC Accumulator)
1188   DC47 0E 00       		MVI	C,0		;Init C=00 (CS Accumulator)
1189   DC49 06 80       		MVI	B,128		;Count 128 bytes per block
1190   DC4B 7E          XMS_BLP		MOV	A,M		;Fetch bytes to send  -------------------\
1191   DC4C CD 3A E9    		CALL	PUT_CHAR	;Send them
1192   DC4F 81          		ADD	C		;Update the CS
1193   DC50 4F          		MOV	C,A
1194   DC51 7E          		MOV	A,M
1195   DC52 CD D0 DD    		CALL	CRC_UPDATE	;Update the CRC
1196   DC55 23          		INX	H		;Advance to next byte in block
1197   DC56 05          		DCR	B		;Count down bytes sent
1198   DC57 C2 4B DC    		JNZ	XMS_BLP		;Loop back until 128 bytes are sent -----^
1199   DC5A 3A 88 FD    		LDA	XMTYPE
1200   DC5D FE 15       		CPI	NAK		;If NAK, send Checksum
1201   DC5F CA 67 DC    		JZ	XMS_CS		;----------------------v
1202   DC62 7A          		MOV	A,D		;else, Send the CRC next
1203   DC63 CD 3A E9    		CALL	PUT_CHAR
1204   DC66 4B          		MOV	C,E
1205   DC67 79          XMS_CS		MOV	A,C		;----------------------/
1206   DC68 CD 3A E9    		CALL	PUT_CHAR
1207   DC6B             					;Packet Sent, get Ack/Nak Response
1208   DC6B 3E 2D       		MVI	A,45		;GET CHAR, 45 SECONDS TIMEOUT (EXPECT C OR NAK)
1209   DC6D CD 00 DE    		CALL	TIMED_GETCHAR
1210   DC70 D1          		POP	D
1211   DC71             
1212   DC71 DA BD DC    		JC	XM_CANCEL	;Cancel download if no response within 45 seconds
1213   DC74 FE 15       		CPI	NAK
1214   DC76 CA 30 DC    		JZ	XMS_RESEND	;Loop back to resend packet
1215   DC79 FE 18       		CPI	CAN
1216   DC7B CA BD DC    		JZ	XM_CANCEL
1217   DC7E FE 06       		CPI	ACK
1218   DC80 C2 BD DC    		JNZ	XM_CANCEL
1219   DC83             
1220   DC83 3A 87 FD    		LDA	XMSEQ
1221   DC86 3C          		INR	A		;NEXT SEQ
1222   DC87 32 87 FD    		STA	XMSEQ
1223   DC8A C9          		RET
1224   DC8B             
1225   DC8B             
1226   DC8B             ;---------------------------------------------------------------------------------
1227   DC8B             ;XMDN - DOWNLOAD XMODEM PACKET
1228   DC8B             ;---------------------------------------------------------------------------------
1229   DC8B 3E 04       XMS_EOT		MVI	A,EOT		;HANDLE THE END OF TRANSFER FOR CRC OR CHECKSUM
1230   DC8D CD 3A E9    		CALL	PUT_CHAR
1231   DC90 3E 2D       		MVI	A,45		;GET CHAR, 45 SECONDS TIMEOUT (EXPECT C OR NAK)
1232   DC92 CD 00 DE    		CALL	TIMED_GETCHAR
1233   DC95 DA BD DC    		JC	XM_CANCEL
1234   DC98 FE 15       		CPI	NAK
1235   DC9A CA 8B DC    		JZ	XMS_EOT
1236   DC9D FE 06       		CPI	ACK
1237   DC9F C2 BD DC    		JNZ	XM_CANCEL
1238   DCA2             
1239   DCA2 CD E7 E8    XM_DONE		CALL	PRINTI
1240   DCA5 0D0A5452414E 		.text "\r\nTRANSFER COMPLETE\r\n\000"
1240   DCAB 5346455220434F4D504C4554450D0A00
1241   DCBB AF          		XRA	A		;CLEAR A, CY
1242   DCBC C9          		RET
1243   DCBD             
1244   DCBD             ;FINISHING CODE PRIOR TO LEAVING XMODEM
1245   DCBD 3E 18       XM_CANCEL	MVI	A,CAN
1246   DCBF CD 3A E9    		CALL	PUT_CHAR
1247   DCC2 CD 3A E9    		CALL	PUT_CHAR
1248   DCC5 CD 21 DE    		CALL	PURGE
1249   DCC8 CD E7 E8    		CALL	PRINTI
1250   DCCB 5452414E5346 		.text "TRANSFER CANCELED\r\n\000"
1250   DCD1 45522043414E43454C45440D0A00
1251   DCDF C1          		POP	B		;SCRAP CALLING ROUTINE AND HEAD TO PARENT
1252   DCE0 C9          		RET
1253   DCE1             
1254   DCE1             
1255   DCE1             
1256   DCE1             
1257   DCE1             
1258   DCE1             
1259   DCE1             ;---------------------------------------------------------------------------------
1260   DCE1             ;START XMODEM RECEIVING and RECEIVE FIRST PACKET
1261   DCE1             ;---------------------------------------------------------------------------------
1262   DCE1 1E 05       XMR_INIT	MVI	E,5		;5 ATTEMPTS TO INITIATE XMODEM CRC TRANSFER
1263   DCE3 3E 01       		MVI	A,1		;EXPECTED SEQ NUMBER starts at 1
1264   DCE5 32 87 FD    		STA	XMSEQ
1265   DCE8 CD 21 DE    XMR_CRC		CALL	PURGE
1266   DCEB 3E 43       		MVI	A,'C'		;Send C
1267   DCED 32 88 FD    		STA	XMTYPE		;Save as XM Type (CRC or CS)
1268   DCF0 CD 3A E9    		CALL	PUT_CHAR
1269   DCF3 CD A9 DD    		CALL	XMGET_HDR	;Await a packet
1270   DCF6 D2 3A DD    		JNC	XMR_TSEQ	;Jump if first packet received
1271   DCF9 C2 BD DC    		JNZ	XM_CANCEL	;Cancel if there was a response that was not a header
1272   DCFC 1D          		DCR	E		;Otherwise, if no response, retry a few times
1273   DCFD C2 E8 DC    		JNZ	XMR_CRC
1274   DD00             
1275   DD00 1E 05       		MVI	E,5		;5 ATTEMPTS TO INITIATE XMODEM CHECKSUM TRANSFER
1276   DD02 CD 21 DE    XMR_CS		CALL	PURGE
1277   DD05 3E 15       		MVI	A,NAK		;Send NAK
1278   DD07 32 88 FD    		STA	XMTYPE		;Save as XM Type (CRC or CS)
1279   DD0A CD 3A E9    		CALL	PUT_CHAR
1280   DD0D CD A9 DD    		CALL	XMGET_HDR	;Await a packet
1281   DD10 D2 3A DD    		JNC	XMR_TSEQ	;Jump if first packet received
1282   DD13 C2 BD DC    		JNZ	XM_CANCEL	;Cancel if there was a response that was not a header
1283   DD16 1D          		DCR	E		;Otherwise, if no response, retry a few times
1284   DD17 C2 02 DD    		JNZ	XMR_CS
1285   DD1A C3 BD DC    		JMP	XM_CANCEL	;Abort
1286   DD1D             
1287   DD1D             
1288   DD1D             ;--------------------- XMODEM RECEIVE
1289   DD1D             ;Entry:	XMR_TSEQ in the middle of the routine
1290   DD1D             ;Pre:	C=1 (expected first block as received when negogiating CRC or Checksum)
1291   DD1D             ;	HL=Memory to dump the file to
1292   DD1D             ;Uses:	B to count the 128 bytes per block
1293   DD1D             ;	C to track Block Number expected
1294   DD1D             ;	DE as CRC (Within Loop) (D is destroyed when Getting Header)
1295   DD1D             ;------------------------------------
1296   DD1D 3E 06       XMR_RECV	MVI	A,ACK		;Send Ack to start Receiving next packet
1297   DD1F CD 3A E9    		CALL	PUT_CHAR
1298   DD22 CD A9 DD    XMR_LP		CALL	XMGET_HDR
1299   DD25 D2 3A DD    		JNC	XMR_TSEQ
1300   DD28 E5          		PUSH	H
1301   DD29 CA 9D DD    		JZ	XMR_NAK		;NACK IF TIMED OUT
1302   DD2C E1          		POP	H
1303   DD2D FE 04       		CPI	EOT
1304   DD2F C2 BD DC    		JNZ	XM_CANCEL	;CANCEL IF CAN RECEIVED (OR JUST NOT EOT)
1305   DD32 3E 06       		MVI	A,ACK
1306   DD34 CD 3A E9    		CALL	PUT_CHAR
1307   DD37 C3 A2 DC    		JMP	XM_DONE
1308   DD3A             
1309   DD3A 4F          XMR_TSEQ	MOV	C,A
1310   DD3B 3A 87 FD    		LDA	XMSEQ
1311   DD3E B9          		CMP	C		;CHECK IF THIS SEQ IS EXPECTED
1312   DD3F CA 50 DD    		JZ	XMR_SEQ_OK	;Jump if CORRECT SEQ
1313   DD42 3D          		DCR	A		;Else test if Previous SEQ
1314   DD43 32 87 FD    		STA	XMSEQ
1315   DD46 B9          		CMP	C
1316   DD47 C2 BD DC    		JNZ	XM_CANCEL	;CANCEL IF SEQUENCE ISN'T PREVIOUS BLOCK
1317   DD4A CD 21 DE    		CALL	PURGE		;ELSE, PURGE AND SEND ACK (ASSUMING PREVIOUS ACK WAS NOT RECEIVED)
1318   DD4D C3 93 DD    		JMP	XMR_ACK
1319   DD50             
1320   DD50 06 80       XMR_SEQ_OK	MVI	B,128		;128 BYTES PER BLOCK
1321   DD52 0E 00       		MVI	C,0		;Clear Checksum
1322   DD54 11 00 00    		LXI	D,0000H		;CLEAR CRC
1323   DD57 E5          		PUSH	H		;Save HL where block is to go
1324   DD58 CD FE DD    XMR_BLK_LP	CALL	TIMED1_GETCHAR
1325   DD5B DA 9D DD    		JC	XMR_NAK
1326   DD5E 77          		MOV	M,A		;SAVE DATA BYTE
1327   DD5F CD D0 DD    		CALL	CRC_UPDATE
1328   DD62 7E          		MOV	A,M		;Update checksum
1329   DD63 81          		ADD	C
1330   DD64 4F          		MOV	C,A
1331   DD65 23          		INX	H		;ADVANCE
1332   DD66 05          		DCR	B
1333   DD67 C2 58 DD    		JNZ	XMR_BLK_LP
1334   DD6A             					;After 128 byte packet, verify error checking byte(s)
1335   DD6A 3A 88 FD    		LDA	XMTYPE		;Determine if we are using CRC or Checksum
1336   DD6D FE 15       		CPI	NAK		;If NAK, then use Checksum
1337   DD6F CA 89 DD    		JZ	XMR_CCS
1338   DD72 CD FE DD    		CALL	TIMED1_GETCHAR
1339   DD75 DA 9D DD    		JC	XMR_NAK
1340   DD78 BA          		CMP	D
1341   DD79 C2 9D DD    		JNZ	XMR_NAK
1342   DD7C CD FE DD    		CALL	TIMED1_GETCHAR
1343   DD7F DA 9D DD    		JC	XMR_NAK
1344   DD82 BB          		CMP	E
1345   DD83 C2 9D DD    		JNZ	XMR_NAK
1346   DD86 C3 93 DD    		JMP	XMR_ACK
1347   DD89             
1348   DD89 CD FE DD    XMR_CCS		CALL	TIMED1_GETCHAR
1349   DD8C DA 9D DD    		JC	XMR_NAK
1350   DD8F B9          		CMP	C
1351   DD90 C2 9D DD    		JNZ	XMR_NAK
1352   DD93             
1353   DD93             		;If we were transfering to a FILE, this is where we would write the
1354   DD93             		;sector and reset HL to the same 128 byte sector buffer.
1355   DD93             		;CALL	WRITE_SECTOR
1356   DD93             
1357   DD93             XMR_ACK		;MVI	A,ACK		;The sending of the Ack is done by
1358   DD93             		;CALL	PUT_CHAR	;the calling routine, to allow writes to disk
1359   DD93 3A 87 FD    		LDA	XMSEQ
1360   DD96 3C          		INR	A		;Advance to next SEQ BLOCK
1361   DD97 32 87 FD    		STA	XMSEQ
1362   DD9A C1          		POP	B
1363   DD9B 37          		STC			;Carry set when NOT last packet
1364   DD9C C9          		RET
1365   DD9D             
1366   DD9D E1          XMR_NAK		POP	H		;Return HL to start of block
1367   DD9E CD 21 DE    		CALL	PURGE
1368   DDA1 3E 15       		MVI	A,NAK
1369   DDA3 CD 3A E9    		CALL	PUT_CHAR
1370   DDA6 C3 22 DD    		JMP	XMR_LP
1371   DDA9             
1372   DDA9             
1373   DDA9             ;--------------------- XMODEM - GET HEADER
1374   DDA9             ;
1375   DDA9             ;pre:	Nothing
1376   DDA9             ;post:	Carry Set: A=0, (Zero set) if Timeout
1377   DDA9             ;	Carry Set: A=CAN (Not Zero) if Cancel received
1378   DDA9             ;	Carry Set: A=EOT (Not Zero) if End of Tranmission received
1379   DDA9             ;	Carry Clear and A = B = Seq if Header found and is good
1380   DDA9             ;------------------------------------------
1381   DDA9 3E 05       XMGET_HDR	MVI	A,5		;GET CHAR, 5 SECONDS TIMEOUT (EXPECT SOH)
1382   DDAB CD 00 DE    		CALL	TIMED_GETCHAR
1383   DDAE D8          		RC			;Return if Timed out
1384   DDAF FE 01       		CPI	SOH		;TEST IF START OF HEADER
1385   DDB1 CA C1 DD    		JZ	GS_SEQ		;IF SOH RECEIVED, GET SEQ NEXT
1386   DDB4 FE 04       		CPI	EOT		;TEST IF END OF TRANSMISSION
1387   DDB6 CA BE DD    		JZ	GS_ESC		;IF EOT RECEIVED, TERMINATE XMODEM
1388   DDB9 FE 18       		CPI	CAN		;TEST IF CANCEL
1389   DDBB C2 A9 DD    		JNZ	XMGET_HDR
1390   DDBE B7          GS_ESC		ORA	A		;Clear Z flag (because A<>0)
1391   DDBF 37          		STC
1392   DDC0 C9          		RET
1393   DDC1 CD FE DD    GS_SEQ		CALL	TIMED1_GETCHAR	;GET SEQ CHAR
1394   DDC4 D8          		RC			;Return if Timed out
1395   DDC5 47          		MOV	B,A		;SAVE SEQ
1396   DDC6 CD FE DD    		CALL	TIMED1_GETCHAR	;GET SEQ COMPLEMENT
1397   DDC9 D8          		RC			;Return if Timed out
1398   DDCA 2F          		CMA
1399   DDCB B8          		CMP	B		;TEST IF SEQ VALID
1400   DDCC C2 A9 DD    		JNZ	XMGET_HDR	;LOOP BACK AND TRY AGAIN IF HEADER INCORRECT (SYNC FRAME)
1401   DDCF C9          		RET
1402   DDD0             
1403   DDD0             ;------------------------------------------ CRC_UPDATE
1404   DDD0             ;HANDLE THE CRC CALCULATION FOR UP/DOWNLOADING
1405   DDD0             ;Total Time=775 cycles = 388uSec
1406   DDD0             ;In:	A  = New char to roll into CRC accumulator
1407   DDD0             ;	DE = 16bit CRC accumulator
1408   DDD0             ;Out:	DE = 16bit CRC accumulator
1409   DDD0             ;------------------------------------------
1410   DDD0             ;CRC_UPDATE	XRA	D		;4
1411   DDD0             ;		MOV	D,A		;5
1412   DDD0             ;		PUSH	B		;11
1413   DDD0             ;		MVI	B,8		;7	PRELOOP=27
1414   DDD0             ;CRCU_LP	ORA	A		;4	CLEAR CARRY
1415   DDD0             ;		MOV	A,E		;5
1416   DDD0             ;		RAL			;4
1417   DDD0             ;		MOV	E,A		;5
1418   DDD0             ;		MOV	A,D		;5
1419   DDD0             ;		RAL			;4
1420   DDD0             ;		MOV	D,A		;5
1421   DDD0             ;		JNC	CRCU_NX		;10
1422   DDD0             ;		MOV	A,D		;5
1423   DDD0             ;		XRI	10h		;7
1424   DDD0             ;		MOV	D,A		;5
1425   DDD0             ;		MOV	A,E		;5
1426   DDD0             ;		XRI	21H		;7
1427   DDD0             ;		MOV	E,A		;5
1428   DDD0             ;CRCU_NX		DCR	B		;5
1429   DDD0             ;		JNZ	CRCU_LP		;10	LOOP=91*8 (WORSE CASE)
1430   DDD0             ;		POP	B		;10	POSTLOOP=20
1431   DDD0             ;		RET			;10
1432   DDD0             
1433   DDD0             
1434   DDD0             ;------------------------------------------ CRC_UPDATE
1435   DDD0             ;HANDLE THE CRC CALCULATION FOR UP/DOWNLOADING
1436   DDD0             ;Total Time=604 cycles = 302uSec MAX
1437   DDD0             ;In:	A  = New char to roll into CRC accumulator
1438   DDD0             ;	DE = 16bit CRC accumulator
1439   DDD0             ;Out:	DE = 16bit CRC accumulator
1440   DDD0             ;------------------------------------------
1441   DDD0 EB          CRC_UPDATE	XCHG			;4
1442   DDD1 AC          		XRA	H		;4
1443   DDD2 67          		MOV	H,A		;5
1444   DDD3 29          		DAD	H		;10	Shift HL Left 1
1445   DDD4 DC F5 DD    		CC	CRC_UPC		;17 (10/61)
1446   DDD7 29          		DAD	H		;10	Shift HL Left 2
1447   DDD8 DC F5 DD    		CC	CRC_UPC		;17
1448   DDDB 29          		DAD	H		;10	Shift HL Left 3
1449   DDDC DC F5 DD    		CC	CRC_UPC		;17
1450   DDDF 29          		DAD	H		;10	Shift HL Left 4
1451   DDE0 DC F5 DD    		CC	CRC_UPC		;17
1452   DDE3 29          		DAD	H		;10	Shift HL Left 5
1453   DDE4 DC F5 DD    		CC	CRC_UPC		;17
1454   DDE7 29          		DAD	H		;10	Shift HL Left 6
1455   DDE8 DC F5 DD    		CC	CRC_UPC		;17
1456   DDEB 29          		DAD	H		;10	Shift HL Left 7
1457   DDEC DC F5 DD    		CC	CRC_UPC		;17
1458   DDEF 29          		DAD	H		;10	Shift HL Left 8
1459   DDF0 DC F5 DD    		CC	CRC_UPC		;17
1460   DDF3 EB          		XCHG			;4
1461   DDF4 C9          		RET			;10
1462   DDF5             
1463   DDF5 7C          CRC_UPC		MOV	A,H		;5
1464   DDF6 EE 10       		XRI	10h		;7
1465   DDF8 67          		MOV	H,A		;5
1466   DDF9 7D          		MOV	A,L		;5
1467   DDFA EE 21       		XRI	21H		;7
1468   DDFC 6F          		MOV	L,A		;5
1469   DDFD C9          		RET			;10
1470   DDFE             
1471   DDFE             
1472   DDFE             ;===============================================
1473   DDFE             ;TIMED1_GETCHAR - Gets a character within 1 second
1474   DDFE             ;
1475   DDFE             ;pre:	nothing
1476   DDFE             ;post: 	Carry Set = No Char, Time Out
1477   DDFE             ;	Carry Clear, A = Char
1478   DDFE             ;-----------------------------------------------
1479   DDFE 3E 01       TIMED1_GETCHAR	MVI	A,1
1480   DE00             
1481   DE00             ;===============================================
1482   DE00             ;TIMED_GETCHAR - Gets a character within a time limit
1483   DE00             ;
1484   DE00             ;pre:	A contains # of seconds to wait before returning
1485   DE00             ;post: 	Carry Set & Zero Set = No Char, Time Out
1486   DE00             ;	Carry Clear, A = Char
1487   DE00             ;-----------------------------------------------
1488   DE00 D5          TIMED_GETCHAR	PUSH	D
1489   DE01 C5          		PUSH	B
1490   DE02 57          		MOV	D,A
1491   DE03             		;MVI	C,0	;B,C=Loop Count down until timeout
1492   DE03 06 6B       TGC_LP1		MVI	B,107		;107 * 9.3mSec = 1 Second
1493   DE05 CD 06 E6    TGC_LP2		CALL	CONSTV	;45  TEST FOR RX DATA
1494   DE08 C2 1B DE    		JNZ	TGC_DO	;10
1495   DE0B 0D          		DCR	C	;5
1496   DE0C C2 05 DE    		JNZ	TGC_LP2	;10	;73 Cycles Loop time. 39*256*.5 ~= 9.3 mSec
1497   DE0F 05          		DCR	B
1498   DE10 C2 05 DE    		JNZ	TGC_LP2	;	1 Second waiting
1499   DE13 15          		DCR	D		;Count down Seconds until Time Out
1500   DE14 C2 03 DE    		JNZ	TGC_LP1
1501   DE17 37          		STC		;SET CARRY TO INDICATE TIME OUT
1502   DE18             		;MVI	A,0
1503   DE18 C3 1E DE    		JMP	TGC_RET
1504   DE1B CD F9 E8    TGC_DO		CALL	GET_CHAR_UART
1505   DE1E C1          TGC_RET		POP	B
1506   DE1F D1          		POP	D
1507   DE20 C9          		RET
1508   DE21             
1509   DE21             
1510   DE21             ;===============================================
1511   DE21             ;PURGE - Clears all in coming bytes until the line is clear for a full 2 seconds
1512   DE21             ;-----------------------------------------------
1513   DE21 3E 02       PURGE		MVI	A,2	;2 seconds for time out
1514   DE23 CD 00 DE    		CALL	TIMED_GETCHAR
1515   DE26 D2 21 DE    		JNC	PURGE
1516   DE29 C9          		RET
1517   DE2A             
1518   DE2A             
1519   DE2A             
1520   DE2A             ;XModem implementation on 8080 Monitor (CP/M-80)
1521   DE2A             ;
1522   DE2A             ;Terminal uploads to 8080 system:
1523   DE2A             ;-Terminal user enters command "XU aaaa"
1524   DE2A             ;-8080 "drives" the protocol since it's the receiver
1525   DE2A             ;-8080 sends <Nak> every 10 seconds until the transmitter sends a packet
1526   DE2A             ;-if transmitter does not begin within 10 trys (100 seconds), 8080 aborts XMODEM
1527   DE2A             ;-a packet is:
1528   DE2A             ; <SOH> [seq] [NOT seq] [128 bytes of data] [checksum or CRC]
1529   DE2A             ;
1530   DE2A             ;<SOH> = 1 (Start of Header)
1531   DE2A             ;<EOT> = 4 (End of Transmission)
1532   DE2A             ;<ACK> = 6
1533   DE2A             ;<DLE> = 16
1534   DE2A             ;<DC1> = 17 (X-ON)
1535   DE2A             ;<DC3> = 19 (X-OFF)
1536   DE2A             ;<NAK> = 21
1537   DE2A             ;<SYN> = 22
1538   DE2A             ;<CAN> = 24 (Cancel)
1539   DE2A             ;
1540   DE2A             ;Checksum is the Modulo 256 sum of all 128 data bytes
1541   DE2A             ;
1542   DE2A             ;                                     <<<<<          [NAK]
1543   DE2A             ;       [SOH][001][255][...][csum]    >>>>>
1544   DE2A             ;                                     <<<<<          [ACK]
1545   DE2A             ;       [SOH][002][254][...][csum]    >>>>>
1546   DE2A             ;                                     <<<<<          [ACK]
1547   DE2A             ;       [SOH][003][253][...][csum]    >>>>>
1548   DE2A             ;                                     <<<<<          [ACK]
1549   DE2A             ;       [EOT]                         >>>>>
1550   DE2A             ;                                     <<<<<          [ACK]
1551   DE2A             ;
1552   DE2A             ;-if we get <EOT> then ACK and terminate XModem
1553   DE2A             ;-if we get <CAN> then terminate XModem
1554   DE2A             ;-if checksum invalid, then NAK
1555   DE2A             ;-if seq number not correct as per [NOT seq], then NAK
1556   DE2A             ;-if seq number = previous number, then ACK (But ignore block)
1557   DE2A             ;-if seq number not the expected number, then <CAN><CAN> and terminate XModem
1558   DE2A             ;-if data not received after 10 seconds, then NAK (inc Timeout Retry)
1559   DE2A             ;-if timeout retry>10 then <CAN><CAN> and terminate XModem
1560   DE2A             ;
1561   DE2A             ;-To keep synchronized,
1562   DE2A             ;  -Look for <SOH>, qualify <SOH> by checking the [seq] / [NOT seq]
1563   DE2A             ;  -if no <SOH> found after 135 chars, then NAK
1564   DE2A             ;
1565   DE2A             ;-False EOT condtion
1566   DE2A             ;  -NAK the first EOT
1567   DE2A             ;  -if the next char is EOT again, then ACK and leave XModem
1568   DE2A             ;
1569   DE2A             ;-False <CAN>, expect a 2nd <CAN> ?
1570   DE2A             ;
1571   DE2A             ;-Using CRC, send "C" instead of <NAK> for the first packet
1572   DE2A             ;  -Send "C" every 3 seconds for 3 tries, then degrade to checksums by sending <NAK>
1573   DE2A             ;
1574   DE2A             ;
1575   DE2A             ;
1576   DE2A             ;* The character-receive subroutine should be called with a
1577   DE2A             ;parameter specifying the number of seconds to wait.  The
1578   DE2A             ;receiver should first call it with a time of 10, then <nak> and
1579   DE2A             ;try again, 10 times.
1580   DE2A             ;  After receiving the <soh>, the receiver should call the
1581   DE2A             ;character receive subroutine with a 1-second timeout, for the
1582   DE2A             ;remainder of the message and the <cksum>.  Since they are sent
1583   DE2A             ;as a continuous stream, timing out of this implies a serious
1584   DE2A             ;like glitch that caused, say, 127 characters to be seen instead
1585   DE2A             ;of 128.
1586   DE2A             ;
1587   DE2A             ;* When the receiver wishes to <nak>, it should call a "PURGE"
1588   DE2A             ;subroutine, to wait for the line to clear.  Recall the sender
1589   DE2A             ;tosses any characters in its UART buffer immediately upon
1590   DE2A             ;completing sending a block, to ensure no glitches were mis-
1591   DE2A             ;interpreted.
1592   DE2A             ;  The most common technique is for "PURGE" to call the
1593   DE2A             ;character receive subroutine, specifying a 1-second timeout,
1594   DE2A             ;and looping back to PURGE until a timeout occurs.  The <nak> is
1595   DE2A             ;then sent, ensuring the other end will see it.
1596   DE2A             ;
1597   DE2A             ;* You may wish to add code recommended by Jonh Mahr to your
1598   DE2A             ;character receive routine - to set an error flag if the UART
1599   DE2A             ;shows framing error, or overrun.  This will help catch a few
1600   DE2A             ;more glitches - the most common of which is a hit in the high
1601   DE2A             ;bits of the byte in two consecutive bytes.  The <cksum> comes
1602   DE2A             ;out OK since counting in 1-byte produces the same result of
1603   DE2A             ;adding 80H + 80H as with adding 00H + 00H.
1604   DE2A             
1605   DE2A             
1606   DE2A             
1607   DE2A             ;----------------------------------------------------------------------------------------------------; RAM TEST
1608   DE2A             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1609   DE2A             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1610   DE2A             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1611   DE2A             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1612   DE2A             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1613   DE2A             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1614   DE2A             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1615   DE2A             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1616   DE2A             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1617   DE2A             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1618   DE2A             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1619   DE2A             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1620   DE2A             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1621   DE2A             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1622   DE2A             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1623   DE2A             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1624   DE2A             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1625   DE2A             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1626   DE2A             ;----------------------------------------------------------------------------------------------------; RAM TEST
1627   DE2A             ;B=START PAGE
1628   DE2A             ;C=END PAGE
1629   DE2A CD CE DA    RAM_TEST:	CALL	SPACE_GET_BYTE
1630   DE2D 47          		MOV	B, A
1631   DE2E CD CE DA    		CALL	SPACE_GET_BYTE
1632   DE31 4F          		MOV	C, A
1633   DE32             
1634   DE32             ;Page March Test.  1 Sec/K
1635   DE32             ;
1636   DE32             ; FOR E = 00 TO FF STEP FF   'March 00 then March FF
1637   DE32             ;   FOR H = B TO C
1638   DE32             ;      PAGE(H) = E
1639   DE32             ;   NEXT H
1640   DE32             ;   FOR D = B TO C
1641   DE32             ;      PAGE(D) = NOT E
1642   DE32             ;      FOR H = B TO C
1643   DE32             ;         A = E
1644   DE32             ;         IF H = D THEN A = NOT E
1645   DE32             ;         IF PAGE(H) <> A THEN ERROR1
1646   DE32             ;      NEXT H
1647   DE32             ;   NEXT D
1648   DE32             ; NEXT E
1649   DE32             ;
1650   DE32             
1651   DE32 CD E7 E8    		CALL	PRINTI
1652   DE35 0D0A54455354 		.text "\r\nTESTING RAM\000"
1652   DE3B 494E472052414D00
1653   DE43 1E FF       		MVI	E,0FFh		;E selects the polarity of the test, ie March a page of 1'S or 0's
1654   DE45             
1655   DE45             ;Clear/Set all pages
1656   DE45 60          RT1_LP0		MOV	H,B		;HL = BASE RAM ADDRESS
1657   DE46 2E 00       		MVI	L,0
1658   DE48 7B          RT1_LP1		MOV	A,E		;CLEAR A
1659   DE49 2F          		CMA
1660   DE4A 77          RT1_LP2		MOV	M,A		;WRITE PAGE
1661   DE4B 2C          		INR	L
1662   DE4C C2 4A DE    		JNZ	RT1_LP2		;LOOP TO QUICKLY WRITE 1 PAGE
1663   DE4F 7C          		MOV	A,H
1664   DE50 24          		INR	H		;ADVANCE TO NEXT PAGE
1665   DE51 B9          		CMP	C		;COMPARE WITH END PAGE
1666   DE52 C2 48 DE    		JNZ	RT1_LP1		;LOOP UNTIL = END PAGE
1667   DE55             
1668   DE55             ;March 1 PAGE through RAM
1669   DE55 50          		MOV	D,B		;Begin with START PAGE
1670   DE56             
1671   DE56             ;Write FF to page D
1672   DE56 62          RT1_LP3		MOV	H,D		;HL = Marched Page ADDRESS
1673   DE57             		;MVI	L,0
1674   DE57 CD C2 E0    		CALL	ABORT_CHECK
1675   DE5A             
1676   DE5A 7A          		MOV	A,D
1677   DE5B 2F          		CMA
1678   DE5C D3 FF       		OUT	FPLED
1679   DE5E             		;MOV	A,E		;SET A
1680   DE5E 73          RT1_LP4		MOV	M,E		;WRITE PAGE
1681   DE5F 2C          		INR	L
1682   DE60 C2 5E DE    		JNZ	RT1_LP4		;LOOP TO QUICKLY WRITE 1 PAGE
1683   DE63             
1684   DE63             ;Test all pages for 0 (except page D = FF)
1685   DE63 60          		MOV	H,B		;HL = BASE RAM ADDRESS
1686   DE64             		;MVI	L,0
1687   DE64             
1688   DE64 7C          RT1_LP5		MOV	A,H		;IF H = D
1689   DE65 BA          		CMP	D
1690   DE66 7B          		MOV	A,E		;THEN Value = FF
1691   DE67 CA 6B DE    		JZ	RT1_LP6
1692   DE6A 2F          		CMA			;ELSE Value = 00
1693   DE6B             
1694   DE6B BE          RT1_LP6		CMP	M		;TEST RAM
1695   DE6C C2 2C E0    		JNZ	RT_FAIL1
1696   DE6F 2C          		INR	L
1697   DE70 C2 6B DE    		JNZ	RT1_LP6		;LOOP TO QUICKLY TEST 1 PAGE
1698   DE73 7C          		MOV	A,H
1699   DE74 24          		INR	H		;ADVANCE TO NEXT PAGE
1700   DE75 B9          		CMP	C		;COMPARE WITH END PAGE
1701   DE76 C2 64 DE    		JNZ	RT1_LP5		;LOOP UNTIL = END PAGE
1702   DE79             
1703   DE79             ;Write 00 back to page D
1704   DE79 62          		MOV	H,D		;HL = Marched Page ADDRESS
1705   DE7A             		;MVI	L,0
1706   DE7A 7B          		MOV	A,E
1707   DE7B 2F          		CMA
1708   DE7C 77          RT1_LP7		MOV	M,A		;WRITE PAGE
1709   DE7D 2C          		INR	L
1710   DE7E C2 7C DE    		JNZ	RT1_LP7		;LOOP TO QUICKLY WRITE 1 PAGE
1711   DE81             
1712   DE81 7A          		MOV	A,D
1713   DE82 14          		INR	D		;ADVANCE TO NEXT PAGE
1714   DE83 B9          		CMP	C		;COMPARE WITH END PAGE
1715   DE84 C2 56 DE    		JNZ	RT1_LP3		;LOOP UNTIL = END PAGE
1716   DE87             
1717   DE87 1C          		INR	E
1718   DE88 CA 45 DE    		JZ	RT1_LP0
1719   DE8B             
1720   DE8B CD E7 E8    		CALL	PRINTI
1721   DE8E 0D0A52414D20 		.text "\r\nRAM PAGE MARCH PASSED\000"
1721   DE94 50414745204D415243482050415353454400
1722   DEA6             
1723   DEA6             
1724   DEA6             ;Byte March Test.  7 Sec/K
1725   DEA6             ;
1726   DEA6             ; FOR E = 00 TO FF STEP FF   'March 00 then March FF
1727   DEA6             ;   FOR H = B TO C
1728   DEA6             ;      PAGE(H) = E
1729   DEA6             ;      FOR D = 00 TO FF
1730   DEA6             ;         PAGE(H).D = NOT E
1731   DEA6             ;         FOR L=0 TO FF
1732   DEA6             ;            IF PAGE(H).L <> E THEN
1733   DEA6             ;               IF PAGE(H).L <> NOT E THEN ERROR2
1734   DEA6             ;               IF L<>D THEN ERROR2
1735   DEA6             ;            ENDIF
1736   DEA6             ;         NEXT L
1737   DEA6             ;      NEXT D
1738   DEA6             ;   NEXT H
1739   DEA6             ; NEXT E
1740   DEA6             
1741   DEA6 1E FF       		MVI	E,0FFh		;E selects the polarity of the test, ie March a page of 1'S or 0's
1742   DEA8             
1743   DEA8             ;Clear/Set all pages
1744   DEA8             
1745   DEA8 60          RT2_LP0		MOV	H,B		;HL = BASE RAM ADDRESS
1746   DEA9 2E 00       RT2_LP1		MVI	L,0
1747   DEAB CD C2 E0    		CALL	ABORT_CHECK
1748   DEAE             
1749   DEAE 7C          		MOV	A,H
1750   DEAF 2F          		CMA
1751   DEB0 D3 FF       		OUT	FPLED
1752   DEB2             
1753   DEB2 7B          		MOV	A,E		;CLEAR A
1754   DEB3 2F          		CMA
1755   DEB4 77          RT2_LP2		MOV	M,A		;WRITE PAGE
1756   DEB5 2C          		INR	L
1757   DEB6 C2 B4 DE    		JNZ	RT2_LP2		;LOOP TO QUICKLY WRITE 1 PAGE
1758   DEB9             
1759   DEB9             
1760   DEB9 16 00       		MVI	D,0		;Starting with BYTE 00 of page
1761   DEBB             
1762   DEBB 6A          RT2_LP3		MOV	L,D		;Save at byte march ptr
1763   DEBC 7B          		MOV	A,E		;SET A
1764   DEBD 77          		MOV	M,A
1765   DEBE             
1766   DEBE             		;MOV	A,E
1767   DEBE 2F          		CMA			;CLEAR A
1768   DEBF 2E 00       		MVI	L,0
1769   DEC1             
1770   DEC1 BE          RT2_LP4		CMP	M		;TEST BYTE FOR CLEAR
1771   DEC2 CA D1 DE    		JZ	RT2_NX1
1772   DEC5 2F          		CMA			;SET A
1773   DEC6 BE          		CMP	M		;TEST BYTE FOR SET
1774   DEC7 C2 51 E0    		JNZ	RT_FAIL2	;IF NOT FULLY SET, THEN DEFINITELY FAIL
1775   DECA 7D          		MOV	A,L		;ELSE CHECK WE ARE ON MARCHED BYTE
1776   DECB BA          		CMP	D
1777   DECC C2 51 E0    		JNZ	RT_FAIL2
1778   DECF 7B          		MOV	A,E		;CLEAR A
1779   DED0 2F          		CMA
1780   DED1 2C          RT2_NX1		INR	L
1781   DED2 C2 C1 DE    		JNZ	RT2_LP4		;LOOP TO QUICKLY WRITE 1 PAGE
1782   DED5             
1783   DED5 6A          		MOV	L,D		;Save at byte march ptr
1784   DED6 7B          		MOV	A,E
1785   DED7 2F          		CMA			;CLEAR A
1786   DED8 77          		MOV	M,A
1787   DED9             
1788   DED9 14          		INR	D
1789   DEDA C2 BB DE    		JNZ	RT2_LP3
1790   DEDD             
1791   DEDD 7C          		MOV	A,H
1792   DEDE 24          		INR	H		;ADVANCE TO NEXT PAGE
1793   DEDF B9          		CMP	C		;COMPARE WITH END PAGE
1794   DEE0 C2 A9 DE    		JNZ	RT2_LP1		;LOOP UNTIL = END PAGE
1795   DEE3             
1796   DEE3 1C          		INR	E
1797   DEE4 CA A8 DE    		JZ	RT2_LP0
1798   DEE7             
1799   DEE7 CD E7 E8    		CALL	PRINTI
1800   DEEA 0D0A52414D20 		.text "\r\nRAM BYTE MARCH 1 PASSED\000"
1800   DEF0 42595445204D4152434820312050415353454400
1801   DF04             
1802   DF04             ;26 Sec/K
1803   DF04             
1804   DF04             BYTEMARCH2
1805   DF04 1E FF       		MVI	E,0FFh		;E selects the polarity of the test, ie March a page of 1'S or 0's
1806   DF06             
1807   DF06 16 00       RT4_LP0		MVI	D,0		;Starting with BYTE 00 of page
1808   DF08             
1809   DF08             ;CLEAR all pages
1810   DF08             
1811   DF08 60          		MOV	H,B		;HL = BASE RAM ADDRESS
1812   DF09 2E 00       		MVI	L,0
1813   DF0B             
1814   DF0B 7B          RT4_LP1		MOV	A,E		;CLEAR A
1815   DF0C 2F          		CMA
1816   DF0D 77          RT4_LP2		MOV	M,A		;WRITE PAGE
1817   DF0E 2C          		INR	L
1818   DF0F C2 0D DF    		JNZ	RT4_LP2		;LOOP TO QUICKLY WRITE 1 PAGE
1819   DF12             
1820   DF12 7C          		MOV	A,H
1821   DF13 24          		INR	H		;ADVANCE TO NEXT PAGE
1822   DF14 B9          		CMP	C		;COMPARE WITH END PAGE
1823   DF15 C2 0B DF    		JNZ	RT4_LP1		;LOOP UNTIL = END PAGE
1824   DF18             
1825   DF18             
1826   DF18 CD C2 E0    RT4_LP3		CALL	ABORT_CHECK
1827   DF1B 7A          		MOV	A,D
1828   DF1C 2F          		CMA
1829   DF1D D3 FF       		OUT	FPLED
1830   DF1F             
1831   DF1F             					;Write SET byte at "D" in every page
1832   DF1F 60          		MOV	H,B		;HL = BASE RAM ADDRESS
1833   DF20 6A          		MOV	L,D		;Save at byte march ptr
1834   DF21 73          RT4_LP4		MOV	M,E
1835   DF22             
1836   DF22 7C          		MOV	A,H
1837   DF23 24          		INR	H		;ADVANCE TO NEXT PAGE
1838   DF24 B9          		CMP	C		;COMPARE WITH END PAGE
1839   DF25 C2 21 DF    		JNZ	RT4_LP4		;LOOP UNTIL = END PAGE
1840   DF28             
1841   DF28             
1842   DF28 2E 00       		MVI	L,0
1843   DF2A             
1844   DF2A 60          RT4_LP5		MOV	H,B		;HL = BASE RAM ADDRESS
1845   DF2B 7D          		MOV	A,L
1846   DF2C BA          		CMP	D
1847   DF2D CA 3F DF    		JZ	RT4_LP7		;Test for marked byte in all pages
1848   DF30             
1849   DF30 7B          RT4_LP6		MOV	A,E
1850   DF31 2F          		CMA			;CLEAR A
1851   DF32 BE          		CMP	M		;TEST BYTE FOR CLEAR
1852   DF33 C2 51 E0    		JNZ	RT_FAIL2
1853   DF36             
1854   DF36 7C          		MOV	A,H
1855   DF37 24          		INR	H		;ADVANCE TO NEXT PAGE
1856   DF38 B9          		CMP	C		;COMPARE WITH END PAGE
1857   DF39 C2 30 DF    		JNZ	RT4_LP6		;LOOP UNTIL = END PAGE
1858   DF3C C3 4A DF    		JMP	RT4_NX
1859   DF3F             
1860   DF3F 7B          RT4_LP7		MOV	A,E
1861   DF40 BE          		CMP	M		;TEST BYTE FOR SET
1862   DF41 C2 51 E0    		JNZ	RT_FAIL2
1863   DF44             
1864   DF44 7C          		MOV	A,H
1865   DF45 24          		INR	H		;ADVANCE TO NEXT PAGE
1866   DF46 B9          		CMP	C		;COMPARE WITH END PAGE
1867   DF47 C2 3F DF    		JNZ	RT4_LP7		;LOOP UNTIL = END PAGE
1868   DF4A             
1869   DF4A 2C          RT4_NX		INR	L
1870   DF4B C2 2A DF    		JNZ	RT4_LP5
1871   DF4E             
1872   DF4E             					;Write CLEAR byte at "D" in every page
1873   DF4E 60          		MOV	H,B		;HL = BASE RAM ADDRESS
1874   DF4F 6A          		MOV	L,D		;Save at byte march ptr
1875   DF50 7B          RT4_LP8		MOV	A,E
1876   DF51 2F          		CMA
1877   DF52 77          		MOV	M,A
1878   DF53             
1879   DF53 7C          		MOV	A,H
1880   DF54 24          		INR	H		;ADVANCE TO NEXT PAGE
1881   DF55 B9          		CMP	C		;COMPARE WITH END PAGE
1882   DF56 C2 50 DF    		JNZ	RT4_LP8		;LOOP UNTIL = END PAGE
1883   DF59             
1884   DF59 14          		INR	D
1885   DF5A C2 18 DF    		JNZ	RT4_LP3
1886   DF5D             
1887   DF5D             
1888   DF5D 1C          		INR	E
1889   DF5E CA 06 DF    		JZ	RT4_LP0
1890   DF61             
1891   DF61 CD E7 E8    		CALL	PRINTI
1892   DF64 0D0A52414D20 		.text "\r\nRAM BYTE MARCH 2 PASSED\000"
1892   DF6A 42595445204D4152434820322050415353454400
1893   DF7E             
1894   DF7E             
1895   DF7E             BIT_MARCH
1896   DF7E             ;Bit March Test.  0.1 Sec/K
1897   DF7E             
1898   DF7E 1E 01       		MVI	E,01		;E selects the bit to march
1899   DF80             
1900   DF80             ;Clear/Set all pages
1901   DF80             
1902   DF80 60          RT3_LP1		MOV	H,B		;HL = BASE RAM ADDRESS
1903   DF81 2E 00       		MVI	L,0
1904   DF83             
1905   DF83 CD C2 E0    		CALL	ABORT_CHECK
1906   DF86             
1907   DF86 7B          		MOV	A,E		;Display bit pattern on LED PORT
1908   DF87 2F          		CMA
1909   DF88 D3 FF       		OUT	FPLED
1910   DF8A             
1911   DF8A 7B          RT3_LP2		MOV	A,E		;FETCH MARCHING BIT PATTERN
1912   DF8B 77          RT3_LP3		MOV	M,A		;WRITE PAGE
1913   DF8C 2C          		INR	L
1914   DF8D C2 8B DF    		JNZ	RT3_LP3		;LOOP TO QUICKLY WRITE 1 PAGE
1915   DF90             
1916   DF90 7C          		MOV	A,H
1917   DF91 24          		INR	H		;ADVANCE TO NEXT PAGE
1918   DF92 B9          		CMP	C		;COMPARE WITH END PAGE
1919   DF93 C2 8A DF    		JNZ	RT3_LP2		;LOOP UNTIL = END PAGE
1920   DF96             
1921   DF96 60          		MOV	H,B		;HL = BASE RAM ADDRESS
1922   DF97             ;		MVI	L,0
1923   DF97             
1924   DF97 7B          RT3_LP4		MOV	A,E		;FETCH MARCHING BIT PATTERN
1925   DF98 BE          RT3_LP5		CMP	M
1926   DF99 C2 76 E0    		JNZ	RT_FAIL3
1927   DF9C 2C          		INR	L
1928   DF9D C2 98 DF    		JNZ	RT3_LP5		;LOOP TO QUICKLY WRITE 1 PAGE
1929   DFA0             
1930   DFA0 7C          		MOV	A,H
1931   DFA1 24          		INR	H		;ADVANCE TO NEXT PAGE
1932   DFA2 B9          		CMP	C		;COMPARE WITH END PAGE
1933   DFA3 C2 97 DF    		JNZ	RT3_LP4		;LOOP UNTIL = END PAGE
1934   DFA6             
1935   DFA6             
1936   DFA6             					;0000 0010
1937   DFA6             					;...
1938   DFA6             					;1000 0000
1939   DFA6             
1940   DFA6 7B          		MOV	A,E
1941   DFA7 17          		RAL			;ROTATE THE 01 UNTIL 00
1942   DFA8 7B          		MOV	A,E
1943   DFA9 07          		RLC
1944   DFAA 5F          		MOV	E,A
1945   DFAB FE 01       		CPI	1
1946   DFAD C2 B5 DF    		JNZ	RT3_NX1
1947   DFB0 2F          		CMA			;INVERT ALL BITS
1948   DFB1 5F          		MOV	E,A
1949   DFB2 C3 80 DF    		JMP	RT3_LP1
1950   DFB5 FE FE       RT3_NX1		CPI	0FEh
1951   DFB7 C2 80 DF    		JNZ	RT3_LP1
1952   DFBA             
1953   DFBA CD E7 E8    		CALL	PRINTI
1954   DFBD 0D0A52414D20 		.text "\r\nRAM BIT MARCH PASSED\000"
1954   DFC3 424954204D415243482050415353454400
1955   DFD4             
1956   DFD4             
1957   DFD4             
1958   DFD4 1E 01       		MVI	E,01		;E selects the start sequence
1959   DFD6             
1960   DFD6             ;Clear/Set all pages
1961   DFD6             
1962   DFD6 CD C2 E0    RT5_LP1		CALL	ABORT_CHECK
1963   DFD9             
1964   DFD9 7B          		MOV	A,E		;Display bit pattern on LED PORT
1965   DFDA 2F          		CMA
1966   DFDB D3 FF       		OUT	FPLED
1967   DFDD             
1968   DFDD 60          		MOV	H,B		;HL = BASE RAM ADDRESS
1969   DFDE 2E 00       		MVI	L,0
1970   DFE0 53          		MOV	D,E
1971   DFE1             
1972   DFE1 14          RT5_LP2		INR	D
1973   DFE2 C2 E6 DF    		JNZ	RT5_NX1
1974   DFE5 14          		INR	D
1975   DFE6 72          RT5_NX1		MOV	M,D		;WRITE PAGE
1976   DFE7 2C          		INR	L
1977   DFE8 C2 E1 DF    		JNZ	RT5_LP2		;LOOP TO QUICKLY WRITE 1 PAGE
1978   DFEB             
1979   DFEB 7C          		MOV	A,H
1980   DFEC 24          		INR	H		;ADVANCE TO NEXT PAGE
1981   DFED B9          		CMP	C		;COMPARE WITH END PAGE
1982   DFEE C2 E1 DF    		JNZ	RT5_LP2		;LOOP UNTIL = END PAGE
1983   DFF1             
1984   DFF1 60          		MOV	H,B		;HL = BASE RAM ADDRESS
1985   DFF2             		;MVI	L,0
1986   DFF2 53          		MOV	D,E
1987   DFF3             
1988   DFF3 14          RT5_LP3		INR	D
1989   DFF4 C2 F8 DF    		JNZ	RT5_NX2
1990   DFF7 14          		INR	D
1991   DFF8 7A          RT5_NX2		MOV	A,D
1992   DFF9 BE          		CMP	M		;TEST
1993   DFFA C2 9A E0    		JNZ	RT_FAIL5
1994   DFFD 2C          		INR	L
1995   DFFE C2 F3 DF    		JNZ	RT5_LP3		;LOOP TO QUICKLY WRITE 1 PAGE
1996   E001             
1997   E001 7C          		MOV	A,H
1998   E002 24          		INR	H		;ADVANCE TO NEXT PAGE
1999   E003 B9          		CMP	C		;COMPARE WITH END PAGE
2000   E004 C2 F3 DF    		JNZ	RT5_LP3		;LOOP UNTIL = END PAGE
2001   E007             
2002   E007 1C          		INR	E
2003   E008 C2 D6 DF    		JNZ	RT5_LP1
2004   E00B             
2005   E00B CD E7 E8    		CALL	PRINTI
2006   E00E 0D0A52414D20 		.text "\r\nRAM SEQUENCE TEST PASSED\000"
2006   E014 53455155454E434520544553542050415353454400
2007   E029             
2008   E029 C3 E5 D5    		JMP	MAIN_MENU
2009   E02C             
2010   E02C             
2011   E02C CD E7 E8    RT_FAIL1	CALL	PRINTI
2012   E02F 0D0A52414D20 		.text "\r\nRAM FAILED PAGE MARCH AT:\000"
2012   E035 4641494C45442050414745204D415243482041543A00
2013   E04B CD B4 E8    		CALL	PUT_HL
2014   E04E C3 E5 D5    		JMP	MAIN_MENU
2015   E051             
2016   E051 CD E7 E8    RT_FAIL2	CALL	PRINTI
2017   E054 0D0A52414D20 		.text "\r\nRAM FAILED BYTE MARCH AT:\000"
2017   E05A 4641494C45442042595445204D415243482041543A00
2018   E070 CD B4 E8    		CALL	PUT_HL
2019   E073 C3 E5 D5    		JMP	MAIN_MENU
2020   E076             
2021   E076 CD E7 E8    RT_FAIL3	CALL	PRINTI
2022   E079 0D0A52414D20 		.text "\r\nRAM FAILED BIT MARCH AT:\000"
2022   E07F 4641494C454420424954204D415243482041543A00
2023   E094 CD B4 E8    		CALL	PUT_HL
2024   E097 C3 E5 D5    		JMP	MAIN_MENU
2025   E09A             
2026   E09A CD E7 E8    RT_FAIL5	CALL	PRINTI
2027   E09D 0D0A52414D20 		.text "\r\nRAM FAILED SEQUENCE TEST AT:\000"
2027   E0A3 4641494C45442053455155454E434520544553542041543A00
2028   E0BC CD B4 E8    		CALL	PUT_HL
2029   E0BF C3 E5 D5    		JMP	MAIN_MENU
2030   E0C2             
2031   E0C2             
2032   E0C2 CD 06 E6    ABORT_CHECK	CALL	CONSTV
2033   E0C5 C8          		RZ
2034   E0C6 CD 27 E9    		CALL	GET_CHAR
2035   E0C9 FE 1B       		CPI	27
2036   E0CB C0          		RNZ
2037   E0CC E1          		POP	H			;SCRAP RETURN ADDRESS AND GO TO PARENT ROUTINE
2038   E0CD CD E7 E8    		CALL	PRINTI
2039   E0D0 0D0A41424F52 		.text "\r\nABORTED\000"
2039   E0D6 54454400
2040   E0DA C9          		RET
2041   E0DB             
2042   E0DB             
2043   E0DB             ;----------------------------------------------------------------------------------------------------; FLOPPY XMODEM TRANSFERS
2044   E0DB             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2045   E0DB             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2046   E0DB             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2047   E0DB             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2048   E0DB             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2049   E0DB             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2050   E0DB             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2051   E0DB             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2052   E0DB             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2053   E0DB             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2054   E0DB             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2055   E0DB             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2056   E0DB             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2057   E0DB             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2058   E0DB             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2059   E0DB             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2060   E0DB             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2061   E0DB             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2062   E0DB             ;----------------------------------------------------------------------------------------------------; FLOPPY XMODEM TRANSFERS
2063   E0DB CD E7 E8    FXSERR:		CALL 	PRINTI		;Display Err when input is invalid
2064   E0DE 0D0A4552524F 		.text "\r\nERROR, LOGICAL SECTOR NUMBER WILL BE OUT OF RANGE\000"
2064   E0E4 522C204C4F474943414C20534543544F52204E554D4245522057494C4C204245204F5554204F462052414E474500
2065   E112             
2066   E112 CD E7 E8    FXMODEM:	CALL 	PRINTI		;Display Err when input is invalid
2067   E115 0D0A464C4F50 		.text "\r\nFLOPPY XMODEM MENU"
2067   E11B 505920584D4F44454D204D454E55
2068   E129 0D0A55207373 		.text "\r\nU ssss      - UPLOAD (WRITE DISK) ssss=Starting Sector"
2068   E12F 73732020202020202D2055504C4F414420285752495445204449534B2920737373733D5374617274696E6720536563746F72
2069   E161 0D0A44207373 		.text "\r\nD ssss cccc - DOWNLOAD (READ DISK) ssss=Starting Sector, cccc=Count of Sectors"
2069   E167 73732063636363202D20444F574E4C4F4144202852454144204449534B2920737373733D5374617274696E6720536563746F722C20636363633D436F756E74206F6620536563746F7273
2070   E1B1 0D0A20207373 		.text "\r\n  ssss = 0000 for 1st sector on track 0"
2070   E1B7 7373203D203030303020666F722031737420736563746F72206F6E20747261636B2030
2071   E1DA 0D0A20206363 		.text "\r\n  cccc = 07D2 (2002) for a whole disk (77 Tracks, 26 Sectors per)"
2071   E1E0 6363203D20303744322028323030322920666F7220612077686F6C65206469736B2028373720547261636B732C20323620536563746F72732070657229
2072   E21D 0D 0A       		.text "\r\n"
2073   E21F 0D 0A 00    		.text "\r\n\000"
2074   E222             
2075   E222 3E 3A       FXMENU_LP:	MVI	A,':'
2076   E224 CD 3A E9    		CALL	PUT_CHAR
2077   E227 CD 27 E9    		CALL 	GET_CHAR	;get char
2078   E22A FE 1B       		CPI 	27		;Branch to Command entered
2079   E22C C8          		RZ 			; <ESC> = Exit
2080   E22D FE 3F       		CPI 	'?'		;
2081   E22F CA 12 E1    		JZ 	FXMODEM		; ? = Help
2082   E232 E6 5F       		ANI 	5Fh		;to upper case
2083   E234 FE 44       		CPI 	'D'		;Branch to Command entered
2084   E236 CA 41 E2    		JZ 	FXMDN		; D = Download to Terminal (Read Disk)  D XXXX YYYY Where XXXX is Logicial sector and YYYY is Count of Sectors to send
2085   E239 FE 55       		CPI 	'U'
2086   E23B CA A3 E2    		JZ 	FXMUP		; U = Upload from Terminal (Write Disk)
2087   E23E C3 22 E2    		JMP 	FXMENU_LP
2088   E241             
2089   E241             
2090   E241 CD FF DA    FXMDN		CALL	SPACE_GET_WORD	;Input Logical Sector (to DE)
2091   E244 EB          		XCHG
2092   E245 22 8D FD    		SHLD	XSUM		;Save to sum up Logical sector + count of sectors
2093   E248 22 8F FD    		SHLD	XPOS		;Save position of next read
2094   E24B EB          		XCHG
2095   E24C CD D9 E2    		CALL	LOG2PHY		;Set the Physical Track and Sector based on the Logical Sector 0=Sector 1, Track 0
2096   E24F D2 DB E0    		JNC	FXSERR		;Sector out of range
2097   E252 EB          		XCHG
2098   E253 22 89 FD    		SHLD	XSECTOR		;Set XSECTOR & XTRACK (16 bit save to two 8 bit variables)
2099   E256 CD FF DA    		CALL	SPACE_GET_WORD	;Input # Sectors (Blocks)  to Send
2100   E259 EB          		XCHG
2101   E25A 22 8B FD    		SHLD	XCOUNT
2102   E25D EB          		XCHG			;Now test if the read of sectors will extend out of range.
2103   E25E 2A 8D FD    		LHLD	XSUM
2104   E261 19          		DAD	D		;HL = HL + DE.  START_SECTOR = START_SECTOR + SECTOR_COUNT
2105   E262 DA DB E0    		JC	FXSERR		;Sector out of range
2106   E265 11 FF FF    		LXI	D,0FFFFH
2107   E268 19          		DAD	D		;HL = HL - 1
2108   E269 EB          		XCHG
2109   E26A CD D9 E2    		CALL	LOG2PHY		;Test Start + Count - 1 <= Valid Track/Sector
2110   E26D D2 DB E0    		JNC	FXSERR		;Sector out of range
2111   E270             
2112   E270 CD 0C DC    		CALL	XMS_INIT	;Starts the Seq, Sets the CS/CRC format
2113   E273             					;Cancelled Transfers will cause a RET
2114   E273             
2115   E273 2A 8B FD    FXMDN_LP	LHLD	XCOUNT		;IF COUNT = 0 THEN EXIT
2116   E276 7C          		MOV	A,H
2117   E277 B5          		ORA	L
2118   E278 CA 9D E2    		JZ	FXMDN_DONE
2119   E27B 2B          		DCX	H		;ELSE, COUNT = COUNT - 1
2120   E27C 22 8B FD    		SHLD	XCOUNT
2121   E27F             					;Future? Check if Drive is already on correct Track
2122   E27F 3A 8A FD    		LDA	XTRACK		;Seek to correct Track (can't be much of a delay if already on correct track)
2123   E282             ;		CALL	FSEEK
2124   E282             
2125   E282 3A 89 FD    		LDA	XSECTOR		;Read the Sector
2126   E285             ;		OUT	DSECTOR
2127   E285             		;LXI	H, TRACK_BUFFER
2128   E285             ;		MVI	A,08Ch		;Read Sector (with 10mS delay for head load)
2129   E285             ;		CALL	READ_CMD
2130   E285             
2131   E285             		;LXI	H,TRACK_BUFFER	;Where to Send the Packet from
2132   E285             
2133   E285 CD 34 DC    		CALL	XMS_SEND	;Sends the packet @HL, Resends if NAK
2134   E288             					;Cancelled Transfers will cause a RET
2135   E288             
2136   E288 2A 8F FD    		LHLD	XPOS		;Advance to next Logical Sector
2137   E28B 23          		INX	H
2138   E28C 22 8F FD    		SHLD	XPOS
2139   E28F EB          		XCHG
2140   E290 CD D9 E2    		CALL	LOG2PHY		;Set the Physical Track and Sector based on the Logical Sector 0=Sector 1, Track 0
2141   E293 D2 9D E2    		JNC	FXMDN_DONE	;Sector out of range
2142   E296 EB          		XCHG
2143   E297 22 89 FD    		SHLD	XSECTOR		;Set XSECTOR & XTRACK (16 bit save to two 8 bit variables)
2144   E29A             
2145   E29A C3 73 E2    		JMP	FXMDN_LP
2146   E29D             
2147   E29D CD 8B DC    FXMDN_DONE	CALL	XMS_EOT		;Send End of Transmission
2148   E2A0 C3 21 DE    		JMP	PURGE
2149   E2A3             
2150   E2A3             
2151   E2A3             
2152   E2A3             ;Disk XMODEM
2153   E2A3 CD FF DA    FXMUP		CALL	SPACE_GET_WORD	;Input Logical Sector (to DE)
2154   E2A6 EB          		XCHG
2155   E2A7 22 8F FD    		SHLD	XPOS		;Save position of next write
2156   E2AA EB          		XCHG
2157   E2AB CD D9 E2    		CALL	LOG2PHY		;Set the Physical Track and Sector based on the Logical Sector 0=Sector 1, Track 0
2158   E2AE D2 DB E0    		JNC	FXSERR		;Sector out of range
2159   E2B1 EB          		XCHG
2160   E2B2 22 89 FD    		SHLD	XSECTOR		;Set XSECTOR & XTRACK (16 bit save to two 8 bit variables)
2161   E2B5             
2162   E2B5             
2163   E2B5             		;LXI	H,TRACK_BUFFER	;Where to receive data
2164   E2B5 CD E1 DC    		CALL	XMR_INIT	;Starts the transfer, Sets the CS/CRC format & Receives first PACKET
2165   E2B8             					;Cancelled Transfers will cause a RET
2166   E2B8             
2167   E2B8 3A 8A FD    XMU_DISK_LP	LDA	XTRACK		;Seek to correct Track (can't be much of a delay if already on correct track)
2168   E2BB             ;		CALL	FSEEK
2169   E2BB             
2170   E2BB             		;LXI	H,TRACK_BUFFER	;Where to save data
2171   E2BB 3A 89 FD    		LDA	XSECTOR		;Read the Sector
2172   E2BE             ;		OUT	DSECTOR
2173   E2BE             ;		MVI	A,0ACh		;WRITE SECTOR (w/ 10mSec Head Load Delay)
2174   E2BE             ;		CALL	WRITE_CMD
2175   E2BE             
2176   E2BE 2A 8F FD    		LHLD	XPOS		;Advance to next Logical Sector
2177   E2C1 23          		INX	H
2178   E2C2 22 8F FD    		SHLD	XPOS
2179   E2C5 EB          		XCHG
2180   E2C6 CD D9 E2    		CALL	LOG2PHY		;Set the Physical Track and Sector based on the Logical Sector 0=Sector 1, Track 0
2181   E2C9 D2 DB E0    		JNC	FXSERR		;Sector out of range
2182   E2CC EB          		XCHG
2183   E2CD 22 89 FD    		SHLD	XSECTOR		;Set XSECTOR & XTRACK (16 bit save to two 8 bit variables)
2184   E2D0             
2185   E2D0             		;LXI	H,TRACK_BUFFER	;Where to receive data
2186   E2D0 CD 1D DD    		CALL	XMR_RECV	;Receives the next packet @HL, Resends if NAK
2187   E2D3             					;Cancelled Transfers will cause a RET
2188   E2D3             
2189   E2D3 DA B8 E2    		JC	XMU_DISK_LP	;Jump until EOT Received
2190   E2D6 C3 21 DE    		JMP	PURGE
2191   E2D9             
2192   E2D9             
2193   E2D9             
2194   E2D9             
2195   E2D9             
2196   E2D9             ;---------------------------------------------------------------------------------------------------------------------
2197   E2D9             ;Logical Sector to Physical Sector and Track #
2198   E2D9             ;0=Track 0 : Sector 1
2199   E2D9             ;1=0:2, 25=0:26, 26=1:1, 2001=77:26 (Last logical Sector)
2200   E2D9             ;In:	DE = Logical Sector 0 to 2001
2201   E2D9             ;Out:	D  = Track (0-76)
2202   E2D9             ;	E  = Sector (1-26)
2203   E2D9             ;	CY = Set for Valid Log Sec
2204   E2D9             ;Uses:	A
2205   E2D9             ;---------------------------------------------------------------------------------------------------------------------
2206   E2D9 7A          LOG2PHY		MOV	A,D
2207   E2DA E6 F8       		ANI	0F8H
2208   E2DC C0          		RNZ			;Return with CY clear
2209   E2DD C5          		PUSH	B
2210   E2DE 06 00       		MVI	B,0		;Track=0
2211   E2E0 D5          L2LP		PUSH	D		;Save DE before subtracting 26 sectors per track
2212   E2E1 7B          		MOV	A,E		;Subtrack 26 from E
2213   E2E2 D6 1A       		SUI	26
2214   E2E4 5F          		MOV	E,A
2215   E2E5 D2 EC E2    		JNC	L2PNT		;If no borrow occurs, then set track
2216   E2E8 15          		DCR	D		;Decrement D
2217   E2E9 FA F1 E2    		JM	L2PSS		;If negative, Set Sector
2218   E2EC F1          L2PNT		POP	PSW		;Scrap saved DE, accept DE as it's still positive
2219   E2ED 04          		INR	B		;Else, Advance Track
2220   E2EE C3 E0 E2    		JMP	L2LP
2221   E2F1 D1          L2PSS		POP	D
2222   E2F2 1C          		INR	E
2223   E2F3 78          		MOV	A,B
2224   E2F4 57          		MOV	D,A
2225   E2F5 FE 4D       		CPI	77		;Test for invalid TRACK# (happens
2226   E2F7 C1          		POP	B		;Return CY set for valid Logical Sector
2227   E2F8 C9          		RET
2228   E2F9             
2229   E2F9             
2230   E2F9             
2231   E2F9             
2232   E2F9             
2233   E2F9             ;----------------------------------------------------------------------------------------------------; DISASSEMBLER
2234   E2F9             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2235   E2F9             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2236   E2F9             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2237   E2F9             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2238   E2F9             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2239   E2F9             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2240   E2F9             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2241   E2F9             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2242   E2F9             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2243   E2F9             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2244   E2F9             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2245   E2F9             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2246   E2F9             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2247   E2F9             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2248   E2F9             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2249   E2F9             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2250   E2F9             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2251   E2F9             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2252   E2F9             ;----------------------------------------------------------------------------------------------------; DISASSEMBLER
2253   E2F9 CD B4 E8    DISASM		CALL	PUT_HL		;Print Address	***CAUTION**** This routine has 3 tables that must NOT cross page boundaries.
2254   E2FC CD E7 E8    		CALL	PRINTI
2255   E2FF 20 20 00    		.text	"  \000"
2256   E302 4E          		MOV	C,M
2257   E303 E5          		PUSH	H
2258   E304 CD 2C E3    		CALL	DA_LOOKUP	;Print Mnemonic code
2259   E307 E1          		POP	H
2260   E308 B7          		ORA	A		;Test if there are any operands to print
2261   E309 CA 27 E3    		JZ	DA_NOOP		;Jump if NO operands
2262   E30C 3D          		DCR	A
2263   E30D C2 18 E3    		JNZ	DA_N1OP		;Jump if 2 operands (actually, if NOT 1 operand)
2264   E310 23          		INX	H
2265   E311 7E          		MOV	A,M		;Print Byte
2266   E312 CD BF E8    		CALL	PUT_BYTE
2267   E315 C3 27 E3    		JMP	DA_NOOP
2268   E318 3D          DA_N1OP		DCR	A
2269   E319 C2 27 E3    		JNZ	DA_NOOP
2270   E31C 23          		INX	H		;Print Word (high/low)
2271   E31D 46          		MOV	B,M
2272   E31E 23          		INX	H
2273   E31F 7E          		MOV	A,M
2274   E320 CD BF E8    		CALL	PUT_BYTE
2275   E323 78          		MOV	A,B
2276   E324 CD BF E8    		CALL	PUT_BYTE
2277   E327 CD 97 E8    DA_NOOP		CALL	PUT_NEW_LINE
2278   E32A 23          		INX	H
2279   E32B C9          		RET
2280   E32C             
2281   E32C             					;Print Operand for Machine Code in C
2282   E32C 21 A0 E4    DA_LOOKUP	LXI	H, TBL_1A
2283   E32F 3E FF       		MVI	A,0FFH		;Bit Mast (Mask no bits)
2284   E331 11 05 00    		LXI	D,5		;DE=LEN of table entry
2285   E334 CD 94 E4    		CALL	LS_SEARCH	;Search for commands without embedded codes or extra operands.
2286   E337 CA 2E E4    		JZ	DA_FOUND
2287   E33A 79          		MOV	A,C		;Fetch Code
2288   E33B E6 C0       		ANI	0C0H
2289   E33D FE 40       		CPI	040H		;Test for MOV code
2290   E33F CA 3D E4    		JZ	DA_MOV
2291   E342 3E CF       		MVI	A,0CFH		;Mask out register pairs
2292   E344 CD 94 E4    		CALL	LS_SEARCH	;Search for 1C commands (Reg Pairs)
2293   E347 CA 23 E4    		JZ	DA_FOUND_1C
2294   E34A CD 94 E4    		CALL	LS_SEARCH	;Search for 3C command (LXI Reg Pairs,Immediate)
2295   E34D CA 18 E4    		JZ	DA_FOUND_3C
2296   E350 3E F8       		MVI	A,0F8H		;Mask out SSS register
2297   E352 CD 94 E4    		CALL	LS_SEARCH	;Search for 1B commands (Source Register)
2298   E355 CA 0F E4    		JZ	DA_FOUND_1B
2299   E358 3E C7       		MVI	A,0C7H		;Mask out DDD register
2300   E35A CD 94 E4    		CALL	LS_SEARCH	;Search for 1B commands (Source Register)
2301   E35D CA 06 E4    		JZ	DA_FOUND_1D
2302   E360 FE 06       		CPI	006H		;Search for MVI command
2303   E362 CA F2 E3    		JZ	DA_FOUND_2B
2304   E365 FE C7       		CPI	0C7H		;Search for RST command
2305   E367 CA DF E3    		JZ	DA_FOUND_1R
2306   E36A 3E EF       		MVI	A,0EFH
2307   E36C CD 94 E4    		CALL	LS_SEARCH	;Search for 1E commands (STAX or LDAX Reg Pairs)
2308   E36F CA 23 E4    		JZ	DA_FOUND_1C
2309   E372 3E FF       		MVI	A,0FFH
2310   E374 CD 94 E4    		CALL	LS_SEARCH	;Search for 2A commands (Acc Immediate functions)
2311   E377 CA A2 E3    		JZ	DA_FOUND_2A
2312   E37A CD 94 E4    		CALL	LS_SEARCH	;Search for 3C commands (LDA,STA,LHLD,SHLD)
2313   E37D CA 99 E3    		JZ	DA_FOUND_3D
2314   E380 3E C7       		MVI	A,0C7H		;Mask out Condition Code & LSB
2315   E382 1E 02       		MVI	E,2		;DE=LEN of table entry
2316   E384 CD 94 E4    		CALL	LS_SEARCH	;Search for 3B commands (Jump / Call Commands)
2317   E387 CA AB E3    		JZ	DA_FOUND_3B
2318   E38A             
2319   E38A CD E7 E8    DA_DB		CALL	PRINTI		;When all searchs fail, print byte as a DB
2320   E38D 444220202000 		.text	"DB   \000"
2321   E393 79          		MOV	A,C
2322   E394 CD BF E8    		CALL	PUT_BYTE
2323   E397 AF          		XRA	A
2324   E398 C9          		RET
2325   E399             
2326   E399 CD 2E E4    DA_FOUND_3D	CALL	DA_FOUND	;Print opcode
2327   E39C CD 53 DB    		CALL	PUT_SPACE
2328   E39F 3E 02       		MVI	A,2		;Return to print 16 bit Memory operand
2329   E3A1 C9          		RET
2330   E3A2             
2331   E3A2 CD 2E E4    DA_FOUND_2A	CALL	DA_FOUND	;Print opcode
2332   E3A5 CD 53 DB    		CALL	PUT_SPACE
2333   E3A8 3E 01       		MVI	A,1		;Return to print 8 bit immediate Operand
2334   E3AA C9          		RET
2335   E3AB             
2336   E3AB 23          DA_FOUND_3B	INX	H
2337   E3AC 7E          		MOV	A,M		;Print First letter of Op Code (J,C or R)
2338   E3AD CD 3A E9    		CALL	PUT_CHAR
2339   E3B0 79          		MOV	A,C		;Fetch Code for DDD
2340   E3B1 0F          		RRC
2341   E3B2 0F          		RRC
2342   E3B3 21 CF E3    		LXI	H, TBL_CC
2343   E3B6 E6 0E       		ANI	0EH		;Print 2 character Condition Code
2344   E3B8 85          		ADD	L
2345   E3B9 6F          		MOV	L,A
2346   E3BA 7E          		MOV	A,M
2347   E3BB CD 3A E9    		CALL	PUT_CHAR
2348   E3BE 23          		INX	H
2349   E3BF 7E          		MOV	A,M
2350   E3C0 CD 3A E9    		CALL	PUT_CHAR
2351   E3C3 CD E7 E8    		CALL	PRINTI
2352   E3C6 20 20 00    		.text	"  \000"
2353   E3C9 79          DAF_3B_RET	MOV	A,C		;Codes that end in 100 or 010 result with 2 Operands
2354   E3CA 0F          		RRC			;This allows address to be printed for JMP's and CALL's
2355   E3CB B1          		ORA	C		;but not RET's
2356   E3CC E6 02       		ANI	2
2357   E3CE C9          		RET
2358   E3CF             
2359   E3CF 4E5A5A204E43 TBL_CC		.text	"NZZ NCC POPEP M "
2359   E3D5 4320504F504550204D20
2360   E3DF             
2361   E3DF CD E7 E8    DA_FOUND_1R	CALL	PRINTI
2362   E3E2 5253542000  		.text	"RST \000"
2363   E3E7 79          		MOV	A,C
2364   E3E8 0F          		RRC
2365   E3E9 0F          		RRC
2366   E3EA 0F          		RRC
2367   E3EB E6 07       		ANI	7
2368   E3ED CD CE E8    		CALL	PUT_HEX
2369   E3F0 AF          		XRA	A
2370   E3F1 C9          		RET
2371   E3F2             
2372   E3F2 CD E7 E8    DA_FOUND_2B	CALL	PRINTI
2373   E3F5 4D5649202000 		.text	"MVI  \000"
2374   E3FB CD 5C E4    		CALL	DA_PUT_DDD
2375   E3FE CD E7 E8    		CALL	PRINTI
2376   E401 2C 00       		.text	",\000"
2377   E403 3E 01       		MVI	A,1
2378   E405 C9          		RET
2379   E406             
2380   E406 CD 2E E4    DA_FOUND_1D	CALL	DA_FOUND
2381   E409 CD 53 DB    		CALL	PUT_SPACE
2382   E40C C3 5C E4    		JMP	DA_PUT_DDD
2383   E40F             
2384   E40F CD 2E E4    DA_FOUND_1B	CALL	DA_FOUND
2385   E412 CD 53 DB    		CALL	PUT_SPACE
2386   E415 C3 4E E4    		JMP	DA_PUT_SSS
2387   E418             
2388   E418             
2389   E418 CD 23 E4    DA_FOUND_3C	CALL	DA_FOUND_1C
2390   E41B CD E7 E8    		CALL	PRINTI
2391   E41E 2C 00       		.text	",\000"
2392   E420 3E 02       		MVI	A,2
2393   E422 C9          		RET
2394   E423             
2395   E423 CD 2E E4    DA_FOUND_1C	CALL	DA_FOUND	;Print the opcode
2396   E426 CD 53 DB    		CALL	PUT_SPACE
2397   E429 CD 6B E4    		CALL	DA_PUT_REGPAIR
2398   E42C AF          		XRA	A
2399   E42D C9          		RET
2400   E42E             
2401   E42E 43          DA_FOUND	MOV	B,E		;Prints Opcode (no operands)
2402   E42F 05          		DCR	B
2403   E430 23          DAF_LP		INX	H
2404   E431 7E          		MOV	A,M
2405   E432 B7          		ORA	A
2406   E433 C8          		RZ
2407   E434 CD 3A E9    		CALL	PUT_CHAR
2408   E437 05          		DCR	B
2409   E438 C2 30 E4    		JNZ	DAF_LP
2410   E43B AF          		XRA	A
2411   E43C C9          		RET
2412   E43D             
2413   E43D CD E7 E8    DA_MOV		CALL	PRINTI		;Prints MOV Opcode with 2 operands DDD, SSS
2414   E440 4D4F56202000 		.text	"MOV  \000"
2415   E446 CD 5C E4    		CALL	DA_PUT_DDD
2416   E449 CD E7 E8    		CALL	PRINTI
2417   E44C 2C 00       		.text	",\000"
2418   E44E 79          DA_PUT_SSS	MOV	A,C		;Fetch Code for SSS
2419   E44F 21 63 E4    DA_PUT_SSSDDD	LXI	H, TBL_DDDSSS
2420   E452 E6 07       		ANI	07H
2421   E454 85          		ADD	L
2422   E455 6F          		MOV	L,A
2423   E456 7E          		MOV	A,M
2424   E457 CD 3A E9    		CALL	PUT_CHAR
2425   E45A AF          		XRA	A
2426   E45B C9          		RET
2427   E45C             
2428   E45C 79          DA_PUT_DDD	MOV	A,C		;Fetch Code for DDD
2429   E45D 0F          		RRC
2430   E45E 0F          		RRC
2431   E45F 0F          		RRC
2432   E460 C3 4F E4    		JMP	DA_PUT_SSSDDD
2433   E463             
2434   E463 42434445484C TBL_DDDSSS	.text	"BCDEHLMA"
2434   E469 4D41
2435   E46B             
2436   E46B 79          DA_PUT_REGPAIR	MOV	A,C		;Fetch Code for Reg Pair
2437   E46C 0F          		RRC
2438   E46D 0F          		RRC
2439   E46E 0F          		RRC
2440   E46F 21 87 E4    		LXI	H, TBL_REGPAIR
2441   E472 E6 0E       		ANI	0EH
2442   E474 FE 0E       		CPI	0EH		;Test for PSW Reg Pair
2443   E476 C2 7E E4    		JNZ	DAPR_OK
2444   E479 3E 09       		MVI	A,9
2445   E47B C3 80 E4    		JMP	DAPR_OK2
2446   E47E E6 06       DAPR_OK		ANI	6H
2447   E480 85          DAPR_OK2	ADD	L
2448   E481 6F          		MOV	L,A
2449   E482 CD DD E8    		CALL	PRINT		
2450   E485 AF          		XRA	A		;Print returns with A=00
2451   E486 C9          		RET
2452   E487             
2453   E487 42 00       TBL_REGPAIR	.text	"B\000"
2454   E489 44 00       		.text	"D\000"
2455   E48B 48 00       		.text	"H\000"
2456   E48D 53 50 00    		.text	"SP\000"
2457   E490 50 53 57 00 		.text	"PSW\000"
2458   E494             
2459   E494             
2460   E494 A1          LS_SEARCH	ANA	C		;Fetch Code (AND with bit mask)
2461   E495 46          		MOV	B,M		;Count of Elements
2462   E496 23          		INX	H
2463   E497 BE          LS_LP		CMP	M
2464   E498 C8          		RZ
2465   E499 19          		DAD	D
2466   E49A 05          		DCR	B
2467   E49B C2 97 E4    		JNZ	LS_LP
2468   E49E 05          		DCR	B		;RETURN WITH Z=0
2469   E49F C9          		RET
2470   E4A0             
2471   E4A0 11          TBL_1A		.DB	17		;COUNT OF TABLE ELEMENTS
2472   E4A1 EB          		.DB	0EBH
2473   E4A2 58 43 48 47 		.text	"XCHG"
2474   E4A6 E3          		.DB	0E3H
2475   E4A7 58 54 48 4C 		.text	"XTHL"
2476   E4AB F9          		.DB	0F9H
2477   E4AC 53 50 48 4C 		.text	"SPHL"
2478   E4B0 E9          		.DB	0E9H
2479   E4B1 50 43 48 4C 		.text	"PCHL"
2480   E4B5 07          		.DB	007H
2481   E4B6 52 4C 43 20 		.text	"RLC "
2482   E4BA 0F          		.DB	00FH
2483   E4BB 52 52 43 20 		.text	"RRC "
2484   E4BF 17          		.DB	017H
2485   E4C0 52 41 4C 20 		.text	"RAL "
2486   E4C4 1F          		.DB	01FH
2487   E4C5 52 41 52 20 		.text	"RAR "
2488   E4C9 2F          		.DB	02FH
2489   E4CA 43 4D 41 20 		.text	"CMA "
2490   E4CE 37          		.DB	037H
2491   E4CF 53 54 43 20 		.text	"STC "
2492   E4D3 3F          		.DB	03FH
2493   E4D4 43 4D 43 20 		.text	"CMC "
2494   E4D8 27          		.DB	027H
2495   E4D9 44 41 41 20 		.text	"DAA "
2496   E4DD FB          		.DB	0FBH
2497   E4DE 45 49 20 20 		.text	"EI  "
2498   E4E2 F3          		.DB	0F3H
2499   E4E3 44 49 20 20 		.text	"DI  "
2500   E4E7 00          		.DB	000H
2501   E4E8 4E 4F 50 20 		.text	"NOP "
2502   E4EC 76          		.DB	076H
2503   E4ED 48 4C 54 20 		.text	"HLT "
2504   E4F1 C9          		.DB	0C9H
2505   E4F2 52 45 54 20 		.text	"RET "
2506   E4F6 05          TBL_1C		.DB	5		;COUNT OF TABLE ELEMENTS
2507   E4F7 C5          		.DB	0C5H
2508   E4F8 50 55 53 48 		.text	"PUSH"
2509   E4FC C1          		.DB	0C1H
2510   E4FD 50 4F 50 20 		.text	"POP "
2511   E501 03          		.DB	003H
2512   E502 49 4E 58 20 		.text	"INX "
2513   E506 0B          		.DB	00BH
2514   E507 44 43 58 20 		.text	"DCX "
2515   E50B 09          		.DB	009H
2516   E50C 44 41 44 20 		.text	"DAD "
2517   E510 01          TBL_3C		.DB	1		;COUNT OF TABLE ELEMENTS
2518   E511 01          		.DB	001H
2519   E512 4C 58 49 20 		.text	"LXI "
2520   E516 08          TBL_1B		.DB	8		;COUNT OF TABLE ELEMENTS
2521   E517 80          		.DB	080H
2522   E518 41 44 44 20 		.text	"ADD "
2523   E51C 88          		.DB	088H
2524   E51D 41 44 43 20 		.text	"ADC "
2525   E521 90          		.DB	090H
2526   E522 53 55 42 20 		.text	"SUB "
2527   E526 98          		.DB	098H
2528   E527 53 42 42 20 		.text	"SBB "
2529   E52B A0          		.DB	0A0H
2530   E52C 41 4E 41 20 		.text	"ANA "
2531   E530 A8          		.DB	0A8H
2532   E531 58 52 41 20 		.text	"XRA "
2533   E535 B0          		.DB	0B0H
2534   E536 4F 52 41 20 		.text	"ORA "
2535   E53A B8          		.DB	0B8H
2536   E53B 43 4D 50 20 		.text	"CMP "
2537   E53F 02          TBL_1D		.DB	2		;COUNT OF TABLE ELEMENTS
2538   E540 04          		.DB	004H
2539   E541 49 4E 52 20 		.text	"INR "
2540   E545 05          		.DB	005H
2541   E546 44 43 52 20 		.text	"DCR "
2542   E54A 02          TBL_1E		.DB	2		;COUNT OF TABLE ELEMENTS
2543   E54B 02          		.DB	002H
2544   E54C 53 54 41 58 		.text	"STAX"
2545   E550 0A          		.DB	00AH
2546   E551 4C 44 41 58 		.text	"LDAX"
2547   E555 0A          TBL_2A		.DB	10		;COUNT OF TABLE ELEMENTS
2548   E556 C6          		.DB	0C6H
2549   E557 41 44 49 20 		.text	"ADI "
2550   E55B CE          		.DB	0CEH
2551   E55C 41 43 49 20 		.text	"ACI "
2552   E560 D6          		.DB	0D6H
2553   E561 53 55 49 20 		.text	"SUI "
2554   E565 DE          		.DB	0DEH
2555   E566 53 42 49 20 		.text	"SBI "
2556   E56A E6          		.DB	0E6H
2557   E56B 41 4E 49 20 		.text	"ANI "
2558   E56F EE          		.DB	0EEH
2559   E570 58 52 49 20 		.text	"XRI "
2560   E574 F6          		.DB	0F6H
2561   E575 4F 52 49 20 		.text	"ORI "
2562   E579 FE          		.DB	0FEH
2563   E57A 43 50 49 20 		.text	"CPI "
2564   E57E DB          		.DB	0DBH
2565   E57F 49 4E 20 20 		.text	"IN  "
2566   E583 D3          		.DB	0D3H
2567   E584 4F 55 54 20 		.text	"OUT "
2568   E588 06          TBL_3D		.DB	6		;COUNT OF TABLE ELEMENTS
2569   E589 32          		.DB	032H
2570   E58A 53 54 41 20 		.text	"STA "
2571   E58E 3A          		.DB	03AH
2572   E58F 4C 44 41 20 		.text	"LDA "
2573   E593 22          		.DB	022H
2574   E594 53 48 4C 44 		.text	"SHLD"
2575   E598 2A          		.DB	02AH
2576   E599 4C 48 4C 44 		.text	"LHLD"
2577   E59D C3          		.DB	0C3H
2578   E59E 4A 4D 50 20 		.text	"JMP "
2579   E5A2 CD          		.DB	0CDH
2580   E5A3 43 41 4C 4C 		.text	"CALL"
2581   E5A7 03          TBL_3B		.DB	3		;COUNT OF TABLE ELEMENTS
2582   E5A8 C2          		.DB	0C2H
2583   E5A9 4A          		.text	"J"
2584   E5AA C4          		.DB	0C4H
2585   E5AB 43          		.text	"C"
2586   E5AC C0          		.DB	0C0H
2587   E5AD 52          		.text	"R"
2588   E5AE             
2589   E5AE             
2590   E5AE             ;----------------------------------------------------------------------------------------------------; CP/M BIOS
2591   E5AE             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2592   E5AE             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2593   E5AE             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2594   E5AE             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2595   E5AE             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2596   E5AE             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2597   E5AE             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2598   E5AE             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2599   E5AE             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2600   E5AE             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2601   E5AE             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2602   E5AE             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2603   E5AE             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2604   E5AE             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2605   E5AE             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2606   E5AE             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2607   E5AE             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2608   E5AE             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2609   E5AE             ;----------------------------------------------------------------------------------------------------; CP/M BIOS
2610   E5AE             
2611   E5AE             
2612   E5AE             
2613   E5AE             ;***************************************************
2614   E5AE             ;*** THIS BEGINS THE AREA WHICH REQUIRES CHANGES ***
2615   E5AE             ;***      FOR DIFFERENT CONSOLE I/O SYSTEMS      ***
2616   E5AE             ;***************************************************
2617   E5AE             
2618   E5AE             MSIZE		.EQU  59	;MEMORY SIZE IN KBYTES.
2619   E5AE             
2620   E5AE             ;*******************************************************
2621   E5AE             ;*** THIS IS THE END OF THE AREA WHICH NORMALLY NEED ***
2622   E5AE             ;***     BE CHANGED FOR MOST CONSOLE I/O SYSTEMS     ***
2623   E5AE             ;*******************************************************
2624   E5AE             
2625   E5AE             IOBYTE		.EQU  3		;ADDRESS OF I/O BYTE.
2626   E5AE             CCP		.EQU  (MSIZE-7)*1024	;START OF CPM (D800)
2627   E5AE             BDOS		.EQU  CCP+806H		;START OF BDOS (E006)
2628   E5AE             BIOS		.EQU  CCP+1600H		;START OF BIOS (EE00)
2629   E5AE             CPMLEN		.EQU  BIOS-CCP		;LENGTH OF CPM SYSTEM (LESS BIOS)
2630   E5AE             NSECTS		.EQU  CPMLEN/128	;NUMBER OF SECTORS IN IT.
2631   E5AE             
2632   E5AE             ;       Page Zero Definitions.
2633   E5AE             IOBYTE		.EQU	3		;Location of IOBYTE
2634   E5AE             CDISK		.EQU	4		;Location of current disk
2635   E5AE             BIORAM		.EQU	40h		;16 ram cells
2636   E5AE             OPTS		.EQU	BIORAM		;GBC DISK1 board switch options
2637   E5AE             ;			BIORAM+1	;GBC (cell before TICK)
2638   E5AE             TICK		.EQU	BIORAM+2	;GBC Sample period
2639   E5AE             DBUF		.EQU	80h		;Default sector buffer
2640   E5AE             
2641   E600             		.ORG	BIOS
2642   E600             
2643   E600             ; I/O JUMP VECTOR
2644   E600             ; THIS IS WHERE CP/M CALLS WHENEVER IT NEEDS
2645   E600             ; TO DO ANY INPUT/OUTPUT OPERATION.
2646   E600             ; USER PROGRAMS MAY USE THESE ENTRY POINTS
2647   E600             ; ALSO, BUT NOTE THAT THE LOCATION OF THIS
2648   E600             ; VECTOR CHANGES WITH THE MEMORY SIZE.
2649   E600             ;
2650   E600 C3 BB E6    CBOOTV	JMP  	CBOOT	;FROM COLD START LOADER.
2651   E603 C3 F0 E6    WBOOTV	JMP  	WBOOT	;FROM WARM BOOT.
2652   E606 C3 9D E7    CONSTV	JMP  	CONST	;CHECK CONSOLE KB STATUS.
2653   E609 C3 B4 E7    	JMP  	CONIN	;READ CONSOLE CHARACTER.
2654   E60C C3 C0 E7    	JMP  	CONOT	;WRITE CONSOLE CHARACTER.
2655   E60F C3 DE E7    	JMP  	LIST	;WRITE LISTING CHAR.
2656   E612 C3 E9 E7    	JMP  	PUNCH	;WRITE PUNCH CHAR.
2657   E615 C3 EA E7    	JMP  	READER	;READ READER CHAR.
2658   E618 C3 0B E8    	JMP  	HOME	;MOVE DISK TO TRACK ZERO.
2659   E61B C3 EC E7    SELDSKV	JMP  	SELDSK	;SELECT DISK DRIVE.
2660   E61E C3 0D E8    	JMP  	SETTRK	;SEEK TO TRACK IN REG A.
2661   E621 C3 14 E8    	JMP  	SETSEC	;SET SECTOR NUMBER.
2662   E624 C3 1A E8    SETDMAV	JMP  	SETDMA	;SET DISK STARTING ADR.
2663   E627 C3 25 E8    	JMP  	DREAD	;READ SELECTED SECTOR.
2664   E62A C3 4D E8    	JMP  	DWRITE	;WRITE SELECTED SECTOR.
2665   E62D C3 EB E7    	JMP  	LISTST	;List status (output)
2666   E630 C3 22 E8    	JMP  	SECTRN	;Translate sector number
2667   E633             	
2668   E633             					;My own BIOS routine entries
2669   E633 C3 F9 E8    	JMP  	GET_CHAR_UART
2670   E636 C3 27 E9    	JMP  	GET_CHAR
2671   E639 C3 3A E9    	JMP  	PUT_CHAR
2672   E63C C3 7D E9    	JMP  	GET_CHAR_NE
2673   E63F             
2674   E63F             
2675   E63F             NDSK	.EQU	4
2676   E63F             
2677   E63F             ;	Control Blocks for disk drives
2678   E63F             
2679   E63F 000000000000 DPBASE	.DW	SKEW,0,0,0,DIRBUF,DPB0,CSV0,ALV0	;Drive A:
2679   E645 000000F27FE680F480F2
2680   E64F 000000000000 	.DW	SKEW,0,0,0,DIRBUF,DPB1,CSV1,ALV1	;Drive B:
2680   E655 000000F28EE6C0F6C0F4
2681   E65F 000000000000 	.DW	SKEW,0,0,0,DIRBUF,DPB2,CSV2,ALV2	;Drive C:
2681   E665 000000F29DE600F900F7
2682   E66F 000000000000 	.DW	SKEW,0,0,0,DIRBUF,DPB3,CSV3,ALV3	;Drive D:
2682   E675 000000F2ACE640FB40F9
2683   E67F             
2684   E67F             ;SKEW	.DB 	01, 07, 13, 19, 25, 05, 11, 17, 23, 03, 09, 15, 21, 02, 08, 14, 20, 26, 06, 12, 18, 24, 04, 10, 16, 22
2685   E67F             SKEW	.equ	0
2686   E67F             
2687   E67F             ;       Disk type definition blocks for each particular mode.
2688   E67F 1A 00       DPB0	.DW	26		;SEC PER TRACK
2689   E681 03          	.DB	3		;BLOCK SHIFT
2690   E682 07          	.DB	7		;BLOCK MASK
2691   E683 00          	.DB	0		;EXTNT MASK
2692   E684 F2 00       	.DW	242		;DISK SIZE-1
2693   E686 3F 00       	.DW	63		;DIRECTORY MAX
2694   E688 C0          	.DB	11000000b	;ALLOC0
2695   E689 00          	.DB	00000000b	;ALLOC1
2696   E68A 10 00       	.DW	16		;CHECK SIZE
2697   E68C 02 00       	.DW	2		;OFFSET
2698   E68E             
2699   E68E 1A 00       DPB1	.DW	26		;SEC PER TRACK
2700   E690 03          	.DB	3		;BLOCK SHIFT
2701   E691 07          	.DB	7		;BLOCK MASK
2702   E692 00          	.DB	0		;EXTNT MASK
2703   E693 F2 00       	.DW	242		;DISK SIZE-1
2704   E695 3F 00       	.DW	63		;DIRECTORY MAX
2705   E697 C0          	.DB	11000000b	;ALLOC0
2706   E698 00          	.DB	00000000b	;ALLOC1
2707   E699 10 00       	.DW	16		;CHECK SIZE
2708   E69B 02 00       	.DW	2		;OFFSET
2709   E69D             
2710   E69D 1A 00       DPB2	.DW	26		;SEC PER TRACK
2711   E69F 03          	.DB	3		;BLOCK SHIFT
2712   E6A0 07          	.DB	7		;BLOCK MASK
2713   E6A1 00          	.DB	0		;EXTNT MASK
2714   E6A2 F2 00       	.DW	242		;DISK SIZE-1
2715   E6A4 3F 00       	.DW	63		;DIRECTORY MAX
2716   E6A6 C0          	.DB	11000000b	;ALLOC0
2717   E6A7 00          	.DB	00000000b	;ALLOC1
2718   E6A8 10 00       	.DW	16		;CHECK SIZE
2719   E6AA 02 00       	.DW	2		;OFFSET
2720   E6AC             
2721   E6AC 1A 00       DPB3	.DW	26		;SEC PER TRACK
2722   E6AE 03          	.DB	3		;BLOCK SHIFT
2723   E6AF 07          	.DB	7		;BLOCK MASK
2724   E6B0 00          	.DB	0		;EXTNT MASK
2725   E6B1 F2 00       	.DW	242		;DISK SIZE-1
2726   E6B3 3F 00       	.DW	63		;DIRECTORY MAX
2727   E6B5 C0          	.DB	11000000b	;ALLOC0
2728   E6B6 00          	.DB	00000000b	;ALLOC1
2729   E6B7 10 00       	.DW	16		;CHECK SIZE
2730   E6B9 02 00       	.DW	2		;OFFSET
2731   E6BB             
2732   E6BB             		;Amstrad 1.44M disk
2733   E6BB             ;DPB33	.DW	48h		;SEC PER TRACK
2734   E6BB             ;	.DB	5		;BLOCK SHIFT = 4K Block size
2735   E6BB             ;	.DB	1Fh		;BLOCK MASK
2736   E6BB             ;	.DB	1		;EXTNT MASK
2737   E6BB             ;	.DW	164H		;DISK SIZE-1
2738   E6BB             ;	.DW	0ffh		;DIRECTORY MAX
2739   E6BB             ;	.DB	0c0h		;ALLOC0
2740   E6BB             ;	.DB	00		;ALLOC1
2741   E6BB             ;	.DW	40h		;CHECK SIZE
2742   E6BB             ;	.DW	1		;OFFSET
2743   E6BB             
2744   E6BB             ;3.5" DSDD    80*2*18*512 = 1,474,560   1.44M
2745   E6BB             ;5"   DSHD    80*2*15*512 = 1,228,800   1.2 M
2746   E6BB             ;5"   DSDD    40*2* 9*512 = 368,640      360K
2747   E6BB             ;5"   DSDD    40*2* 8*512 = 327,680      320K
2748   E6BB             ;5"   DSDD    40*2*10*512 = 409,600      400K
2749   E6BB             ;5"   DSSD    40*2*18*128 = 184,320      180K
2750   E6BB             ;8"   DSDD    77*2*8*1024 = 1,261,568   1232K
2751   E6BB             ;8"   SSDD    77*1*8*1024 = 630,784      616K
2752   E6BB             ;8"   DSDD    77*2*15*512 = 1,182,720   1155K
2753   E6BB             ;8"   DSDD    77*2*26*256 = 1,025,024   1001K
2754   E6BB             ;8"   SSSD    77*1*26*128 = 256,256      250K
2755   E6BB             
2756   E6BB             
2757   E6BB             ;       B O O T   C P / M   f r o m   d i s k.
2758   E6BB             ;
2759   E6BB             ;       The CBOOT entry point gets control from the cold start
2760   E6BB             ;       loader and is responsible for the basic system initial-
2761   E6BB             ;       ization.  This includes outputting a sign-on message and
2762   E6BB             ;       initializing the following page zero locations:
2763   E6BB             ;
2764   E6BB             ;          0,1,2: Set to the warmstart jump vector.
2765   E6BB             ;              3: Set to the initial IOBYTE value.
2766   E6BB             ;              4: Default and logged on drive.
2767   E6BB             ;          5,6,7: Set to a jump to BDOS.
2768   E6BB             ;             40: (Set by BOOT) Board switch options.
2769   E6BB             ;
2770   E6BB             ;       If BANG is true (DISK1 bit serial latch is to be supported), then
2771   E6BB             ;       board switch option I means to use the BitBanger for console I/O.
2772   E6BB             ;       Register C must contain the selected drive, which is zero to
2773   E6BB             ;       select the A drive.  The exit address is to the CCP routine.
2774   E6BB             ;
2775   E6BB             ;
2776   E6BB             ;       The WBOOT entry point gets control when a warm start occurs,
2777   E6BB             ;       a ^C from the console, a jump to BDOS (function 0), or a jump to
2778   E6BB             ;       location zero.  The WBOOT routine reads the CCP and BDOS from the
2779   E6BB             ;       appropriate disk sectors.  WBOOT must also re-initialize locations
2780   E6BB             ;       0,1,2 and 5,6,7.  The WBOOT routines exits with the C register set
2781   E6BB             ;       to the appropriate drive selection value.  The exit address is to
2782   E6BB             ;       the CCP routine.
2783   E6BB             ;
2784   E6BB 31 00 FD    CBOOT:	LXI  SP,HIGHSTACK	;SET STACK POINTER.
2785   E6BE CD E7 E8    	CALL PRINTI
2786   E6C1 0D0A414C5441 	.text "\r\nALTAIR/IMSAI CPU CARD. "
2786   E6C7 49522F494D5341492043505520434152442E20
2787   E6DA 35 39       	.DB   (MSIZE / 10) + '0', (MSIZE % 10) + '0'
2788   E6DC 4B2043502F4D 	.text "K CP/M 2.2\r\n\000"
2788   E6E2 20322E320D0A00
2789   E6E9             
2790   E6E9 AF          	XRA     A
2791   E6EA 32 04 00    	STA     CDISK           ;Force A drive
2792   E6ED 32 03 00    	STA     IOBYTE          ;Clear I/O byte
2793   E6F0             
2794   E6F0             ; WARM-BOOT:  READ ALL OF CPM BACK IN
2795   E6F0             ; EXCEPT BIOS, THEN JUMP TO CCP.
2796   E6F0             ;
2797   E6F0 31 00 FD    WBOOT:	LXI  SP,HIGHSTACK	;SET STACK POINTER.
2798   E6F3             
2799   E6F3 CD E7 E8    	CALL PRINTI
2800   E6F6 0D0A57424F4F 	.text "\r\nWBOOT\r\n\000"
2800   E6FC 540D0A00
2801   E700             
2802   E700             				;Boot CP/M
2803   E700             
2804   E700 3A 04 00    	LDA  CDISK	;SAVE DISK NUMBER.
2805   E703 32 EA FD    	STA  TEMP      
2806   E706 0E 00       	MVI	C,0	;Set DISK A
2807   E708 CD 1B E6    	CALL	SELDSKV
2808   E70B             
2809   E70B 11 00 D0    	LXI	D,CCP		;Save destination address
2810   E70E 06 2C       	MVI	B,NSECTS
2811   E710 21 01 00    	LXI	H,1
2812   E713 22 99 FD    WBLP	SHLD	LOGICAL_SEC	;Set first sector to read from disk
2813   E716 C5          	PUSH	B
2814   E717 D5          	PUSH	D
2815   E718 CD 16 EA    	CALL	DISK_READ	;HL = Quarter Buffer
2816   E71B D1          	POP	D
2817   E71C 06 80       	MVI	B,128
2818   E71E CD 2C F1    	CALL	COPY_RAM	;Copy the SD_RAM_BUFFER to CP/M
2819   E721 2A 99 FD    	LHLD	LOGICAL_SEC	;Set first sector to read from disk
2820   E724 23          	INX	H
2821   E725 C1          	POP	B
2822   E726 05          	DCR	B
2823   E727 C2 13 E7    	JNZ	WBLP
2824   E72A             
2825   E72A             ; SET UP JUMPS IN CP/M PAGE ZERO.
2826   E72A             
2827   E72A 01 80 00    	LXI  B,DBUF	;SET DEFAULT DMA ADR.
2828   E72D CD 24 E6    	CALL SETDMAV
2829   E730 3E C3       	MVI  A,0C3H	;PUT JMP TO WBOOT
2830   E732 32 00 00    	STA  0		;ADR AT ZERO.
2831   E735 32 05 00    	STA  5
2832   E738 21 03 E6    	LXI  H,WBOOTV
2833   E73B 22 01 00    	SHLD 1
2834   E73E 21 06 D8    	LXI  H,BDOS	;PUT JUMP TO BDOS
2835   E741 22 06 00    	SHLD 6		;AT ADR 5,6,7.
2836   E744             
2837   E744             #IF (CCPMOD)    
2838   E744             ; patch the CCP to call our routines
2839   E744 21 83 E7    	LXI  H,PROMPT
2840   E747 22 8E D3    	SHLD CCP+038Eh
2841   E74A 21 5A E7    	LXI  H,USER0 
2842   E74D 22 DC D6    	SHLD CCP+06DCh
2843   E750             #ENDIF
2844   E750             
2845   E750 3A EA FD    	LDA  TEMP
2846   E753 32 04 00    	STA  CDISK
2847   E756 4F          	MOV  C,A
2848   E757 C3 00 D0    	JMP  CCP             ;Go to CPM
2849   E75A             
2850   E75A             #IF (CCPMOD)    
2851   E75A             ;----------------------------------------------------------------------------
2852   E75A             ; Drive A, User 0 Patch for the CCP
2853   E75A             ;    1) Display the user number in the prompt (e.g., "A3>").
2854   E75A             ;    2) Look on drive A with current user, then drive A user 0 for the
2855   E75A             ;       typed command if it fails to open on the default drive.
2856   E75A             ;----------------------------------------------------------------------------
2857   E75A             CMDDRV  .EQU CCP+07F0h	;drive field used by the CCP
2858   E75A             CMDTYPE .EQU CCP+07D6h	;file type in the FCB
2859   E75A             USRNUM  .EQU CCP+0B41h	;user number in the BDOS
2860   E75A             
2861   E75A             CCPCMD  .EQU CCP+06CDh	;CCP entry, try to open COM file
2862   E75A             CCPERR  .EQU CCP+076Bh	;CCP entry, COM open failed
2863   E75A             CCPOPEN .EQU CCP+00D0h	;CCP entry, open file in the FCB
2864   E75A             CCPGO   .EQU CCP+06DEh	;CCP entry, execute opened COM file
2865   E75A             CCPPRNT .EQU CCP+008Ch	;CCP entry, print A
2866   E75A              
2867   E75A             ; USER0 is jumped to when the CCP fails to open the .COM file typed
2868   E75A             ;     on the command line.
2869   E75A             
2870   E75A 21 F0 D7    USER0	LXI  H,CMDDRV	;HL->drive flag used by the CCP
2871   E75D 7E          	MOV  A,M	;A=content of drive field
2872   E75E B7          	ORA  A		;was a drive specified?
2873   E75F C2 69 E7           	JNZ  UHAVDRV	;yes
2874   E762             
2875   E762 34                 	INR  M		;drive flag now = drive A
2876   E763 11 D6 D7           	LXI  D,CMDTYPE	;point DE to file type field
2877   E766 C3 CD D6           	JMP  CCPCMD	;try again to open the command file
2878   E769             
2879   E769             ; UHAVDRV - drive field was specified or our drive A change just failed
2880   E769             
2881   E769 3A 41 DB    UHAVDRV LDA  USRNUM	;A=user number from the BDOS
2882   E76C B7                 	ORA  A		;user zero?
2883   E76D CA 6B D7           	JZ   CCPERR	;yes, nothing more to do
2884   E770             
2885   E770 F5                 	PUSH PSW	;save original user number
2886   E771 AF                 	XRA  A		;set user number to zero
2887   E772 32 41 DB           	STA  USRNUM
2888   E775             
2889   E775 CD D0 D0           	CALL CCPOPEN	;try to open the command file as user 0
2890   E778             
2891   E778 D1                 	POP  D		;restore original user number in D
2892   E779 21 41 DB           	LXI  H,USRNUM	;HL->user number in the BODS
2893   E77C 72                 	MOV  M,D	;restore original user number
2894   E77D             	
2895   E77D C2 DE D6           	JNZ  CCPGO	;execute .COM if it opened
2896   E780 C3 6B D7           	JMP  CCPERR	;else show the error
2897   E783             
2898   E783             ; prompt is called when the CCP has loaded the drive letter for the prompt
2899   E783             ;    into A. The drive letter is printed and then followed with the user num.
2900   E783             
2901   E783 CD 8C D0    PROMPT  CALL CCPPRNT	;display drive letter
2902   E786 3A 41 DB           	LDA  USRNUM	;A=user number
2903   E789 FE 0A              	CPI  10		;0-9?
2904   E78B DA 98 E7           	JC   DO1S	;yes, just do the 1's digit
2905   E78E             
2906   E78E 3E 31              	MVI  A,'1'	;print the 10's digit
2907   E790 CD 8C D0           	CALL CCPPRNT
2908   E793             
2909   E793 3A 41 DB           	LDA  USRNUM	;A=user number
2910   E796 D6 0A              	SUI  10		;get 1's digit alone
2911   E798             
2912   E798 C6 30       DO1S   	ADI   '0'	;convert 1's digit to ASCII
2913   E79A C3 8C D0           	JMP  CCPPRNT	;display it and exit
2914   E79D             #ENDIF
2915   E79D             
2916   E79D             ;==============================================
2917   E79D             ;       C O N S O L   S T A T U S
2918   E79D             ;
2919   E79D             ;       This routine samples the Console status and
2920   E79D             ;       returns the following values in the A register.
2921   E79D             ;
2922   E79D             ;       EXIT    A = 0 (zero), means no character
2923   E79D             ;               currently ready to read.
2924   E79D             ;
2925   E79D             ;               A = FFh (255), means character
2926   E79D             ;               currently ready to read.
2927   E79D             ;-----------------------------------------------
2928   E79D DB 25       CONST:		IN	UART0+5 ;10	TEST FOR RX DATA
2929   E79F E6 01       		ANI	1	;7
2930   E7A1 CA A7 E7    		JZ	CONST_0	;10
2931   E7A4 F6 FF       		ORI	0FFH
2932   E7A6 C9          		RET		;10
2933   E7A7             		
2934   E7A7 3A 82 FD    CONST_0		LDA	PROP_CHECK
2935   E7AA B7          		ORA	A
2936   E7AB C8          		RZ
2937   E7AC             
2938   E7AC DB 00       		IN	PROPELLERS
2939   E7AE E6 02       		ANI	2
2940   E7B0 C8          		RZ
2941   E7B1 F6 FF       		ORI	0FFH
2942   E7B3 C9          		RET
2943   E7B4             
2944   E7B4             
2945   E7B4             ;===============================================
2946   E7B4             ;       C O N S O L   I N P U T
2947   E7B4             ;
2948   E7B4             ;       Read the next character into the A register, clearing the high
2949   E7B4             ;       order bit.  If no character currently ready to read then wait
2950   E7B4             ;       for a character to arrive before returning.
2951   E7B4             ;
2952   E7B4             ;       EXIT    A = character read from terminal.
2953   E7B4             ;-----------------------------------------------
2954   E7B4 CD 7D E9    CONIN:	CALL	GET_CHAR_NE	;Get Char No Echo
2955   E7B7 E6 7F       	ANI  7FH	;MAKE MOST SIG. BIT = 0.
2956   E7B9 FE 7F       	CPI  7FH	;IS IT A RUBOUT?
2957   E7BB C0          	RNZ		;RETURN IF NOT.
2958   E7BC 32 80 FD    	STA  CONOTF	;SET NO PRINT FLAG.
2959   E7BF C9          	RET		;RETURN FROM CONIN.
2960   E7C0             	
2961   E7C0             ;===============================================
2962   E7C0             ;       C O N S O L   O U T P U T
2963   E7C0             ;
2964   E7C0             ;       Send a character to the console.  If the console is not ready to
2965   E7C0             ;       receive a character wait until the console is ready.
2966   E7C0             ;
2967   E7C0             ;       ENTRY   C = ASCII character to output to console.
2968   E7C0             ;-----------------------------------------------
2969   E7C0 79          CONOT:	MOV  A,C	;GET CHARACTER.
2970   E7C1 FE 7F       	CPI  7FH	;IS IT A RUBOUT?
2971   E7C3 C8          	RZ		;IF SO, DON'T PRINT IT.
2972   E7C4 3A 80 FD    	LDA  CONOTF	;GET NO PRINT FLAG.
2973   E7C7 B7          	ORA  A		;SET CPU FLAGS.
2974   E7C8 CA D9 E7    	JZ   CONOTA	;NOT SET, SO PRINT.
2975   E7CB AF          	XRA  A		;RESET THE FLAG
2976   E7CC 32 80 FD    	STA  CONOTF	;TO ZERO.
2977   E7CF 0E 08       	MVI  C,8	;PRINT BACKSPACE.
2978   E7D1 CD D9 E7    	CALL CONOTA
2979   E7D4 3E 20       	MVI  A,20H	;PRINT SPACE.
2980   E7D6 CD 3A E9    	CALL PUT_CHAR
2981   E7D9             			;ANOTHER BACKSPACE.
2982   E7D9 79          CONOTA:	MOV  A,C	;GET CHARACTER.
2983   E7DA CD 3A E9    	CALL PUT_CHAR	;PRINT IT.
2984   E7DD C9          	RET		;RETURN.
2985   E7DE             
2986   E7DE             
2987   E7DE             ;
2988   E7DE             ; WRITE A CHARACTER ON LISTING DEVICE.
2989   E7DE             ;
2990   E7DE             LIST:
2991   E7DE             
2992   E7DE DB 2D       LTBSY	IN	UART1+5
2993   E7E0 E6 20       	ANI	20H	;TEST FOR TX HOLD REG EMPTY
2994   E7E2 CA DE E7    	JZ	LTBSY
2995   E7E5             
2996   E7E5 79          	MOV  A,C	;GET DATA BYTE.
2997   E7E6 D3 28       	OUT	UART1	;PRINT IT.
2998   E7E8 C9          	RET		;RETURN FROM LIST.
2999   E7E9             
3000   E7E9             
3001   E7E9             ;
3002   E7E9             ; PUNCH PAPER TAPE.
3003   E7E9             ;
3004   E7E9 C9          PUNCH:	RET		;RETURN FROM PUNCH.
3005   E7EA             
3006   E7EA             ;
3007   E7EA             ;  NORMALLY USED TO READ PAPER TAPE.
3008   E7EA             ;
3009   E7EA C9          READER:	RET		;RETURN FROM READER.
3010   E7EB             
3011   E7EB C9          LISTST	RET
3012   E7EC             
3013   E7EC             
3014   E7EC             ;       S E L E C T   D I S K   D R I V E
3015   E7EC             ;
3016   E7EC             ;       Select the disk drive for subsequent disk transfers and
3017   E7EC             ;       return the appropriate DPH address. 
3018   E7EC             ;
3019   E7EC             ;       ENTRY   C = disk Selection value.
3020   E7EC             ;
3021   E7EC             ;       EXIT    HL = 0, if drive not selectable.
3022   E7EC             ;               HL = DPH address if drive is selectable.
3023   E7EC             ;
3024   E7EC 21 00 00    SELDSK:	LXI  H,0
3025   E7EF 79          	MOV  A,C	;GET NEW DISK NUMBER.
3026   E7F0 FE 04       	CPI  NDSK
3027   E7F2 D0          	RNC		;If Disk invalid...EXIT
3028   E7F3             
3029   E7F3             
3030   E7F3~            #IF (DEBUG & 80h)
3031   E7F3~               CALL SELECT_UART1
3032   E7F3             #ENDIF
3033   E7F3~            #IF (DEBUG & 1)  
3034   E7F3~            	CALL PRINTI		;DEBUG
3035   E7F3~            	.text " :SEL\000"
3036   E7F3~            	CALL	PUT_BYTE
3037   E7F3             #ENDIF
3038   E7F3~            #IF (DEBUG & 80h)  
3039   E7F3~               CALL SELECT_UART0
3040   E7F3             #ENDIF
3041   E7F3             	
3042   E7F3 C5          	PUSH B
3043   E7F4 D5          	PUSH D
3044   E7F5 CD 87 E9    	CALL SET_FCB_PTR ;Set the FCB PTR for the correct SD File & HL = DPBASE[A] (or 0000 if drive not exist)
3045   E7F8 D1          	POP  D
3046   E7F9 E5          	PUSH H
3047   E7FA 01 0A 00    	LXI  B,10
3048   E7FD 09          	DAD  B
3049   E7FE CD 35 F1    	CALL LD_HL_HL
3050   E801 CD 35 F1    	CALL LD_HL_HL
3051   E804 22 85 FD    	SHLD SEC_PER_TRACK
3052   E807             	
3053   E807             	
3054   E807~            #IF (DEBUG & 80h)
3055   E807~               CALL SELECT_UART1
3056   E807             #ENDIF
3057   E807~            #IF (DEBUG & 1)  
3058   E807~            	CALL PRINTI		;DEBUG
3059   E807~            	.text " :SPT\000"
3060   E807~            	CALL	PUT_HL
3061   E807             #ENDIF
3062   E807~            #IF (DEBUG & 80h)  
3063   E807~               CALL SELECT_UART0
3064   E807             #ENDIF
3065   E807             
3066   E807 E1          	POP  H	
3067   E808 C1          	POP  B
3068   E809 AF          	XRA  A		;SET A = 0.
3069   E80A C9          	RET		;RETURN FROM SELDSK.
3070   E80B             
3071   E80B             
3072   E80B             ; MOVE DISK TO TRACK ZERO.
3073   E80B             ;
3074   E80B 0E 00       HOME:	MVI  C,0	;SEEK TO TRACK ZERO.
3075   E80D             
3076   E80D             ;
3077   E80D             ; SET TRACK NUMBER TO WHATEVER IS IN REGISTER C.
3078   E80D             ; ALSO PERFORM MOVE TO THE CORRECT TRACK (SEEK).
3079   E80D             ;
3080   E80D 60          SETTRK:	MOV  H,B	;GET NEW TRACK NUMBER.
3081   E80E 69          	MOV  L,C	;MOVE B&C TO H&L.
3082   E80F 22 E4 FD    	SHLD  TRK	;UPDATE OLD WITH NEW.
3083   E812             	
3084   E812             ; MOVE THE HEAD TO THE TRACK IN REGISTER A.
3085   E812             
3086   E812             
3087   E812~            #IF (DEBUG & 80h)
3088   E812~               CALL SELECT_UART1
3089   E812             #ENDIF
3090   E812~            #IF (DEBUG & 1)  
3091   E812~            	CALL PRINTI		;DEBUG
3092   E812~            	.text " :TRK\000"
3093   E812~            	CALL	PUT_HL
3094   E812             #ENDIF
3095   E812~            #IF (DEBUG & 80h)  
3096   E812~               CALL SELECT_UART0
3097   E812             #ENDIF
3098   E812             
3099   E812             
3100   E812 AF          	XRA  A		;Clear flags
3101   E813 C9          	RET		;RETURN FROM SEEK.
3102   E814             
3103   E814             ;
3104   E814             ; SET DISK SECTOR NUMBER.
3105   E814             ;
3106   E814 79          SETSEC:	MOV  A,C	;GET SECTOR NUMBER.
3107   E815 32 E6 FD    	STA  SECT	;PUT AT SECT # ADDRESS.
3108   E818             
3109   E818             
3110   E818             
3111   E818~            #IF (DEBUG & 80h)
3112   E818~               CALL SELECT_UART1
3113   E818             #ENDIF
3114   E818~            #IF (DEBUG & 1)  
3115   E818~            	CALL PRINTI		;DEBUG
3116   E818~            	.text " :SEC\000"
3117   E818~            	CALL	PUT_BYTE
3118   E818             #ENDIF
3119   E818~            #IF (DEBUG & 80h)  
3120   E818~               CALL SELECT_UART0
3121   E818             #ENDIF
3122   E818             
3123   E818             	
3124   E818 AF          	XRA  A		;Clear flags
3125   E819 C9          	RET		;RETURN FROM SETSEC.
3126   E81A             ;
3127   E81A             ; SET DISK DMA ADDRESS.
3128   E81A             ;
3129   E81A E5          SETDMA:	PUSH H
3130   E81B 60          	MOV  H,B	;MOVE B&C TO H&L.
3131   E81C 69          	MOV  L,C
3132   E81D 22 E7 FD    	SHLD DMAADD	;PUT AT DMA ADR ADDRESS.
3133   E820 E1          	POP  H
3134   E821 C9          	RET		;RETURN FROM SETDMA.
3135   E822             
3136   E822             
3137   E822             ;       Translate sector number from logical to physical.
3138   E822             ;
3139   E822             ;       ENTRY   DE = 0, no translation required.
3140   E822             ;               DE = translation table address.
3141   E822             ;               BC = sector number to translate.
3142   E822             ;
3143   E822             ;       EXIT    HL = translated sector.
3144   E822             
3145   E822 69          SECTRN:	MOV     L,C	;No Translation
3146   E823 60          	MOV     H,B
3147   E824 C9          	RET
3148   E825             	
3149   E825             	;CALL PRINTI		;DEBUG
3150   E825             	;.text " :TR-\000"
3151   E825             	;CALL	PUT_BC
3152   E825             	;CALL	PUT_DE
3153   E825             	
3154   E825             	;XCHG	;HL=DE
3155   E825             	;DAD B	;HL=DE + BC
3156   E825             	;MOV L,M ;A=M(HL)
3157   E825             	;MVI H,0
3158   E825             	;DCR L	
3159   E825             	;RET
3160   E825             
3161   E825             
3162   E825             
3163   E825             		
3164   E825             		
3165   E825             
3166   E825             ;
3167   E825             ; READ THE SECTOR AT SECT, FROM THE PRESENT DISK/TRACK/SSECT.
3168   E825             ; USE STARTING ADDRESS AT DMAADD.
3169   E825             ;
3170   E825 E5          DREAD:	PUSH	H	;Save HL
3171   E826 21 00 00    	LXI	H,0
3172   E829 39          	DAD	SP	;HL = SP
3173   E82A 31 00 F2    	LXI	SP,TEMP_STACK
3174   E82D E5          	PUSH	H	;Save SP on new stack
3175   E82E             
3176   E82E C5          	PUSH	B
3177   E82F D5          	PUSH	D
3178   E830 CD 75 E8    	CALL 	GETLOG	;Fetch Logical FSector of requested read
3179   E833             	
3180   E833             
3181   E833~            #IF (DEBUG & 80h)
3182   E833~               CALL SELECT_UART1
3183   E833             #ENDIF
3184   E833~            #IF (DEBUG & 1)  
3185   E833~            	CALL PRINTI		;DEBUG
3186   E833~            	.text " :DR\000"
3187   E833~            	CALL	PUT_HL
3188   E833             #ENDIF
3189   E833~            #IF (DEBUG & 80h)  
3190   E833~               CALL SELECT_UART0
3191   E833             #ENDIF
3192   E833             
3193   E833             	
3194   E833             	;LXI	D,-2002
3195   E833             	;DAD	D
3196   E833             	;JC	DREADE
3197   E833             	
3198   E833 CD 16 EA    	CALL	DISK_READ	;HL = Quarter Buffer
3199   E836 EB          	XCHG
3200   E837 2A E7 FD    	LHLD	DMAADD	;Destination, CP/M Data Buffer
3201   E83A EB          	XCHG
3202   E83B 06 80       	MVI	B,128
3203   E83D CD 2C F1    	CALL	COPY_RAM	;Copy the SD_RAM_BUFFER to CP/M DMAADD
3204   E840 AF          	XRA  A		;SET FLAGS.
3205   E841 C3 47 E8    	JMP	DREADX
3206   E844             
3207   E844 3E 01       DREADE	MVI	A,1	;ERROR
3208   E846 B7          	ORA	A
3209   E847             	
3210   E847 D1          DREADX	POP	D
3211   E848 C1          	POP	B	
3212   E849 E1          	POP	H	;Restore Stack Pointer
3213   E84A F9          	SPHL
3214   E84B E1          	POP	H	;Restore HL
3215   E84C C9          	RET
3216   E84D             
3217   E84D             
3218   E84D             
3219   E84D             ;
3220   E84D             ; WRITE THE SECTOR AT SECT, ON THE PRESENT TRACK.
3221   E84D             ; USE STARTING ADDRESS AT DMAADD.
3222   E84D             ;
3223   E84D E5          DWRITE:	PUSH	H	;Save HL
3224   E84E 21 00 00    	LXI	H,0
3225   E851 39          	DAD	SP	;HL = SP
3226   E852 31 00 F2    	LXI	SP,TEMP_STACK
3227   E855 E5          	PUSH	H	;Save SP on new stack
3228   E856             
3229   E856 F5          	PUSH	PSW
3230   E857 C5          	PUSH	B
3231   E858 D5          	PUSH	D
3232   E859 CD 75 E8    	CALL 	GETLOG	;Fetch Logical FSector of requested write
3233   E85C             			;DISK_READ will find the right Cluster/File sector *AND* Flush any previous writes.
3234   E85C             			
3235   E85C             	
3236   E85C~            #IF (DEBUG & 80h)
3237   E85C~               CALL SELECT_UART1
3238   E85C             #ENDIF
3239   E85C~            #IF (DEBUG & 1)  
3240   E85C~            	CALL PRINTI		;DEBUG
3241   E85C~            	.text " :DW\000"
3242   E85C~            	CALL	PUT_HL
3243   E85C             #ENDIF
3244   E85C~            #IF (DEBUG & 80h)  
3245   E85C~               CALL SELECT_UART0
3246   E85C             #ENDIF
3247   E85C             
3248   E85C             
3249   E85C CD 16 EA    	CALL	DISK_READ	;HL = Quarter Buffer
3250   E85F EB          	XCHG
3251   E860 2A E7 FD    	LHLD	DMAADD		;Source, CP/M Data Buffer
3252   E863 06 80       	MVI	B,128
3253   E865 CD 2C F1    	CALL	COPY_RAM	;Copy the SD_RAM_BUFFER to CP/M DMAADD
3254   E868 3E FF       	MVI	A,0FFH
3255   E86A 32 D7 FD    	STA	DIRTY_DATA
3256   E86D D1          	POP	D
3257   E86E C1          	POP	B
3258   E86F F1          	POP	PSW
3259   E870 AF          	XRA  A		;SET FLAGS.
3260   E871 E1          	POP	H	;Restore Stack Pointer
3261   E872 F9          	SPHL
3262   E873 E1          	POP	H	;Restore HL
3263   E874 C9          	RET
3264   E875             
3265   E875             ; Return Logical Disk Sector based on TRACK and SECTOR
3266   E875             ; Track starts at 0 for first track
3267   E875             ; Sector starts at 0 for first sector
3268   E875             ;
3269   E875 2A E4 FD    GETLOG	LHLD  TRK	;HL = TRK
3270   E878             
3271   E878             
3272   E878             ;-------------------------------------	Multiply Routine.  16bit by 8 bit -> 24bit
3273   E878             					;HL = 16bit input
3274   E878 11 00 00    		LXI	D,0		;DE = 16bit output
3275   E87B 06 08       		MVI	B,8		;Go through 8 bits
3276   E87D 3A 85 FD    		LDA	SEC_PER_TRACK	;Fetch Multiplier		
3277   E880 1F          GL_LP		RAR		
3278   E881 D2 87 E8    		JNC	GL_SHIFT
3279   E884 EB          		XCHG
3280   E885 19          		DAD	D		;DE=DE+HL
3281   E886 EB          		XCHG
3282   E887             
3283   E887 29          GL_SHIFT	DAD	H		;BHL=BHL*2		
3284   E888 05          		DCR	B		;Count down 8 bits
3285   E889 C2 80 E8    		JNZ	GL_LP
3286   E88C             
3287   E88C             
3288   E88C             			
3289   E88C 26 00       	MVI  H,0
3290   E88E 3A E6 FD    	LDA  SECT
3291   E891             	;DCR  A		;Option for Sector to start at 1
3292   E891 6F          	MOV  L,A
3293   E892 19          	DAD  D		;HL= TRK * SPT + SECT = 0000 to 07D1 (0 TO 2001)
3294   E893 22 99 FD    	SHLD	LOGICAL_SEC
3295   E896 C9          	RET
3296   E897             
3297   E897             
3298   E897             
3299   E897             ;----------------------------------------------------------------------------------------------------; CONSOLE BIOS
3300   E897             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
3301   E897             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
3302   E897             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
3303   E897             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
3304   E897             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
3305   E897             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
3306   E897             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
3307   E897             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
3308   E897             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
3309   E897             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
3310   E897             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
3311   E897             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
3312   E897             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
3313   E897             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
3314   E897             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
3315   E897             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
3316   E897             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
3317   E897             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
3318   E897             ;----------------------------------------------------------------------------------------------------; CONSOLE BIOS
3319   E897             
3320   E897             ;===============================================
3321   E897             ;PUT_NEW_LINE -- Start a new line on the console
3322   E897             ;
3323   E897             ;pre: none
3324   E897             ;post: 0x0A printed to console
3325   E897             ;-----------------------------------------------
3326   E897 CD E7 E8    PUT_NEW_LINE:	CALL	PRINTI
3327   E89A 0D 0A 00    		.text "\r\n\000"
3328   E89D C9          		RET
3329   E89E             
3330   E89E             ;===============================================
3331   E89E             ;PUT_BC Prints BC Word
3332   E89E             ;-----------------------------------------------
3333   E89E F5          PUT_BC:		PUSH	PSW
3334   E89F 78          		MOV	A, B
3335   E8A0 CD BF E8    		CALL	PUT_BYTE
3336   E8A3 79          		MOV	A, C
3337   E8A4 CD BF E8    		CALL	PUT_BYTE
3338   E8A7 F1          		POP	PSW
3339   E8A8 C9          		RET
3340   E8A9             
3341   E8A9             ;===============================================
3342   E8A9             ;PUT_DE Prints DE Word
3343   E8A9             ;-----------------------------------------------
3344   E8A9 F5          PUT_DE:		PUSH	PSW
3345   E8AA 7A          		MOV	A, D
3346   E8AB CD BF E8    		CALL	PUT_BYTE
3347   E8AE 7B          		MOV	A, E
3348   E8AF CD BF E8    		CALL	PUT_BYTE
3349   E8B2 F1          		POP	PSW
3350   E8B3 C9          		RET
3351   E8B4             
3352   E8B4             ;===============================================
3353   E8B4             ;PUT_HL Prints HL Word
3354   E8B4             ;-----------------------------------------------
3355   E8B4 F5          PUT_HL:		PUSH	PSW
3356   E8B5 7C          		MOV	A, H
3357   E8B6 CD BF E8    		CALL	PUT_BYTE
3358   E8B9 7D          		MOV	A, L
3359   E8BA CD BF E8    		CALL	PUT_BYTE
3360   E8BD F1          		POP	PSW
3361   E8BE C9          		RET
3362   E8BF             
3363   E8BF             ;===============================================
3364   E8BF             ;PUT_BYTE -- Output byte to console as hex
3365   E8BF             ;
3366   E8BF             ;pre:	A register contains byte to be output
3367   E8BF             ;post:
3368   E8BF             ;-----------------------------------------------
3369   E8BF F5          PUT_BYTE:	PUSH	PSW
3370   E8C0 0F          		RRC
3371   E8C1 0F          		RRC
3372   E8C2 0F          		RRC
3373   E8C3 0F          		RRC
3374   E8C4 CD CE E8    		CALL	PUT_HEX
3375   E8C7 F1          		POP	PSW
3376   E8C8 F5          		PUSH	PSW
3377   E8C9 CD CE E8    		CALL	PUT_HEX
3378   E8CC F1          		POP	PSW
3379   E8CD C9          		RET
3380   E8CE             
3381   E8CE             ;===============================================
3382   E8CE             ;PUT_HEX -- Convert nibble to ASCII char
3383   E8CE             ;
3384   E8CE             ;pre: A register contains nibble
3385   E8CE             ;post: A register contains ASCII char
3386   E8CE             ;-----------------------------------------------
3387   E8CE CD D4 E8    PUT_HEX:	CALL	BIN2HEX
3388   E8D1 C3 3A E9    		JMP	PUT_CHAR
3389   E8D4             		
3390   E8D4 E6 0F       BIN2HEX		ANI	0Fh
3391   E8D6 C6 90       		ADI	90h
3392   E8D8 27          		DAA
3393   E8D9 CE 40       		ACI	40h
3394   E8DB 27          		DAA
3395   E8DC C9          		RET
3396   E8DD             
3397   E8DD             ;===============================================
3398   E8DD             ;PRINT -- Print a null-terminated string
3399   E8DD             ;
3400   E8DD             ;pre: HL contains pointer to start of a null-
3401   E8DD             ;     terminated string
3402   E8DD             ;-----------------------------------------------
3403   E8DD 7E          PRINT:		MOV	A, M
3404   E8DE 23          		INX	H
3405   E8DF B7          		ORA	A
3406   E8E0 C8          		RZ
3407   E8E1 CD 3A E9    		CALL	PUT_CHAR
3408   E8E4 C3 DD E8    		JMP	PRINT
3409   E8E7             
3410   E8E7             ;===============================================
3411   E8E7             ;PRINT IMMEDIATE
3412   E8E7             ;-----------------------------------------------
3413   E8E7 E3          PRINTI:		XTHL	;HL = Top of Stack
3414   E8E8 F5          		PUSH	PSW
3415   E8E9 CD DD E8    		CALL	PRINT
3416   E8EC F1          		POP	PSW
3417   E8ED E3          		XTHL	;Move updated return address back to stack
3418   E8EE C9          		RET
3419   E8EF             
3420   E8EF             ;===============================================
3421   E8EF             ;PRINT B-LENGTH
3422   E8EF             ;-----------------------------------------------
3423   E8EF 7E          PRINTB		MOV	A, M
3424   E8F0 CD 3A E9    		CALL	PUT_CHAR
3425   E8F3 23          		INX	H
3426   E8F4 05          		DCR	B
3427   E8F5 C2 EF E8    		JNZ	PRINTB
3428   E8F8 C9          		RET
3429   E8F9             
3430   E8F9             
3431   E8F9             
3432   E8F9             ;===============================================
3433   E8F9             ;GET_CHAR_UART -- Get Char from UART
3434   E8F9             ;-----------------------------------------------
3435   E8F9 DB 25       GET_CHAR_UART	IN	UART0+5	;10	;TEST FOR RX DATA
3436   E8FB E6 01       		ANI	1	;7
3437   E8FD C2 24 E9    		JNZ	GCU_UART ;10
3438   E900             
3439   E900 3A 82 FD    		LDA	PROP_CHECK
3440   E903 B7          		ORA	A
3441   E904 CA F9 E8    		JZ	GET_CHAR_UART
3442   E907             		
3443   E907 DB 00       		IN	PROPELLERS
3444   E909 E6 02       		ANI	2
3445   E90B CA F9 E8    		JZ	GET_CHAR_UART
3446   E90E             		
3447   E90E DB 01       		IN	PROPELLERD ;Char from Propeller ready
3448   E910 B7          		ORA	A
3449   E911 CA 1A E9    		JZ	GCU_PROPSTRIKE
3450   E914 FE FF       		CPI	0FFh
3451   E916 CA 1A E9    		JZ	GCU_PROPSTRIKE
3452   E919 C9          		RET
3453   E91A             		
3454   E91A 3A 82 FD    GCU_PROPSTRIKE	LDA	PROP_CHECK
3455   E91D 3D          		DCR	A
3456   E91E 32 82 FD    		STA	PROP_CHECK
3457   E921 C3 F9 E8    		JMP	GET_CHAR_UART
3458   E924             
3459   E924 DB 20       GCU_UART	IN	UART0	;Char from UART ready
3460   E926 C9          		RET
3461   E927             
3462   E927             ;===============================================
3463   E927             ;GET_CHAR -- Get a char from the console
3464   E927             ;-----------------------------------------------
3465   E927 3A 81 FD    GET_CHAR:	LDA	ECHO_ON
3466   E92A B7          		ORA	A
3467   E92B CA 7D E9    		JZ	GET_CHAR_NE
3468   E92E CD 06 E6    GET_CHAR_LP	CALL	CONSTV	;TEST FOR RX DATA
3469   E931 CA 2E E9    		JZ	GET_CHAR_LP
3470   E934 CD F9 E8    		CALL	GET_CHAR_UART
3471   E937 FE 20       		CPI	' '	;Do not echo control chars
3472   E939 F8          		RM
3473   E93A             		;RET		;ECHO THE CHAR
3474   E93A             
3475   E93A             ;===============================================
3476   E93A             ;PUT_CHAR -- Output a character to the console
3477   E93A             ;-----------------------------------------------
3478   E93A F5          PUT_CHAR:	PUSH	PSW
3479   E93B             
3480   E93B             		;XRA	A		;256 ~= 2mSec Delay
3481   E93B             		;CALL	SD_DELAY		
3482   E93B             
3483   E93B DB 25       PC_LP		IN	UART0+5
3484   E93D             PCU5		.EQU	$-1
3485   E93D E6 20       		ANI	20H	;TEST FOR TX HOLD REG EMPTY
3486   E93F CA 3B E9    		JZ	PC_LP
3487   E942 F1          		POP	PSW
3488   E943 D3 20       		OUT	UART0
3489   E945             PCU0		.EQU	$-1
3490   E945 F5          		PUSH	PSW
3491   E946 3A 82 FD    		LDA	PROP_CHECK
3492   E949 B7          		ORA	A
3493   E94A CA 5F E9    		JZ	PC_EXIT
3494   E94D E5          		PUSH	H
3495   E94E 21 00 20    		LXI	H,2000h
3496   E951 2B          PC_LP2		DCX	H	;PUT A TIME LIMIT ON PROP STATUS
3497   E952 7C          		MOV	A,H
3498   E953 B5          		ORA	L
3499   E954 CA 5E E9    		JZ	PC_TO
3500   E957 DB 00       		IN	PROPELLERS
3501   E959 E6 04       		ANI	4
3502   E95B CA 51 E9    		JZ	PC_LP2
3503   E95E E1          PC_TO		POP	H
3504   E95F F1          PC_EXIT		POP	PSW
3505   E960 D3 01       		OUT	PROPELLERD
3506   E962 C9          		RET
3507   E963             
3508   E963             SELECT_UART0:
3509   E963 F5          	PUSH	PSW
3510   E964 3E 25       	MVI	A,UART0+5
3511   E966 32 3C E9    	STA	PCU5
3512   E969 3E 20       	MVI	A,UART0
3513   E96B 32 44 E9    	STA	PCU0
3514   E96E F1          	POP	PSW
3515   E96F C9          	RET
3516   E970             
3517   E970             SELECT_UART1:
3518   E970 F5          	PUSH	PSW
3519   E971 3E 2D       	MVI	A,UART1+5
3520   E973 32 3C E9    	STA	PCU5
3521   E976 3E 28       	MVI	A,UART1
3522   E978 32 44 E9    	STA	PCU0
3523   E97B F1          	POP	PSW
3524   E97C C9          	RET
3525   E97D             
3526   E97D             ;===============================================
3527   E97D             ;GET_CHAR -- Get a char from the console NO ECHO
3528   E97D             ;-----------------------------------------------
3529   E97D CD 06 E6    GET_CHAR_NE:	CALL	CONSTV	;TEST FOR RX DATA
3530   E980 CA 7D E9    		JZ	GET_CHAR_NE
3531   E983 CD F9 E8    		CALL	GET_CHAR_UART
3532   E986 C9          		RET
3533   E987             
3534   E987             
3535   E987             
3536   E987             ;----------------------------------------------------------------------------------------------------; FLOPPY DISK BIOS
3537   E987             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
3538   E987             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
3539   E987             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
3540   E987             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
3541   E987             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
3542   E987             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
3543   E987             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
3544   E987             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
3545   E987             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
3546   E987             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
3547   E987             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
3548   E987             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
3549   E987             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
3550   E987             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
3551   E987             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
3552   E987             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
3553   E987             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
3554   E987             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
3555   E987             ;----------------------------------------------------------------------------------------------------; FLOPPY DISK BIOS
3556   E987             
3557   E987             
3558   E987             
3559   E987             
3560   E987             ;SDFCB:
3561   E987             FSTAT		.EQU	0	;BLOCK	1	;+0  Status of FCB, 00=File Not Open
3562   E987             FNAME		.EQU	1	;BLOCK	11	;+1  File name
3563   E987             AFClus0		.EQU	12	;BLOCK	2	;+12 First Cluster of File as given by the Directory Entry.
3564   E987             CRFClus		.EQU	14	;BLOCK	2	;+14 Current Relative Cluster location in file, (0 to F for a system with 32 Sectors per Cluster)
3565   E987             CAFClus		.EQU	16	;BLOCK	2	;+16 Current Absolute Cluster location in file, set to AFClus0, then updated with FAT
3566   E987             RFSec		.EQU	18	;BLOCK	2	;+18 Relative Sector being addressed (0 to 500, based 26 sectors per track and 77 tracks Divide by 4)
3567   E987             SSOC		.EQU	20	;BLOCK	4	;+20 Starting Sector of Cluster, this is the first Sector for that Cluster
3568   E987             ABS_SEC		.EQU	24	;BLOCK	4	;+24 Absolute Sector of Current Relative Sector
3569   E987             
3570   E987             
3571   E987             
3572   E987             ;=====================================================================================================
3573   E987             ;Set FCB Pointer to one of 4 FCB blocks
3574   E987             ;=====================================================================================================
3575   E987 C5          SET_FCB_PTR	PUSH	B
3576   E988 E6 03       		ANI	03H		;Limit & Clear Carry
3577   E98A 0F          		RRC			;Set A x 32 to offset into correct FCB
3578   E98B 0F          		RRC
3579   E98C 0F          		RRC
3580   E98D 4F          		MOV	C,A
3581   E98E 06 00       		MVI	B,0
3582   E990 21 00 FD    		LXI	H,SDISKA
3583   E993 09          		DAD	B		;HL = FCB[A]
3584   E994 22 83 FD    		SHLD	FCB_PTR
3585   E997 0F          		RRC			;Set A x 16
3586   E998 4F          		MOV	C,A		;BC = A x 16
3587   E999 7E          		MOV	A,M		;Fetch FCB FSTAT (Is File OPEN / Exist)
3588   E99A 21 00 00    		LXI	H,0		;HL = 0000 File (disk) not ready
3589   E99D B7          		ORA	A
3590   E99E CA A5 E9    		JZ	SFPE
3591   E9A1 21 3F E6    		LXI	H,DPBASE
3592   E9A4 09          		DAD	B		;HL = DPBASE[A]
3593   E9A5 C1          SFPE		POP	B
3594   E9A6 C9          		RET
3595   E9A7             
3596   E9A7             
3597   E9A7             ;=====================================================================================================
3598   E9A7             ;Directory Routines.  1st Routine to start/init the search, 2nd routine to continue the search
3599   E9A7             ;=====================================================================================================
3600   E9A7             
3601   E9A7             ;-----------------------------------------------------------------------------------------------------
3602   E9A7             ;Call this routine to initialize and start the HL Pointer to the first Directory Entry
3603   E9A7 21 C0 FD    SD_LDIR1	LXI	H,DIR_SECTOR	;SEC_PTR = DIR_SECTOR
3604   E9AA CD D1 F0    		CALL	MOV_32_HL
3605   E9AD 2A B0 FD    		LHLD	ROOTDIR_SIZE	;ENT_COUNT = ROOTDIR_SIZE (to count down directory entries searched)
3606   E9B0 22 D8 FD    		SHLD	ENT_COUNT
3607   E9B3 B7          		ORA	A		;Clear Carry, Read only if Necessary
3608   E9B4             
3609   E9B4 CD BB ED    SD_FETCH	CALL	SD_READ_SEC	;Fetch a ROOT DIRECTORY sector
3610   E9B7 21 00 FE    		LXI	H,SD_RAM_BUFFER	;(Re)start H at start of Sector
3611   E9BA AF          SD_TEST		XRA	A		;EXIT Z=0 if there is a File at this entry
3612   E9BB BE          		CMP	M
3613   E9BC C9          		RET
3614   E9BD             
3615   E9BD             ;-----------------------------------------------------------------------------------------------------
3616   E9BD             ;Call this routine to advance to the next Directory Entry (loads next sector and restarts HL as needed)
3617   E9BD             ;-----------------------------------------------------------------------------------------------------
3618   E9BD 01 20 00    SD_LDIRN	LXI	B,20h		;Advance to next file entry
3619   E9C0 09          		DAD	B
3620   E9C1 D2 BA E9    		JNC	SD_TEST		;Check if extended beyond this sector
3621   E9C4             
3622   E9C4 AF          		XRA	A		;Return Z=1 if no more files
3623   E9C5 2A D8 FD    		LHLD	ENT_COUNT
3624   E9C8 01 F0 FF    		LXI	B,-16
3625   E9CB 09          		DAD	B
3626   E9CC 22 D8 FD    		SHLD	ENT_COUNT
3627   E9CF D0          		RNC			;Out of Directory entries
3628   E9D0 7C          		MOV	A,H
3629   E9D1 B5          		ORA	L
3630   E9D2 C8          		RZ			;Out of Directory entries
3631   E9D3             
3632   E9D3 21 D3 FD    		LXI	H,SEC_PTR	;Advance to next SECTOR
3633   E9D6 CD D1 F0    		CALL	MOV_32_HL
3634   E9D9 CD F1 F0    		CALL	INC_32
3635   E9DC C3 B4 E9    		JMP	SD_FETCH
3636   E9DF             
3637   E9DF             ;-----------------------------------------------------------------------------------------------------
3638   E9DF             ;-----------------------------------------------------------------------------------------------------
3639   E9DF             		;Find File w/ Verbose Output
3640   E9DF             		;Call with File Name set in FILENAME.EXT
3641   E9DF             		;Return Z=1 File Not Found
3642   E9DF             		;	Z=0 File Found, HL = Ptr to Directory Entry in SD_RAM_BUFFER
3643   E9DF 21 C8 FD    SDV_FIND_FILE	LXI	H,FILENAME
3644   E9E2 CD 75 F0    		CALL	PRINT_FILENAME
3645   E9E5 CD 08 EA    SDV_FIND_FILE1	CALL	SD_FIND_FILE	;Call the Find File routine
3646   E9E8 C2 FB E9    		JNZ	SDV_FOUND	;Print Yah or Nah
3647   E9EB CD E7 E8    		CALL 	PRINTI
3648   E9EE 202D4E4F5420 		.text " -NOT FOUND\000"
3648   E9F4 464F554E4400
3649   E9FA C9          		RET
3650   E9FB CD E7 E8    SDV_FOUND	CALL 	PRINTI
3651   E9FE 202D45584953 		.text " -EXISTS\000"
3651   EA04 545300
3652   EA07 C9          		RET
3653   EA08             
3654   EA08             ;-----------------------------------------------------------------------------------------------------
3655   EA08             		;Find File
3656   EA08             		;Call with File Name set in RAM variable: FILENAME.EXT
3657   EA08             		;Return Z=1 File Not Found
3658   EA08             		;	Z=0 File Found, HL = Ptr to Directory Entry in SD_RAM_BUFFER
3659   EA08 CD A7 E9    SD_FIND_FILE	CALL	SD_LDIR1
3660   EA0B C8          SDFF_LP 	RZ			;End of list
3661   EA0C CD DB EB    		CALL	CMP_FILENAME
3662   EA0F C0          		RNZ			;FILE FOUND
3663   EA10 CD BD E9    		CALL	SD_LDIRN
3664   EA13 C3 0B EA    		JMP	SDFF_LP
3665   EA16             
3666   EA16             
3667   EA16             
3668   EA16             ;=====================================================================================================
3669   EA16             ;Read of Logical Disk Sector.
3670   EA16             ;=====================================================================================================
3671   EA16             	;Start-of-Directory = Size-of-Fat * Number-of-fats + 1 (boot sector)
3672   EA16             	;Start-of-Data-Area = Start-of-Directory + #Entries/32/bytes_per_sector
3673   EA16             
3674   EA16             	;Input:	Disk Sector required (0 to 2001) based on 26 sectors per track by 77 tracks, counting from 0
3675   EA16             	;Disk FCB in HL
3676   EA16             
3677   EA16             	;if AFClus0 = 0x0000 then attempt to open the file report Disk not loaded if fail
3678   EA16             	;Relative file sector:
3679   EA16             	;DISK_SEC is the input to this routine, it holds Virtual Disk Sector 0 to 2001
3680   EA16             	;because every SD sector has 512 bytes, each SD sector holds 4 CP/M Virtual Disk sectors (that's 128 bytes)
3681   EA16             	;RFSec is the Relative File Sector, it spans from 0 to 500 (this accomodates 501 SD Sectors or 256,512 bytes)
3682   EA16             	;If RFSec = DISK_SEC / 4 Then...
3683   EA16             	;If RFSec has not changed, then read that sector into RAM and be done.
3684   EA16             	;That Relative File sector is located on the SD card at address set in the absolute sector (ABS_SEC)
3685   EA16             	;
3686   EA16             	;If RFSec has changed... then determine is the new RFSec is within the same cluster or not.
3687   EA16             	;On a 1Gig SD card, the system uses 32 sectors per cluster.  This means, 32 sequential SD Memory Card sectors form 1 cluster.
3688   EA16             	;If a sector within the same cluster is being accessed, then the cluster does not have to be found again.
3689   EA16             	;If it's NOT in the same cluster, then find new cluster by looking through the FAT
3690   EA16             	;If it is in the same cluster, then skip to the part were we can just offset the RFSec into the current cluster
3691   EA16             	;
3692   EA16             	;...else
3693   EA16             	;RFSec = DISK_SEC / 4  'Set the new sector as the current one.
3694   EA16             	;
3695   EA16             	;Find the Relative File Cluster (RFClus).  This number will be from 0 to 15 on a 1Gig SD Card = 262,144 bytes (to hold a 256,256 file)
3696   EA16             	;
3697   EA16             	;Relative file cluster:
3698   EA16             	;RFClus = RFSec / SEC_PER_CLUS
3699   EA16             	;if RFClus has changed, then recalculate the File Cluster and then update the SSOC.
3700   EA16             	;  if RFClus < CRFClus then CRFClus=0, CAFClus = AFClus0  'start FAT search from 0 if going backward
3701   EA16             	;  RFClus = RFClus - CRFClus
3702   EA16             	;  do while RFClus>0
3703   EA16             	;      if CAFClus = 0xFFFF Then EOF reached, file too small to be a disk. (Report as disk error)
3704   EA16             	;      CAFClus = FAT(CAFClus)
3705   EA16             	;      CRFClus = CRFClus + 1
3706   EA16             	;      RFClus = RFClus - 1
3707   EA16             	;  loop
3708   EA16             	;  SSOC = (CAFClus - 2) * SEC_PER_CLUS + Start-of-Data-Area
3709   EA16             	;if RFClus has NOT changed, then ABS_SEC = SSOC + (RFSec MOD SEC_PER_CLUS), then read ABS_SEC into the buffer.
3710   EA16             
3711   EA16             ;=====================================================================================================
3712   EA16             ;Read of Logical Disk Sector.
3713   EA16             ;Input:	LOGICAL_SEC = 0=First Sector, 2001=Last Sector based on 26 Sectors/Track and 77 Tracks
3714   EA16             ;	FCB_PTR	= Points to Drive (File) selected to read from
3715   EA16             DISK_READ	
3716   EA16             ;		CALL	PRINTI
3717   EA16             ;		.text " R-\000"
3718   EA16             ;		LHLD	LOGICAL_SEC
3719   EA16             ;		CALL	PUT_HL
3720   EA16             
3721   EA16 2A 83 FD    		LHLD	FCB_PTR	;Get Current Disk FCB
3722   EA19 7E          		MOV	A,M		;Is file open?
3723   EA1A B7          		ORA	A		;Test FSTAT
3724   EA1B C2 3F EA    		JNZ	DR_1		;Jump YES
3725   EA1E             		
3726   EA1E             ;		CALL	PRINTI
3727   EA1E             ;		.text " HL:\000"
3728   EA1E             ;		CALL	PUT_HL
3729   EA1E             		
3730   EA1E CD A0 EB    		CALL	SD_OPEN		;ELSE, Attempt to open file
3731   EA21 2A 83 FD    		LHLD	FCB_PTR
3732   EA24 7E          		MOV	A,M		;Is file open?
3733   EA25 B7          		ORA	A		;Test FSTAT
3734   EA26 C2 3F EA    		JNZ	DR_1		;Jump YES
3735   EA29 CD E7 E8    		CALL	PRINTI
3736   EA2C 202D4469736B 		.text " -Disk Not Loaded\000"
3736   EA32 204E6F74204C6F6164656400
3737   EA3E C9          		RET			;Exit if file could not open
3738   EA3F             
3739   EA3F             DR_1		;LHLD	FCB_PTR		;If file open, Check if Read is from same Data Sector (4 LSectors fit in 1 DSector)
3740   EA3F 01 12 00    		LXI	B,RFSec
3741   EA42 09          		DAD	B		;H=FCB(RFSec)
3742   EA43 5E          		MOV	E,M
3743   EA44 23          		INX	H
3744   EA45 56          		MOV	D,M		;D=RFSec
3745   EA46 2A 99 FD    		LHLD	LOGICAL_SEC	;Fetch sector to be read
3746   EA49 06 02       		MVI	B,2
3747   EA4B CD 19 F1    		CALL	RHLR		;Rotate HL right 2 times
3748   EA4E CD 13 F1    		CALL	CMP_DE_HL
3749   EA51 C2 61 EA    		JNZ	DR_NEW_SEC	;Jump if Read is from a different Data Sector
3750   EA54             
3751   EA54             					;LOGICAL SECTOR = LAST READ SECTOR, Fetch Absolute Sector and read it to RAM (if wasn't last read)
3752   EA54 2A 83 FD    		LHLD	FCB_PTR		;H=FCB
3753   EA57 01 18 00    		LXI	B,ABS_SEC
3754   EA5A 09          		DAD	B		;H=FCB(ABS_SEC)
3755   EA5B             
3756   EA5B CD D1 F0    		CALL	MOV_32_HL
3757   EA5E C3 69 EB    		JMP	DR_READ_IT
3758   EA61             
3759   EA61             
3760   EA61             	;RFClus = RFSec / SEC_PER_CLUS
3761   EA61             	;if RFClus has changed, then recalculate the File Cluster and then update the SSOC.
3762   EA61             	;  if RFClus < CRFClus then
3763   EA61             	;     CRFClus=0, CAFClus = AFClus0  'start FAT search from 0 if going backward
3764   EA61             	;  eles
3765   EA61             	;     RFClus = RFClus - CRFClus	   'else, continue FAT search from point of
3766   EA61             	;  endif
3767   EA61             	;  do while RFClus>0
3768   EA61             	;      if CAFClus = 0xFFFF Then EOF reached, file too small to be a disk. (Report as disk error)
3769   EA61             	;      CAFClus = FAT(CAFClus)
3770   EA61             	;      CRFClus = CRFClus + 1
3771   EA61             	;      RFClus = RFClus - 1
3772   EA61             	;  loop
3773   EA61             	;  SSOC = (CAFClus - 2) * SEC_PER_CLUS + Start-of-Data-Area
3774   EA61             	;if RFClus has NOT changed, then ABS_SEC = SSOC + (RFSec MOD SEC_PER_CLUS), then read ABS_SEC into the buffer.
3775   EA61             DR_NEW_SEC
3776   EA61 EB          		XCHG			;D=LOGICAL_SEC/4 = Relative File Sector (Update FCB with this new Rel-File-Sec
3777   EA62 2A 83 FD    		LHLD	FCB_PTR		;Set FCB(RFSec)
3778   EA65 01 12 00    		LXI	B,RFSec
3779   EA68 09          		DAD	B		;H=FCB(RFSec)
3780   EA69 73          		MOV	M,E		;MOV (HL),DE
3781   EA6A 23          		INX	H
3782   EA6B 72          		MOV	M,D
3783   EA6C             
3784   EA6C 2A 91 FD    		LHLD	DIVIDE_FUNC	;DE = DE / Sectors-Per-Cluster
3785   EA6F CD 45 F1    		CALL	VCALL
3786   EA72 2A 83 FD    		LHLD	FCB_PTR		;Set FCB(CRFClus)
3787   EA75 01 0E 00    		LXI	B,CRFClus
3788   EA78 09          		DAD	B		;H=FCB(CRFClus)
3789   EA79 E5          		PUSH	H
3790   EA7A CD 35 F1    		CALL	LD_HL_HL
3791   EA7D 44          		MOV	B,H		;BC = CRFClus
3792   EA7E 4D          		MOV	C,L
3793   EA7F             
3794   EA7F E1          		POP	H		;H->FCB(CRFClus)
3795   EA80             					;TEST DE - BC  aka NewRFClus vs FCB-RFClus
3796   EA80             					;Speed Optimize the above code
3797   EA80 7A          		MOV	A,D
3798   EA81 B8          		CMP	B
3799   EA82 C2 8A EA    		JNZ	DR_DIFF_CLUS
3800   EA85 7B          		MOV	A,E
3801   EA86 B9          		CMP	C
3802   EA87 CA 45 EB    		JZ	DR_SAME_CLUS	;IF they are the same, then the new sector is in the same cluster
3803   EA8A D2 95 EA    DR_DIFF_CLUS	JNC	DR_BIGGER_CLUS
3804   EA8D             
3805   EA8D             					;If going to a smaller cluster, restart the FAT search from the begining
3806   EA8D 01 00 00    		LXI	B,0		;CRFClus = 0
3807   EA90 2B          		DCX	H
3808   EA91 2B          		DCX	H
3809   EA92 C3 9D EA    		JMP	DR_SEEK_FAT	;HL will load with AFClus0
3810   EA95             
3811   EA95             DR_BIGGER_CLUS
3812   EA95 7B          		MOV	A,E		;NewRFClus = NewRFClus - FCB-RFClus,  ie Set counter for number of new FAT hops.
3813   EA96 91          		SUB	C
3814   EA97 5F          		MOV	E,A
3815   EA98 7A          		MOV	A,D
3816   EA99 98          		SBB	B
3817   EA9A 57          		MOV	D,A
3818   EA9B             
3819   EA9B 23          		INX	H
3820   EA9C 23          		INX	H		;HL will load with CAFClus
3821   EA9D             
3822   EA9D             	;  do while RFClus>0
3823   EA9D             	;      if CAFClus = 0xFFFF Then EOF reached, file too small to be a disk. (Report as disk error)
3824   EA9D             	;      CAFClus = FAT(CAFClus)
3825   EA9D             	;      CRFClus = CRFClus + 1
3826   EA9D             	;      RFClus = RFClus - 1
3827   EA9D             	;  loop
3828   EA9D             
3829   EA9D             DR_SEEK_FAT
3830   EA9D CD 35 F1    		CALL	LD_HL_HL	;HL = CAFClus or AFClus0
3831   EAA0             
3832   EAA0             ;		CALL	PRINTI
3833   EAA0             ;		.text "\r\nCAFClus=\000"
3834   EAA0             ;		CALL	PUT_HL
3835   EAA0             ;		CALL	PRINTI
3836   EAA0             ;		.text "\r\nCRFClus=\000"
3837   EAA0             ;		CALL	PUT_BC
3838   EAA0             ;		CALL	PRINTI
3839   EAA0             ;		.text "\r\nRFClus=\000"
3840   EAA0             ;		CALL	PUT_DE
3841   EAA0             
3842   EAA0             					;BC = CRFClus
3843   EAA0 7A          DR_SEEK_LP	MOV	A,D		;DE = RFClus
3844   EAA1 B3          		ORA	E
3845   EAA2 CA E8 EA    		JZ	DR_SEEK_DONE
3846   EAA5             
3847   EAA5             ;		CALL	PRINTI
3848   EAA5             ;		.text "\r\nseek=\000"
3849   EAA5             ;		CALL	PUT_HL
3850   EAA5             
3851   EAA5 23          		INX	H		;IF CAFClus = 0xFFFF...
3852   EAA6 7C          		MOV	A,H
3853   EAA7 B5          		ORA	L
3854   EAA8 CA DC EA    		JZ	SDO_FSERR2	;Error, File too small
3855   EAAB 2B          		DCX	H
3856   EAAC             
3857   EAAC             	;Here comes the FAT Hopping FUN...
3858   EAAC             	;      CAFClus = FAT(CAFClus)
3859   EAAC             	;it's convenient that 1 Sector is 512 bytes, that's 256 words = 256 FAT Entries, therefore...
3860   EAAC             	;H = Sector of FAT
3861   EAAC             	;L = Word within that Sector of FAT
3862   EAAC             
3863   EAAC C5          		PUSH	B
3864   EAAD D5          		PUSH	D
3865   EAAE E5          		PUSH	H
3866   EAAF 5C          		MOV	E,H		;E=Sector of FAT
3867   EAB0 2A BC FD    		LHLD	FAT1START	;DE = E + FAT1START
3868   EAB3 7D          		MOV	A,L
3869   EAB4 83          		ADD	E
3870   EAB5 5F          		MOV	E,A
3871   EAB6 7C          		MOV	A,H
3872   EAB7 CE 00       		ACI	0		;Carry it forward
3873   EAB9 57          		MOV	D,A
3874   EABA 2A BE FD    		LHLD	FAT1START+2
3875   EABD D2 C1 EA    		JNC	DRS_0		;Test for Carry
3876   EAC0 23          		INX	H		;Carry it forward
3877   EAC1 44          DRS_0		MOV	B,H
3878   EAC2 4D          		MOV	C,L		;BCDE now have Sector of FAT desired
3879   EAC3 CD BB ED    		CALL	SD_READ_SEC
3880   EAC6 D1          		POP	D		;Fetch DE, E=Word within that FAT sector
3881   EAC7 21 00 FE    		LXI	H,SD_RAM_BUFFER
3882   EACA B7          		ORA	A		;Clear Carry
3883   EACB 7B          		MOV	A,E		;Fetch offset into FAT sector read
3884   EACC 17          		RAL
3885   EACD 6F          		MOV	L,A		;
3886   EACE 7C          		MOV	A,H
3887   EACF CE 00       		ACI	0
3888   EAD1 67          		MOV	H,A		;HL -> FAT Entry
3889   EAD2 CD 35 F1    		CALL	LD_HL_HL	;HL = FAT Entry
3890   EAD5 D1          		POP	D
3891   EAD6 C1          		POP	B
3892   EAD7             
3893   EAD7 03          		INX	B
3894   EAD8 1B          		DCX	D
3895   EAD9 C3 A0 EA    		JMP	DR_SEEK_LP
3896   EADC             
3897   EADC CD E7 E8    SDO_FSERR2	CALL	PRINTI
3898   EADF 202D21454F46 		.text " -!EOF!\000"
3898   EAE5 2100
3899   EAE7 C9          		RET
3900   EAE8             
3901   EAE8             
3902   EAE8             DR_SEEK_DONE	;Write Registers to FCB
3903   EAE8             		;BC = CRFClus
3904   EAE8             		;DE = RFClus - Not required (it's a counter down to zero to find the correct cluster)
3905   EAE8             		;HL = CAFClus
3906   EAE8             
3907   EAE8 EB          		XCHG			;DE = CAFClus
3908   EAE9 2A 83 FD    		LHLD	FCB_PTR		;Set FCB(CRFClus)
3909   EAEC D5          		PUSH	D
3910   EAED 11 0E 00    		LXI	D,CRFClus
3911   EAF0 19          		DAD	D		;H=FCB(CRFClus)
3912   EAF1 D1          		POP	D
3913   EAF2 71          		MOV	M,C		;Save CRFClust to FCB
3914   EAF3 23          		INX	H
3915   EAF4 70          		MOV	M,B
3916   EAF5 23          		INX	H
3917   EAF6 73          		MOV	M,E		;Save CAFClus to FCB
3918   EAF7 23          		INX	H
3919   EAF8 72          		MOV	M,D
3920   EAF9             
3921   EAF9             	;Now, let's find the Data Sector to be loaded....
3922   EAF9             	;First, calculate the Starting Sector of Cluster (SSOC)
3923   EAF9             	;  SSOC = (CAFClus - 2) * SEC_PER_CLUS + Start-of-Data-Area
3924   EAF9             
3925   EAF9 EB          		XCHG			;HL = CAFClus
3926   EAFA 2B          		DCX	H		;CAFClus - 2
3927   EAFB 2B          		DCX	H
3928   EAFC             
3929   EAFC             ;-------------------------------------	Multiply Routine.  16bit by 8 bit -> 24bit
3930   EAFC 01 00 00    		LXI	B,0		;BHL = 16bit input (need 24 bits to shift)
3931   EAFF 11 00 00    		LXI	D,0		;CDE = 24bit output
3932   EB02 3E 08       		MVI	A,8		;Go through 8 bits
3933   EB04 32 95 FD    		STA	M_COUNTER
3934   EB07 3A AC FD    		LDA	SEC_PER_CLUS	;Fetch Multiplier
3935   EB0A 1F          DRSS_LP		RAR
3936   EB0B 32 94 FD    		STA	MUL8
3937   EB0E D2 17 EB    		JNC	DRSS_SHIFT
3938   EB11 EB          		XCHG
3939   EB12 19          		DAD	D		;DE=DE+HL
3940   EB13 EB          		XCHG
3941   EB14 79          		MOV	A,C
3942   EB15 88          		ADC	B
3943   EB16 4F          		MOV	C,A
3944   EB17             
3945   EB17 29          DRSS_SHIFT	DAD	H		;BHL=BHL*2
3946   EB18 78          		MOV	A,B		;
3947   EB19 17          		RAL
3948   EB1A 47          		MOV	B,A
3949   EB1B 3A 95 FD    		LDA	M_COUNTER	;Count down 8 bits
3950   EB1E 3D          		DCR	A
3951   EB1F 32 95 FD    		STA	M_COUNTER
3952   EB22 3A 94 FD    		LDA	MUL8		;Fetch next Multiplier bit
3953   EB25 C2 0A EB    		JNZ	DRSS_LP
3954   EB28             ;-------
3955   EB28             					;Add to BCDE, the DATASTART sector
3956   EB28 06 00       		MVI	B,0		;BCDE = 32bit Absolute sector
3957   EB2A 2A C4 FD    		LHLD	DATASTART	;32 Bit ADD DATASTART
3958   EB2D 19          		DAD	D
3959   EB2E EB          		XCHG			;DE=DE+START (LSB)
3960   EB2F 2A C6 FD    		LHLD	DATASTART+2
3961   EB32 D2 36 EB    		JNC	DRSS_ABC
3962   EB35 03          		INX	B		;Add Carry out of 16 Bit ADD
3963   EB36 09          DRSS_ABC	DAD	B
3964   EB37 E5          		PUSH	H
3965   EB38 C1          		POP	B		;BC=BC+START (MSB)
3966   EB39             ;-------
3967   EB39             					;Save the result to RAM variable SSOC
3968   EB39 2A 83 FD    		LHLD	FCB_PTR		;Set FCB(SSOC)
3969   EB3C C5          		PUSH	B
3970   EB3D 01 14 00    		LXI	B,SSOC
3971   EB40 09          		DAD	B		;H=FCB(SSOC)
3972   EB41 C1          		POP	B
3973   EB42 CD D9 F0    		CALL	MOV_HL_32	;Save the 32 bit register BCDE to (HL)
3974   EB45             ;-------
3975   EB45             
3976   EB45             	;ABS_SEC = SSOC + (RFSec MOD SEC_PER_CLUS), then read ABS_SEC into the buffer.
3977   EB45             DR_SAME_CLUS				;Fetch the RFSec
3978   EB45 2A 83 FD    		LHLD	FCB_PTR		;Set FCB(RFSec)
3979   EB48 01 12 00    		LXI	B,RFSec
3980   EB4B 09          		DAD	B		;H=FCB(RFSec)
3981   EB4C             
3982   EB4C 5E          		MOV	E,M		;DE=RFSec
3983   EB4D 23          		INX	H
3984   EB4E 56          		MOV	D,M
3985   EB4F             
3986   EB4F 2A 96 FD    		LHLD	MOD_FUNC	;DE = DE % Sectors-Per-Cluster
3987   EB52 CD 45 F1    		CALL	VCALL		;A = RFSec MOD SEC_PER_CLUS
3988   EB55             
3989   EB55 2A 83 FD    		LHLD	FCB_PTR		;Set FCB(SSOC)
3990   EB58 01 14 00    		LXI	B,SSOC
3991   EB5B 09          		DAD	B		;H=FCB(SSOC)
3992   EB5C 01 00 00    		LXI	B,0		;BCDE = (RFSec MOD SEC_PER_CLUS)
3993   EB5F 16 00       		MVI	D,0
3994   EB61 5F          		MOV	E,A
3995   EB62 CD E1 F0    		CALL	ADD_32_HL	;BCDE = SSOC + (RFSec MOD SEC_PER_CLUS)
3996   EB65             
3997   EB65 23          		INX	H		;Advance HL to ABS_SEC
3998   EB66 CD D9 F0    		CALL	MOV_HL_32	;Save the ABS_SEC
3999   EB69             
4000   EB69 CD BB ED    DR_READ_IT	CALL	SD_READ_SEC	;Fetch the Sector
4001   EB6C             
4002   EB6C             ;--------- Set HL to the 128 byte Quarter Buffer of SD_RAM_BUFFER
4003   EB6C 21 00 FE    SET_QUARTER	LXI	H,SD_RAM_BUFFER
4004   EB6F 3A 99 FD    		LDA	LOGICAL_SEC	;Fetch sector to be read (lsb)
4005   EB72 1F          		RAR			;Adjust H to correct LSector of 128 Bytes
4006   EB73 1F          		RAR
4007   EB74 D2 78 EB    		JNC	SQ_0
4008   EB77 24          		INR	H
4009   EB78 17          SQ_0		RAL
4010   EB79 06 80       		MVI	B,128		;Preset Length of copy = 128 Bytes
4011   EB7B D0          		RNC
4012   EB7C 2E 80       		MVI	L,80h
4013   EB7E C9          		RET
4014   EB7F             
4015   EB7F             
4016   EB7F             ;=====================================================================================================
4017   EB7F             		;Open File (Mount Disk)	;Input:	FCB_PTR = FCB
4018   EB7F             		;Tests if file exists, right size, then copies the Starting Cluster to the FCB
4019   EB7F 2A 83 FD    SD_OPENT	LHLD	FCB_PTR
4020   EB82 7E          		MOV	A,M		;Is file open?
4021   EB83 E6 CF       		ANI	0CFH		;Test FSTAT
4022   EB85 CA A0 EB    		JZ	SD_OPEN
4023   EB88 CD E7 E8    		CALL	PRINTI
4024   EB8B 202D46494C45 		.text " -FILE ALREADY OPEN\000"
4024   EB91 20414C5245414459204F50454E00
4025   EB9F C9          		RET
4026   EBA0             		
4027   EBA0             ;SD_OPEN   -Open FAT-16 file on SD card
4028   EBA0             ;Searches Directory for file - Returns Zero flag if File not found.
4029   EBA0             
4030   EBA0 2A 83 FD    SD_OPEN		LHLD	FCB_PTR
4031   EBA3 36 00       		MVI	M,0		;FSTAT=0, Clear Open Status
4032   EBA5 23          		INX	H		;+1 = FNAME
4033   EBA6 11 C8 FD    		LXI	D,FILENAME	;Write FCB File name to FILENAME for finding
4034   EBA9 06 0B       		MVI	B,11
4035   EBAB CD 2C F1    		CALL	COPY_RAM
4036   EBAE CD DF E9    		CALL	SDV_FIND_FILE	;Return with H=Directory Entry
4037   EBB1 C8          		RZ			;Exit if file not found
4038   EBB2             
4039   EBB2 01 1A 00    		LXI	B,001Ah		;START CLUSTER & File Size Offset (into Directory Entry)
4040   EBB5 09          		DAD	B		;H=(FILE SIZE)
4041   EBB6 11 DA FD    		LXI	D,CLUSTER1
4042   EBB9 06 06       		MVI	B,6
4043   EBBB CD 2C F1    		CALL	COPY_RAM
4044   EBBE             		
4045   EBBE 2A DA FD    		LHLD	CLUSTER1
4046   EBC1 EB          		XCHG			;DE=CLUSTER1			
4047   EBC2 2A 83 FD    		LHLD	FCB_PTR		;H=FCB
4048   EBC5 36 01       		MVI	M,1		;FSTAT=1
4049   EBC7 01 0C 00    		LXI	B,AFClus0	;offset to AFClus0
4050   EBCA 09          		DAD	B
4051   EBCB 73          		MOV	M,E		;Save Starting Cluster
4052   EBCC 23          		INX	H
4053   EBCD 72          		MOV	M,D
4054   EBCE 23          		INX	H
4055   EBCF 06 0E       		MVI	B,14
4056   EBD1 3E FF       		MVI	A,0FFH
4057   EBD3 CD 3A F1    		CALL	FILL_BLOCK	;Fill 14 bytes of FF (Nuke pointers to force new calculations)
4058   EBD6 2A 83 FD    		LHLD	FCB_PTR		;H=FCB
4059   EBD9 3D          		DCR	A		;Z=0
4060   EBDA C9          		RET	
4061   EBDB             
4062   EBDB             
4063   EBDB             
4064   EBDB             
4065   EBDB             ;-----------------------------------------------------------------------------------------------------
4066   EBDB E5          CMP_FILENAME	PUSH	H		;Save H pointer into Directory
4067   EBDC 06 0B       		MVI	B,11		;Compare 11 characters
4068   EBDE 11 C8 FD    		LXI	D,FILENAME
4069   EBE1 1A          CMPF_LP1	LDAX	D
4070   EBE2 BE          		CMP	M
4071   EBE3 C2 EF EB    		JNZ	CMPF_RETFAIL	;Exit if not equal
4072   EBE6 23          		INX	H
4073   EBE7 13          		INX	D
4074   EBE8 05          		DCR	B
4075   EBE9 C2 E1 EB    		JNZ	CMPF_LP1
4076   EBEC             
4077   EBEC 04          		INR	B		;Z=0
4078   EBED E1          		POP	H
4079   EBEE C9          		RET
4080   EBEF AF          CMPF_RETFAIL	XRA	A		;Z=1
4081   EBF0 E1          		POP	H
4082   EBF1 C9          		RET
4083   EBF2             
4084   EBF2             
4085   EBF2             
4086   EBF2             
4087   EBF2             ;		MVI	B,8		;Compare 8 characters
4088   EBF2             ;		LXI	D,FILENAME
4089   EBF2             ;CMPF_LP1	LDAX	D
4090   EBF2             ;		CMP	M
4091   EBF2             ;		JNZ	CMPF_RETFAIL	;Exit if not equal
4092   EBF2             ;		INX	H
4093   EBF2             ;		INX	D
4094   EBF2             ;		DCR	B
4095   EBF2             ;		JNZ	CMPF_LP1
4096   EBF2             ;
4097   EBF2             ;		POP	H
4098   EBF2             ;		PUSH	H
4099   EBF2             ;		LXI	D,8		;Point to Ext in Dir
4100   EBF2             ;		DAD	D
4101   EBF2             ;
4102   EBF2             ;		MVI	B,3
4103   EBF2             ;		LXI	D,FILEEXT
4104   EBF2             ;CMPF_LP2	LDAX	D
4105   EBF2             ;		CMP	M
4106   EBF2             ;		JNZ	CMPF_RETFAIL
4107   EBF2             ;		INX	H
4108   EBF2             ;		INX	D
4109   EBF2             ;		DCR	B
4110   EBF2             ;		JNZ	CMPF_LP2
4111   EBF2             ;		INR	B		;Z=0
4112   EBF2             ;		POP	H
4113   EBF2             ;		RET
4114   EBF2             ;CMPF_RETFAIL	XRA	A		;Z=1
4115   EBF2             ;		POP	H
4116   EBF2             ;		RET
4117   EBF2             
4118   EBF2             
4119   EBF2             
4120   EBF2             ;=====================================================================================================
4121   EBF2             ;=====================================================================================================
4122   EBF2 21 87 FD    INIT_FAT	LXI	H,CLEAR_RAM	;Clear RAM
4123   EBF5 06 00       		MVI	B,0
4124   EBF7 AF          		XRA	A
4125   EBF8 CD 3A F1    		CALL	FILL_BLOCK
4126   EBFB             
4127   EBFB             		;XRA	A		;Flag no more Dirty Data
4128   EBFB             		;STA	DIRTY_DATA	;which would require flushing changed data to SD Memory Card
4129   EBFB CD B9 EE    		CALL	INIT_SDCARD
4130   EBFE C0          		RNZ
4131   EBFF             
4132   EBFF CD E7 E8    		CALL 	PRINTI		;
4133   EC02 4D 42 52 00 		.text "MBR\000"
4134   EC06             
4135   EC06             
4136   EC06 01 00 00    		LXI	B,0		;BCDE = 0x00000000
4137   EC09 11 00 00    		LXI	D,0
4138   EC0C 37          		STC			;Force Read
4139   EC0D CD BB ED    		CALL	SD_READ_SEC	;READ MBR
4140   EC10 CD A6 ED    		CALL	TEST_SIGNATURE
4141   EC13 C0          		RNZ
4142   EC14             
4143   EC14 CD E7 E8    		CALL 	PRINTI		;
4144   EC17 205479706500 		.text " Type\000"
4145   EC1D 3A C2 FF    		LDA	SD_RAM_BUFFER+01C2h
4146   EC20 CD BF E8    		CALL	PUT_BYTE
4147   EC23 32 A1 FD    		STA	SD_PART_TYPE
4148   EC26 FE 04       		CPI	4
4149   EC28 CA 35 EC    		JZ	INITFAT_PGOOD
4150   EC2B FE 06       		CPI	6
4151   EC2D CA 35 EC    		JZ	INITFAT_PGOOD
4152   EC30 FE 86       		CPI	86h
4153   EC32 C2 90 ED    		JNZ	INITFAT_FAIL
4154   EC35             
4155   EC35 21 C6 FF    INITFAT_PGOOD	LXI	H,SD_RAM_BUFFER+1C6h
4156   EC38 11 A2 FD    		LXI	D,SD_PART_BASE
4157   EC3B 06 08       		MVI	B,8
4158   EC3D CD 2C F1    		CALL	COPY_RAM	;Copy BASE & SIZE from BUFFER to RAM Variables
4159   EC40 CD E7 E8    		CALL 	PRINTI		;
4160   EC43 2050425200  		.text " PBR\000"
4161   EC48             
4162   EC48 21 A2 FD    		LXI	H,SD_PART_BASE
4163   EC4B CD D1 F0    		CALL	MOV_32_HL	;Copy BASE to SEC_PTR
4164   EC4E CD BB ED    		CALL	SD_READ_SEC	;READ BOOT RECORD OF PARTITION
4165   EC51 CD A6 ED    		CALL	TEST_SIGNATURE
4166   EC54 C0          		RNZ
4167   EC55             
4168   EC55 21 0B FE    		LXI	H,SD_RAM_BUFFER+0Bh
4169   EC58 11 AA FD    		LXI	D,BYTE_P_SEC
4170   EC5B 06 0A       		MVI	B,10
4171   EC5D CD 2C F1    		CALL	COPY_RAM	;Copy Description Table to RAM Variables (Up to Total Filesys Sectors)
4172   EC60 EB          		XCHG			;Test TOTAL_FILESYS_SECTORS = 0
4173   EC61 2B          		DCX	H
4174   EC62 2B          		DCX	H
4175   EC63 7E          		MOV	A,M
4176   EC64 23          		INX	H
4177   EC65 B6          		ORA	M
4178   EC66 C2 74 EC    		JNZ	INITFAT_TFS_OK
4179   EC69 2B          		DCX	H
4180   EC6A EB          		XCHG
4181   EC6B 21 20 FE    		LXI	H,SD_RAM_BUFFER+020h
4182   EC6E             
4183   EC6E CD 2A F1    		CALL	COPY_RAM4
4184   EC71 C3 7B EC    		JMP	INITFAT_TFS_DONE
4185   EC74             
4186   EC74 AF          INITFAT_TFS_OK	XRA	A
4187   EC75 23          		INX	H
4188   EC76 77          		MOV	M,A
4189   EC77 23          		INX	H
4190   EC78 77          		MOV	M,A
4191   EC79 23          		INX	H
4192   EC7A EB          		XCHG
4193   EC7B             INITFAT_TFS_DONE
4194   EC7B             
4195   EC7B 21 1C FE    		LXI	H,SD_RAM_BUFFER+01Ch
4196   EC7E CD 2A F1    		CALL	COPY_RAM4	;Copy HIDDEN_SECTORS to RAM Variables
4197   EC81 21 16 FE    		LXI	H,SD_RAM_BUFFER+016h
4198   EC84 CD 25 F1    		CALL	COPY_RAM2	;Copy SECTORS_PER_FAT to RAM Variables
4199   EC87             
4200   EC87             ;BS.fat1Start = MBR.part1Start + BS.reservedSectors;
4201   EC87 2A AD FD    		LHLD	RESERVED_SEC	;H=Reserved Sectors
4202   EC8A EB          		XCHG
4203   EC8B 2A A2 FD    		LHLD	SD_PART_BASE	;FAT1START = SD_PART_BASE + RESERVED_SEC
4204   EC8E 19          		DAD	D
4205   EC8F 22 BC FD    		SHLD	FAT1START
4206   EC92 2A A4 FD    		LHLD	SD_PART_BASE+2
4207   EC95 D2 99 EC    		JNC	INITFAT_C1_DONE
4208   EC98 23          		INX	H
4209   EC99 22 BE FD    INITFAT_C1_DONE	SHLD	FAT1START+2
4210   EC9C             
4211   EC9C             ;firstDirSector = BS.fat1Start + (BS.fatCopies * BS.sectorsPerFAT);
4212   EC9C 3A AF FD    		LDA	FAT_COPIES
4213   EC9F 47          		MOV	B,A
4214   ECA0 2A BA FD    		LHLD	SEC_PER_FAT
4215   ECA3 EB          		XCHG
4216   ECA4 21 00 00    		LXI	H,0
4217   ECA7 19          INITFAT_C2_LP	DAD	D
4218   ECA8 05          		DCR	B
4219   ECA9 C2 A7 EC    		JNZ	INITFAT_C2_LP	;H = FAT_COPIES * SEC_PER_FAT
4220   ECAC EB          		XCHG			;D = H
4221   ECAD 2A BC FD    		LHLD	FAT1START
4222   ECB0 19          		DAD	D		;DIR_SECTOR = FAT1START + FAT_COPIES * SEC_PER_FAT
4223   ECB1 22 C0 FD    		SHLD	DIR_SECTOR
4224   ECB4 2A BE FD    		LHLD	FAT1START+2
4225   ECB7 D2 BB EC    		JNC	INITFAT_C2_DONE
4226   ECBA 23          		INX	H
4227   ECBB 22 C2 FD    INITFAT_C2_DONE	SHLD	DIR_SECTOR+2
4228   ECBE             
4229   ECBE             ;DATASTART = DIR_SECTOR + LEN(Directory)
4230   ECBE             ;          = DIR_SECTOR + ROOTDIR_SIZE * 32 / BYTE_P_SEC
4231   ECBE 06 10       		MVI	B,16		;Maximum # of Reductions
4232   ECC0 2A AA FD    		LHLD	BYTE_P_SEC	;To fit math into 16 bits, let's reduce "ROOTDIR_SIZE / BYTE_P_SEC"
4233   ECC3 EB          		XCHG			;Divide each by 2 while dividable
4234   ECC4 2A B0 FD    		LHLD	ROOTDIR_SIZE	;H=ROOTDIR_SIZE, D=BYTE_P_SEC
4235   ECC7 7B          INITFAT_C3_LP	MOV	A,E
4236   ECC8 1F          		RAR
4237   ECC9 DA F6 EC    		JC	INITFAT_C3_0	;If lsb of D is 1, no more Reduction possible
4238   ECCC 7D          		MOV	A,L
4239   ECCD 1F          		RAR
4240   ECCE DA F6 EC    		JC	INITFAT_C3_0	;If lsb of H is 1, no more Reduction possible
4241   ECD1 7A          		MOV	A,D
4242   ECD2 1F          		RAR
4243   ECD3 57          		MOV	D,A
4244   ECD4 7B          		MOV	A,E
4245   ECD5 1F          		RAR
4246   ECD6 5F          		MOV	E,A
4247   ECD7 7C          		MOV	A,H
4248   ECD8 1F          		RAR
4249   ECD9 67          		MOV	H,A
4250   ECDA 7D          		MOV	A,L
4251   ECDB 1F          		RAR
4252   ECDC 6F          		MOV	L,A
4253   ECDD 05          		DCR	B
4254   ECDE C2 C7 EC    		JNZ	INITFAT_C3_LP
4255   ECE1 CD E7 E8    INITFAT_C3_ERR	CALL 	PRINTI		;
4256   ECE4 204572726F72 		.text " Error DATASTART\000"
4256   ECEA 2044415441535441525400
4257   ECF5 C9          		RET
4258   ECF6 06 05       INITFAT_C3_0	MVI	B,5		;5 shifts = Multiply 32
4259   ECF8 29          INITFAT_C3_LP2	DAD	H		;Double H
4260   ECF9 DA E1 EC    		JC	INITFAT_C3_ERR
4261   ECFC 05          		DCR	B
4262   ECFD C2 F8 EC    		JNZ	INITFAT_C3_LP2
4263   ED00             
4264   ED00 7B          		MOV	A,E		;2'S Complement BYTE_P_SEC
4265   ED01 2F          		CMA
4266   ED02 4F          		MOV	C,A
4267   ED03 7A          		MOV	A,D
4268   ED04 2F          		CMA
4269   ED05 47          		MOV	B,A
4270   ED06 03          		INX	B
4271   ED07 11 FF FF    		LXI	D,0FFFFh	;Start with -1
4272   ED0A 09          INITFAT_C3_LP3	DAD	B		;Divide by counting Subtractions
4273   ED0B 13          		INX	D
4274   ED0C DA 0A ED    		JC	INITFAT_C3_LP3
4275   ED0F 2A C0 FD    		LHLD	DIR_SECTOR	;Add the Dword at DIR_SECTOR
4276   ED12 19          		DAD	D
4277   ED13 22 C4 FD    		SHLD	DATASTART
4278   ED16 2A C2 FD    		LHLD	DIR_SECTOR+2
4279   ED19 D2 1D ED    		JNC	INITFAT_C3_1
4280   ED1C 23          		INX	H
4281   ED1D 22 C6 FD    INITFAT_C3_1	SHLD	DATASTART+2
4282   ED20             
4283   ED20 3A AC FD    		LDA	SEC_PER_CLUS	;Determine the best way to divide Sectors into cluster#
4284   ED23 3D          		DCR	A
4285   ED24 32 98 FD    		STA	MODMASK
4286   ED27 3C          		INR	A
4287   ED28 CA 7A ED    		JZ	INITFAT_FAIL1
4288   ED2B 01 00 08    		LXI	B,0800h
4289   ED2E 1F          INITFAT_C4_LP	RAR
4290   ED2F D2 34 ED    		JNC	INITFAT_C4_1
4291   ED32 50          		MOV	D,B		;Save location of "1" bit
4292   ED33 0C          		INR	C		;Count of 1 bits.
4293   ED34 05          INITFAT_C4_1	DCR	B
4294   ED35 C2 2E ED    		JNZ	INITFAT_C4_LP
4295   ED38 3E 01       		MVI	A,1
4296   ED3A B9          		CMP	C
4297   ED3B C2 4E ED    		JNZ	INITFAT_C4_2	;More than 1 "1" bit, cannot do divide by simple shift.
4298   ED3E 7A          		MOV	A,D		;Fetch position of the 1 bit.  8=lsb, 1=msb
4299   ED3F 2F          		CMA
4300   ED40 C6 0A       		ADI	10		;Re-adjust to make 1=lsb AND 8=msb  A=9-A
4301   ED42 32 93 FD    		STA	DF_SHIFTCNT
4302   ED45 21 62 F1    		LXI	H,DIVBYSHIFT	;Use fast shift divider
4303   ED48 11 72 F1    		LXI	D,MODBYMASK
4304   ED4B C3 53 ED    		JMP	INITFAT_C4_3
4305   ED4E             
4306   ED4E 21 46 F1    INITFAT_C4_2	LXI	H,DIV16BY8SPC	;Use Full Divide function for Sectors Per Cluster
4307   ED51 E5          		PUSH	H
4308   ED52 D1          		POP	D
4309   ED53 22 91 FD    INITFAT_C4_3	SHLD	DIVIDE_FUNC
4310   ED56 EB          		XCHG
4311   ED57 22 96 FD    		SHLD	MOD_FUNC
4312   ED5A             
4313   ED5A CD E7 E8    		CALL 	PRINTI		;
4314   ED5D 20564F4C3D00 		.text " VOL=\000"
4315   ED63 21 2B FE    		LXI	H,0FE2Bh
4316   ED66 06 0B       		MVI	B,11
4317   ED68 CD EF E8    		CALL	PRINTB
4318   ED6B CD E7 E8    		CALL 	PRINTI		;
4319   ED6E 205359533D00 		.text " SYS=\000"
4320   ED74 06 08       		MVI	B,8
4321   ED76 CD EF E8    		CALL	PRINTB
4322   ED79 C9          		RET
4323   ED7A             
4324   ED7A             
4325   ED7A CD E7 E8    INITFAT_FAIL1	CALL 	PRINTI		;
4326   ED7D 0D0A4572726F 		.text "\r\nError=0 Sec/Clus\000"
4326   ED83 723D30205365632F436C757300
4327   ED90 CD E7 E8    INITFAT_FAIL	CALL 	PRINTI		;
4328   ED93 0D0A46415420 		.text "\r\nFAT Init FAILED\000"
4328   ED99 496E6974204641494C454400
4329   EDA5 C9          		RET
4330   EDA6             
4331   EDA6             ;SD_CARD_TYPE	.BLOCK	1	;SD CARD TYPE
4332   EDA6             ;SDC_STATUS	.BLOCK	1	;SD Status Code returned
4333   EDA6             ;SD_PARAM	.BLOCK	4	;32 bit address parameter for SD Commands
4334   EDA6             ;SD_PART_TYPE	.BLOCK	1	;SD PARTITION TYPE
4335   EDA6             ;SD_PART_BASE	.BLOCK	4	;SD PARTITION STARTING RECORD
4336   EDA6             ;SD_PART_SIZE	.BLOCK	4	;SD PARTITION SIZE (Must follow SD_PART_BASE)
4337   EDA6             ;SEC_PER_CLUS	.BLOCK	1	;0x0D
4338   EDA6             ;RESERVED_SEC	.BLOCK	2	;0x0E - 0x0F
4339   EDA6             ;FAT_COPIES	.BLOCK	1	;0x10
4340   EDA6             ;RT_DIR_ENTRIES	.BLOCK	2	;0x11 - 0x12
4341   EDA6             ;TOT_FILESYS_SEC.BLOCK	4	;0x13 - 0x14 or 0x20 - 0x23
4342   EDA6             ;HIDDEN_SECTORS	.BLOCK	4	;0x1C - 0x1F
4343   EDA6             ;SEC_PER_FAT	.BLOCK	2	;0x16 - 0x17
4344   EDA6             ;FAT1START	.BLOCK	4	;Calculated
4345   EDA6             ;DIR_SECTOR	.BLOCK	4	;Calculated
4346   EDA6             ;DATASTART	.BLOCK	4	;Calculated
4347   EDA6             
4348   EDA6             ;-------------------------------------------------
4349   EDA6 CD E7 E8    TEST_SIGNATURE	CALL 	PRINTI		;
4350   EDA9 20 53 00    		.text " S\000"
4351   EDAC 2B          		DCX	H
4352   EDAD 3E AA       		MVI	A,0AAh
4353   EDAF BE          		CMP	M
4354   EDB0 C2 90 ED    		JNZ	INITFAT_FAIL
4355   EDB3 2B          		DCX	H
4356   EDB4 3E 55       		MVI	A,055h
4357   EDB6 BE          		CMP	M
4358   EDB7 C2 90 ED    		JNZ	INITFAT_FAIL
4359   EDBA C9          		RET
4360   EDBB             
4361   EDBB             
4362   EDBB             ;=====================================================================================================
4363   EDBB             ;SD Memory Car Routines, Mid Level, Send/Recieve Data Sectors (Writes out Dirty Data)
4364   EDBB             ;=====================================================================================================
4365   EDBB             
4366   EDBB             ;-----------------------------------------------------------------------------------------------------
4367   EDBB             ;Read to the SD_RAM_BUFFER from the SD Card at Sector BCDE
4368   EDBB             ;-----------------------------------------------------------------------------------------------------
4369   EDBB             		;Sector in SEC_PTR
4370   EDBB 21 D3 FD    SD_READ_SEC	LXI	H,SEC_PTR	;READ SECTOR
4371   EDBE DA C5 ED    		JC	SD_RS_FORCED
4372   EDC1 CD F7 F0    		CALL	CMP_HL_32
4373   EDC4 C8          		RZ			;Return if no change to sector being read/written
4374   EDC5             
4375   EDC5 3A D7 FD    SD_RS_FORCED	LDA	DIRTY_DATA	;Test if flush required
4376   EDC8 B7          		ORA	A
4377   EDC9 CA DC ED    		JZ	SD_RS_NC	;Jump if no change in SD RAM BUFFER
4378   EDCC AF          		XRA	A
4379   EDCD 32 D7 FD    		STA	DIRTY_DATA	;Clear Write Flag
4380   EDD0             
4381   EDD0 C5          		PUSH	B
4382   EDD1 D5          		PUSH	D
4383   EDD2 E5          		PUSH	H
4384   EDD3 CD D1 F0    		CALL	MOV_32_HL	;Fetch the last SEC_PTR
4385   EDD6             
4386   EDD6             
4387   EDD6~            #IF (DEBUG & 80h)
4388   EDD6~               CALL SELECT_UART1
4389   EDD6             #ENDIF
4390   EDD6~            #IF (DEBUG & 2)  
4391   EDD6~            	CALL PRINTI		;DEBUG
4392   EDD6~            	.text " Write:\000"
4393   EDD6~            	CALL	PUT_BC
4394   EDD6~            	CALL	PUT_DE
4395   EDD6             #ENDIF
4396   EDD6~            #IF (DEBUG & 80h)  
4397   EDD6~               CALL SELECT_UART0
4398   EDD6             #ENDIF
4399   EDD6             
4400   EDD6 CD 25 EE    		CALL	SD_WRITE_SEC
4401   EDD9             	
4402   EDD9 E1          		POP	H
4403   EDDA D1          		POP	D
4404   EDDB C1          		POP	B
4405   EDDC             
4406   EDDC             SD_RS_NC
4407   EDDC             		
4408   EDDC~            #IF (DEBUG & 80h)
4409   EDDC~               CALL SELECT_UART1
4410   EDDC             #ENDIF
4411   EDDC~            #IF (DEBUG & 2)  
4412   EDDC~            	CALL PRINTI		;DEBUG
4413   EDDC~            	.text " Read:\000"
4414   EDDC~            	CALL	PUT_BC
4415   EDDC~            	CALL	PUT_DE
4416   EDDC             #ENDIF
4417   EDDC~            #IF (DEBUG & 80h)  
4418   EDDC~               CALL SELECT_UART0
4419   EDDC             #ENDIF
4420   EDDC             
4421   EDDC             
4422   EDDC 21 D3 FD    		LXI	H,SEC_PTR
4423   EDDF CD D9 F0    		CALL	MOV_HL_32	;Save Sector in SEC_PTR
4424   EDE2 CD 9E EE    		CALL	SET_PARAM	;READ SECTOR
4425   EDE5 06 05       		MVI	B,5	;5 Retries to read
4426   EDE7 3E 11       SD_RS_LP0	MVI	A,17 	;Read Sector Command
4427   EDE9 CD BE EF    		CALL	SD_CMD
4428   EDEC CA F8 ED    		JZ	SD_RS_0
4429   EDEF 05          		DCR	B
4430   EDF0 C2 E7 ED    		JNZ	SD_RS_LP0
4431   EDF3             				;Read failed
4432   EDF3 05          		DCR	B	;Clear Zero flag
4433   EDF4 CD A6 EF    		CALL	SD_DESELECT	;Deselect card
4434   EDF7 C9          		RET
4435   EDF8 06 00       SD_RS_0		MVI	B,0		;256 Attempts to recieve the DATASTART
4436   EDFA CD 04 F0    SD_RS_LP1	CALL	SPI_RX
4437   EDFD FE FE       		CPI	0FEh		;IS DATASTART?
4438   EDFF CA 0A EE    		JZ	SD_RS_1
4439   EE02 05          		DCR	B
4440   EE03 C2 FA ED    		JNZ	SD_RS_LP1
4441   EE06 CD A6 EF    		CALL	SD_DESELECT	;Deselect card
4442   EE09 C9          		RET
4443   EE0A             
4444   EE0A 01 00 02    SD_RS_1		LXI	B,0200h
4445   EE0D CD 04 F0    SD_RS_LP2	CALL	SPI_RX	;Fetch 512 Bytes to M(HL)
4446   EE10 77          		MOV	M,A
4447   EE11 23          		INX	H
4448   EE12 0D          		DCR	C
4449   EE13 C2 0D EE    		JNZ	SD_RS_LP2
4450   EE16 05          		DCR	B
4451   EE17 C2 0D EE    		JNZ	SD_RS_LP2
4452   EE1A             
4453   EE1A CD 04 F0    		CALL	SPI_RX	;BURN 2 BYTES (CRC)
4454   EE1D CD 04 F0    		CALL	SPI_RX	;
4455   EE20 CD A6 EF    		CALL	SD_DESELECT	;Deselect card
4456   EE23 AF          		XRA	A
4457   EE24 C9          		RET
4458   EE25             
4459   EE25             
4460   EE25             
4461   EE25             ;-----------------------------------------------------------------------------------------------------
4462   EE25             ;Write the SD_RAM_BUFFER to the SD Card at Sector 'SEC_PTR'
4463   EE25             ;-----------------------------------------------------------------------------------------------------
4464   EE25             		;Sector in SEC_PTR, H=SD_RAM_BUFFER
4465   EE25 CD 9E EE    SD_WRITE_SEC	CALL	SET_PARAM
4466   EE28 3E 18       		MVI	A,24 	;Write Sector Command
4467   EE2A CD BE EF    		CALL	SD_CMD
4468   EE2D 3E 01       		MVI	A,1 	;Error Code
4469   EE2F C2 83 EE    		JNZ	SD_WR_FAIL
4470   EE32             
4471   EE32 3E FE       		MVI	A,0FEh	;DATA START BLOCK
4472   EE34 D3 30       		OUT	SPI
4473   EE36 01 00 02    		LXI	B,0200h
4474   EE39 7E          SD_WR_LP	MOV	A,M
4475   EE3A 23          		INX	H
4476   EE3B D3 30       		OUT	SPI
4477   EE3D 0D          		DCR	C
4478   EE3E C2 39 EE    		JNZ	SD_WR_LP
4479   EE41 05          		DCR	B
4480   EE42 C2 39 EE    		JNZ	SD_WR_LP
4481   EE45             
4482   EE45 3E FF       		MVI	A,0FFh
4483   EE47 D3 30       		OUT	SPI
4484   EE49 00          		NOP
4485   EE4A 3E FF       		MVI	A,0FFh
4486   EE4C D3 30       		OUT	SPI
4487   EE4E             
4488   EE4E CD 04 F0    		CALL	SPI_RX
4489   EE51 E6 1F       		ANI	1Fh
4490   EE53 FE 05       		CPI	5
4491   EE55 3E 02       		MVI	A,2 	;Error Code
4492   EE57 C2 83 EE    		JNZ	SD_WR_FAIL
4493   EE5A CD 0C F0    		CALL	WAIT_NOT_BUSY
4494   EE5D 3E 03       		MVI	A,3 	;Error Code
4495   EE5F DA 83 EE    		JC	SD_WR_FAIL
4496   EE62 CD 2E F0    		CALL	SD_CLEAR_ARG
4497   EE65 3E 0D       		MVI	A,13		;SEND_STATUS
4498   EE67 CD BE EF    		CALL	SD_CMD
4499   EE6A 3E 04       		MVI	A,4 	;Error Code
4500   EE6C C2 83 EE    		JNZ	SD_WR_FAIL
4501   EE6F CD 04 F0    		CALL	SPI_RX
4502   EE72 B7          		ORA	A
4503   EE73 3E 05       		MVI	A,5 	;Error Code
4504   EE75 C2 83 EE    		JNZ	SD_WR_FAIL
4505   EE78             
4506   EE78 AF          		XRA	A		;A should be zero
4507   EE79 32 D7 FD    		STA	DIRTY_DATA
4508   EE7C             
4509   EE7C CD B9 EF    		CALL	SD_DELAY
4510   EE7F             
4511   EE7F CD A6 EF    		CALL	SD_DESELECT	;Deselect card
4512   EE82 C9          		RET
4513   EE83             
4514   EE83 CD A6 EF    SD_WR_FAIL	CALL	SD_DESELECT	;Deselect card
4515   EE86 CD E7 E8    		CALL	PRINTI
4516   EE89 0D0A2D577269 		.text "\r\n-Write Failed:\000"
4516   EE8F 7465204661696C65643A00
4517   EE9A CD BF E8    		CALL	PUT_BYTE
4518   EE9D C9          		RET
4519   EE9E             
4520   EE9E             ;-----------------------------------------------------------------------------------------------------
4521   EE9E             ;Input:	Sector in 32 bit register BCDE
4522   EE9E 3A 9B FD    SET_PARAM	LDA	SD_CARD_TYPE	;IF CARD_TYPE <> 3 THEN SHIFT SECTOR << 9 Bits
4523   EEA1 FE 03       		CPI	3
4524   EEA3 CA AF EE    		JZ	SP_RET
4525   EEA6             
4526   EEA6 79          		MOV	A,C
4527   EEA7 EB          		XCHG
4528   EEA8 29          		DAD	H
4529   EEA9 17          		RAL
4530   EEAA 47          		MOV	B,A
4531   EEAB 4C          		MOV	C,H
4532   EEAC 55          		MOV	D,L
4533   EEAD 1E 00       		MVI	E,0
4534   EEAF             
4535   EEAF 21 9D FD    SP_RET		LXI	H,SD_PARAM
4536   EEB2 CD D9 F0    		CALL	MOV_HL_32	;Save Parameter
4537   EEB5 21 00 FE    		LXI	H,SD_RAM_BUFFER	;Set buffer space
4538   EEB8 C9          		RET
4539   EEB9             
4540   EEB9             
4541   EEB9             ;=====================================================================================================
4542   EEB9             ;SD Memory Car Routines, Low Level, INIT CARD, Send/Recieve Data, Send Commands
4543   EEB9             ;=====================================================================================================
4544   EEB9             ;-------------------------------- INIT SDCARD --------------------------------
4545   EEB9 CD A6 EF    INIT_SDCARD	CALL	SD_DESELECT	;Deselect and clock the card many cycles
4546   EEBC 0E 80       		MVI	C,080H
4547   EEBE 3E FF       		MVI	A,0FFH
4548   EEC0 32 9B FD    		STA	SD_CARD_TYPE
4549   EEC3 D3 30       ISD_0		OUT	SPI		;CLOCK many cycles
4550   EEC5 0D          		DCR	C
4551   EEC6 C2 C3 EE    		JNZ	ISD_0
4552   EEC9 CD AD EF    		CALL	SD_SELECT
4553   EECC             
4554   EECC CD E7 E8    		CALL 	PRINTI		;
4555   EECF 0D0A496E6974 		.text "\r\nInit SD\000"
4555   EED5 20534400
4556   EED9             
4557   EED9 CD 2E F0    		CALL	SD_CLEAR_ARG	;Fetch the 01 response
4558   EEDC 06 00       		MVI	B,0		;256 retries
4559   EEDE 3E 00       ISD_LP1		MVI	A,0		;CMD 0
4560   EEE0 CD BE EF    		CALL	SD_CMD
4561   EEE3 FE 01       		CPI	1		;Test 01 response
4562   EEE5 CA FD EE    		JZ	ISD_1
4563   EEE8 05          		DCR	B
4564   EEE9 C2 DE EE    		JNZ	ISD_LP1
4565   EEEC             		;JMP	INIT_FAIL
4566   EEEC CD E7 E8    INIT_FAIL	CALL 	PRINTI		;
4567   EEEF 2D4641494C45 		.text "-FAILED\000"
4567   EEF5 4400
4568   EEF7 CD A6 EF    		CALL	SD_DESELECT
4569   EEFA AF          		XRA	A		;Return Zero Flag cleared = Failure
4570   EEFB 3D          		DCR	A
4571   EEFC C9          		RET
4572   EEFD             
4573   EEFD CD E7 E8    ISD_1		CALL 	PRINTI		;
4574   EF00 205479706523 		.text " Type#\000"
4574   EF06 00
4575   EF07 21 AA 01    		LXI	H,01AAh		;Deterimine Card Type
4576   EF0A 22 9D FD    		SHLD	SD_PARAM
4577   EF0D 3E 08       		MVI	A,8		;CMD 8
4578   EF0F CD BE EF    		CALL	SD_CMD
4579   EF12 E6 04       		ANI	4
4580   EF14 CA 1F EF    		JZ	ISD_2
4581   EF17 3E 01       		MVI	A,1		;If CMD8 is Illegal Cmd, CARD_TYPE=1
4582   EF19 32 9B FD    		STA	SD_CARD_TYPE
4583   EF1C C3 3A EF    		JMP	ISD_3
4584   EF1F             
4585   EF1F CD 04 F0    ISD_2		CALL	SPI_RX
4586   EF22 CD 04 F0    		CALL	SPI_RX
4587   EF25 CD 04 F0    		CALL	SPI_RX
4588   EF28 CD 04 F0    		CALL	SPI_RX
4589   EF2B 32 9C FD    		STA	SDC_STATUS
4590   EF2E FE AA       		CPI	0AAh
4591   EF30 3E AA       		MVI	A,0AAh		;Error code
4592   EF32 C2 EC EE    		JNZ	INIT_FAIL
4593   EF35 3E 02       		MVI	A,2
4594   EF37 32 9B FD    		STA	SD_CARD_TYPE
4595   EF3A             
4596   EF3A CD CE E8    ISD_3		CALL	PUT_HEX
4597   EF3D CD E7 E8    		CALL 	PRINTI		;
4598   EF40 2041434D4434 		.text " ACMD41\000"
4598   EF46 3100
4599   EF48 CD 2E F0    		CALL	SD_CLEAR_ARG
4600   EF4B             
4601   EF4B 06 00       		MVI	B,0
4602   EF4D 3E 37       ISD_LP2		MVI	A,55		;CMD 55 (ACMD)
4603   EF4F CD BE EF    		CALL	SD_CMD
4604   EF52 3E 29       		MVI	A,41		;CMD 41
4605   EF54 CD BE EF    		CALL	SD_CMD
4606   EF57 FE 00       		CPI	0
4607   EF59 CA 67 EF    		JZ	ISD_4
4608   EF5C AF          		XRA	A		;256 ~= 2mSec Delay
4609   EF5D CD B9 EF    		CALL	SD_DELAY
4610   EF60 05          		DCR	B
4611   EF61 C2 4D EF    		JNZ	ISD_LP2
4612   EF64 C3 EC EE    		JMP	INIT_FAIL
4613   EF67             
4614   EF67 CD E7 E8    ISD_4		CALL 	PRINTI		;
4615   EF6A 2B 00       		.text "+\000"
4616   EF6C 3A 9B FD    		LDA	SD_CARD_TYPE
4617   EF6F FE 02       		CPI	2
4618   EF71 C2 A1 EF    		JNZ	ISD_6
4619   EF74 3E 3A       		MVI	A,58		;CMD 58
4620   EF76 CD BE EF    		CALL	SD_CMD
4621   EF79 FE 00       		CPI	0
4622   EF7B C2 EC EE    		JNZ	INIT_FAIL
4623   EF7E CD 04 F0    		CALL	SPI_RX
4624   EF81 E6 C0       		ANI	0C0h
4625   EF83 FE C0       		CPI	0C0h
4626   EF85 C2 98 EF    		JNZ	ISD_5
4627   EF88 3E 03       		MVI	A,3
4628   EF8A 32 9B FD    		STA	SD_CARD_TYPE
4629   EF8D CD E7 E8    		CALL 	PRINTI		;
4630   EF90 205479706523 		.text " Type#3\000"
4630   EF96 3300
4631   EF98 CD 04 F0    ISD_5		CALL	SPI_RX
4632   EF9B CD 04 F0    		CALL	SPI_RX
4633   EF9E CD 04 F0    		CALL	SPI_RX
4634   EFA1             
4635   EFA1 CD A6 EF    ISD_6		CALL	SD_DESELECT
4636   EFA4 AF          		XRA	A		;Set Zero Flag = Success
4637   EFA5 C9          		RET
4638   EFA6             
4639   EFA6             ;-----------------------------------------------------------------------------------------------------
4640   EFA6 F5          SD_DESELECT	PUSH	PSW
4641   EFA7 3E 01       		MVI	A,1	;Deselect SDCARD
4642   EFA9 D3 31       		OUT	SPI_SS
4643   EFAB F1          		POP	PSW
4644   EFAC C9          		RET
4645   EFAD             
4646   EFAD             ;-----------------------------------------------------------------------------------------------------
4647   EFAD F5          SD_SELECT	PUSH	PSW
4648   EFAE 3E 00       		MVI	A,0	;Select SDCARD
4649   EFB0 D3 31       		OUT	SPI_SS
4650   EFB2 CD B7 EF    		CALL	SD_DELAY100
4651   EFB5 F1          		POP	PSW
4652   EFB6 C9          		RET
4653   EFB7             
4654   EFB7             ;-----------------------------------------------------------------------------------------------------
4655   EFB7 3E 0D       SD_DELAY100	MVI	A,13	 ;Small delay after selecting card
4656   EFB9 3D          SD_DELAY	DCR	A	 ;5
4657   EFBA C2 B9 EF    		JNZ	SD_DELAY ;10    15*13 ~= 200 ~= 100uSec
4658   EFBD C9          		RET
4659   EFBE             
4660   EFBE             ;-----------------------------------------------------------------------------------------------------
4661   EFBE             ;Send command to SD card
4662   EFBE C5          SD_CMD		PUSH	B
4663   EFBF CD AD EF    		CALL	SD_SELECT
4664   EFC2 CD 0C F0    		CALL	WAIT_NOT_BUSY
4665   EFC5             
4666   EFC5 06 FF       		MVI	B,0FFh	;Default CRC
4667   EFC7 FE 00       		CPI	0
4668   EFC9 C2 CE EF    		JNZ	SDC_1
4669   EFCC 06 95       		MVI	B,095h
4670   EFCE FE 08       SDC_1		CPI	8
4671   EFD0 C2 D5 EF    		JNZ	SDC_2
4672   EFD3 06 87       		MVI	B,087h
4673   EFD5             SDC_2
4674   EFD5 F6 40       		ORI	040H	;All Commands start with 40h
4675   EFD7 D3 30       		OUT	SPI
4676   EFD9 3A A0 FD    		LDA	SD_PARAM+3
4677   EFDC D3 30       		OUT	SPI
4678   EFDE 3A 9F FD    		LDA	SD_PARAM+2
4679   EFE1 D3 30       		OUT	SPI
4680   EFE3 3A 9E FD    		LDA	SD_PARAM+1
4681   EFE6 D3 30       		OUT	SPI
4682   EFE8 3A 9D FD    		LDA	SD_PARAM
4683   EFEB D3 30       		OUT	SPI
4684   EFED 00          		NOP
4685   EFEE 78          		MOV	A,B
4686   EFEF D3 30       		OUT	SPI
4687   EFF1             
4688   EFF1 06 00       		MVI	B,0
4689   EFF3 CD 04 F0    SDC_LP		CALL	SPI_RX	;Read Respsonse?
4690   EFF6 32 9C FD    		STA	SDC_STATUS
4691   EFF9 B7          		ORA	A
4692   EFFA F2 02 F0    		JP	SDC_RET
4693   EFFD 05          		DCR	B
4694   EFFE C2 F3 EF    		JNZ	SDC_LP
4695   F001 B7          		ORA	A
4696   F002 C1          SDC_RET		POP	B
4697   F003 C9          		RET
4698   F004             
4699   F004             ;-----------------------------------------------------------------------------------------------------
4700   F004             ;------------------------------- Receive a byte from SPI
4701   F004 3E FF       SPI_RX		MVI	A,0FFH	;Read Respsonse
4702   F006 D3 30       		OUT	SPI
4703   F008 00          		NOP		;4
4704   F009 DB 30       		IN	SPI	;10
4705   F00B C9          		RET
4706   F00C             
4707   F00C             ;-----------------------------------------------------------------------------------------------------
4708   F00C             ;------------------------------- Wait until FF's come back from Card (ie NOT BUSY)
4709   F00C F5          WAIT_NOT_BUSY	PUSH	PSW	;Do not destroy Acc
4710   F00D C5          		PUSH	B	;Fetch 1 consecutive FF's to be sure SD card NOT BUSY
4711   F00E 06 00       		MVI	B,0
4712   F010 0E 01       WNB_LP		MVI	C,1	;Set count for 1 trys
4713   F012 CD 04 F0    WNB_LP2		CALL	SPI_RX
4714   F015 3C          		INR	A
4715   F016 C2 22 F0    		JNZ	WNB_0	;NOT FF RETURNED, JUMP TO COUNT DOWN TRYS
4716   F019 0D          		DCR	C	;Count Down Consecutive FF's
4717   F01A C2 12 F0    		JNZ	WNB_LP2
4718   F01D C1          		POP	B
4719   F01E F1          		POP	PSW
4720   F01F 37          		STC		;Return NOT BUSY (Clear Carry)
4721   F020 3F          		CMC
4722   F021 C9          		RET
4723   F022             
4724   F022 AF          WNB_0		XRA	A
4725   F023 CD B9 EF    		CALL	SD_DELAY
4726   F026 05          		DCR	B	;Count Down Trys
4727   F027 C2 10 F0    		JNZ	WNB_LP
4728   F02A C1          		POP	B
4729   F02B F1          		POP	PSW
4730   F02C 37          		STC		;Return STILL BUSY (Set Carry)
4731   F02D C9          		RET
4732   F02E             
4733   F02E             ;-----------------------------------------------------------------------------------------------------
4734   F02E AF          SD_CLEAR_ARG	XRA	A
4735   F02F 32 9D FD    		STA	SD_PARAM
4736   F032 32 9E FD    		STA	SD_PARAM+1
4737   F035 32 9F FD    		STA	SD_PARAM+2
4738   F038 32 A0 FD    		STA	SD_PARAM+3
4739   F03B C9          		RET
4740   F03C             
4741   F03C             
4742   F03C             ;=====================================================================================================
4743   F03C             ;General Support Routines, Strings
4744   F03C             ;=====================================================================================================
4745   F03C             
4746   F03C             ;-----------------------------------------------------------------------------------------------------
4747   F03C CD E7 E8    INPUT_FNAME	CALL 	PRINTI		;Display Menu Prompt
4748   F03F 0D0A454E5445 		.text "\r\nENTER 8.3 FILE NAME> \000"
4748   F045 5220382E332046494C45204E414D453E2000
4749   F057 21 C8 FD    		LXI	H,FILENAME
4750   F05A 06 0B       		MVI	B,11
4751   F05C 3E 20       		MVI	A,' '
4752   F05E CD 3A F1    		CALL	FILL_BLOCK
4753   F061 0E 2E       		MVI	C,'.'
4754   F063 06 08       		MVI	B,8
4755   F065 CD AB F0    		CALL	GET_STRING
4756   F068 D8          		RC
4757   F069 FE 0D       		CPI	13
4758   F06B C8          		RZ
4759   F06C 21 D0 FD    		LXI	H,FILEEXT
4760   F06F 06 03       		MVI	B,3
4761   F071 CD AB F0    		CALL	GET_STRING
4762   F074 C9          		RET
4763   F075             
4764   F075             ;-----------------------------------------------------------------------------------------------------
4765   F075             ;	Prints Filename at HL
4766   F075             ;-----------------------------------------------------------------------------------------------------
4767   F075 E5          PRINT_FILENAME	PUSH	H
4768   F076 06 08       		MVI	B,8
4769   F078 7E          PF_LP1		MOV	A,M
4770   F079 B7          		ORA	A
4771   F07A CA 8A F0    		JZ	PFE
4772   F07D FE 20       		CPI	' '
4773   F07F CA 8A F0    		JZ	PFE
4774   F082 CD 3A E9    		CALL	PUT_CHAR
4775   F085 23          		INX	H
4776   F086 05          		DCR	B
4777   F087 C2 78 F0    		JNZ	PF_LP1
4778   F08A 3E 2E       PFE		MVI	A,'.'
4779   F08C CD 3A E9    		CALL	PUT_CHAR
4780   F08F E1          		POP	H
4781   F090 E5          		PUSH	H
4782   F091 01 08 00    		LXI	B,8
4783   F094 09          		DAD	B
4784   F095 06 03       		MVI	B,3
4785   F097 7E          PF_LP2		MOV	A,M
4786   F098 B7          		ORA	A
4787   F099 CA A9 F0    		JZ	PF_RET
4788   F09C FE 20       		CPI	' '
4789   F09E CA A9 F0    		JZ	PF_RET
4790   F0A1 CD 3A E9    		CALL	PUT_CHAR
4791   F0A4 23          		INX	H
4792   F0A5 05          		DCR	B
4793   F0A6 C2 97 F0    		JNZ	PF_LP2
4794   F0A9 E1          PF_RET		POP	H
4795   F0AA C9          		RET
4796   F0AB             
4797   F0AB             ;-----------------------------------------------------------------------------------------------------
4798   F0AB CD 27 E9    GET_STRING	CALL	GET_CHAR
4799   F0AE FE 1B       		CPI	27
4800   F0B0 37          		STC			;Set Carry to indicate Abort
4801   F0B1 C8          		RZ
4802   F0B2 FE 0D       		CPI	13		;Exit on <CR>
4803   F0B4 C8          		RZ
4804   F0B5 B9          		CMP	C		;Exit on Selectable Char (dot for file input)
4805   F0B6 C8          		RZ
4806   F0B7 CD C8 F0    		CALL	TO_UPPER
4807   F0BA FE 21       		CPI	' '+1		;Test if ACC is Control or Space
4808   F0BC DA AB F0    		JC	GET_STRING	;Skip such characters
4809   F0BF 05          		DCR	B
4810   F0C0 04          		INR	B		;Exit if B charcters are already inputed
4811   F0C1 C8          		RZ			;Exit if no more characters allowed
4812   F0C2 77          		MOV	M,A
4813   F0C3 23          		INX	H
4814   F0C4 05          		DCR	B
4815   F0C5 C3 AB F0    		JMP	GET_STRING
4816   F0C8             
4817   F0C8             ;-----------------------------------------------------------------------------------------------------
4818   F0C8 FE 61       TO_UPPER	CPI	'a'
4819   F0CA D8          		RC		;Return if ACC < 'a'
4820   F0CB FE 7B       		CPI	'z'+1
4821   F0CD D0          		RNC		;Return if ACC > 'z'
4822   F0CE E6 5F       		ANI	5Fh	;Flag upper case
4823   F0D0 C9          		RET
4824   F0D1             
4825   F0D1             
4826   F0D1             
4827   F0D1             ;=====================================================================================================
4828   F0D1             ;General Support Routines, 32 Bit stuff and other math
4829   F0D1             ;=====================================================================================================
4830   F0D1             
4831   F0D1             ;------------------------- Move (HL) to 32 bit register BCDE
4832   F0D1 5E          MOV_32_HL	MOV	E,M
4833   F0D2 23          		INX	H
4834   F0D3 56          		MOV	D,M
4835   F0D4 23          		INX	H
4836   F0D5 4E          		MOV	C,M
4837   F0D6 23          		INX	H
4838   F0D7 46          		MOV	B,M
4839   F0D8 C9          		RET
4840   F0D9             
4841   F0D9             ;------------------------- Move 32 bit register BCDE to (HL)
4842   F0D9 73          MOV_HL_32	MOV	M,E
4843   F0DA 23          		INX	H
4844   F0DB 72          		MOV	M,D
4845   F0DC 23          		INX	H
4846   F0DD 71          		MOV	M,C
4847   F0DE 23          		INX	H
4848   F0DF 70          		MOV	M,B
4849   F0E0 C9          		RET
4850   F0E1             
4851   F0E1             ;------------------------- ADD (HL) to 32 bit register BCDE
4852   F0E1 7B          ADD_32_HL	MOV	A,E
4853   F0E2 86          		ADD	M
4854   F0E3 5F          		MOV	E,A
4855   F0E4 23          		INX	H
4856   F0E5 7A          		MOV	A,D
4857   F0E6 8E          		ADC	M
4858   F0E7 57          		MOV	D,A
4859   F0E8 23          		INX	H
4860   F0E9 79          		MOV	A,C
4861   F0EA 8E          		ADC	M
4862   F0EB 4F          		MOV	C,A
4863   F0EC 23          		INX	H
4864   F0ED 78          		MOV	A,B
4865   F0EE 8E          		ADC	M
4866   F0EF 47          		MOV	B,A
4867   F0F0 C9          		RET
4868   F0F1             
4869   F0F1             ;-----------------------------------------------------------------------------------------------------
4870   F0F1 13          INC_32		INX	D
4871   F0F2 7A          		MOV	A,D
4872   F0F3 B3          		ORA	E
4873   F0F4 C0          		RNZ
4874   F0F5 03          		INX	B
4875   F0F6 C9          		RET
4876   F0F7             
4877   F0F7             ;-----------------------------------------------------------------------------------------------------
4878   F0F7             ;Compare BCDE with 32bit word at HL
4879   F0F7 23          CMP_HL_32	INX	H		;Point to MSB
4880   F0F8 23          		INX	H
4881   F0F9 23          		INX	H
4882   F0FA 78          		MOV	A,B		;Compare with B
4883   F0FB BE          		CMP	M
4884   F0FC C2 0F F1    		JNZ	CH3_R1
4885   F0FF 2B          		DCX	H
4886   F100 79          		MOV	A,C
4887   F101 BE          		CMP	M
4888   F102 C2 10 F1    		JNZ	CH3_R2
4889   F105 2B          		DCX	H
4890   F106 7A          		MOV	A,D
4891   F107 BE          		CMP	M
4892   F108 C2 11 F1    		JNZ	CH3_R3
4893   F10B 2B          		DCX	H
4894   F10C 7B          		MOV	A,E
4895   F10D BE          		CMP	M
4896   F10E C9          		RET
4897   F10F 2B          CH3_R1		DCX	H
4898   F110 2B          CH3_R2		DCX	H
4899   F111 2B          CH3_R3		DCX	H
4900   F112 C9          		RET
4901   F113             
4902   F113             ;------------------------- COMPARE DE WITH HL
4903   F113 7A          CMP_DE_HL	MOV	A,D		;Compare the MSB first
4904   F114 BC          		CMP	H
4905   F115 C0          		RNZ
4906   F116 7B          		MOV	A,E
4907   F117 BD          		CMP	L
4908   F118 C9          		RET
4909   F119             
4910   F119             
4911   F119             ;------------------------- SHIFT HL RIGHT ( 0 -> HL -> C )
4912   F119 B7          RHLR		ORA	A		;Clear Carry
4913   F11A 7C          		MOV	A,H
4914   F11B 1F          		RAR
4915   F11C 67          		MOV	H,A
4916   F11D 7D          		MOV	A,L
4917   F11E 1F          		RAR
4918   F11F 6F          		MOV	L,A
4919   F120 05          		DCR	B
4920   F121 C2 19 F1    		JNZ	RHLR
4921   F124 C9          		RET
4922   F125             
4923   F125             ;-----------------------------------------------------------------------------------------------------
4924   F125 06 02       COPY_RAM2	MVI	B,2	;2 BYTES
4925   F127 C3 2C F1    		JMP	COPY_RAM
4926   F12A 06 04       COPY_RAM4	MVI	B,4	;4 BYTES PER WORD
4927   F12C 7E          COPY_RAM	MOV	A,M
4928   F12D 12          		STAX	D
4929   F12E 23          		INX	H
4930   F12F 13          		INX	D
4931   F130 05          		DCR	B
4932   F131 C2 2C F1    		JNZ	COPY_RAM
4933   F134 C9          		RET
4934   F135             
4935   F135             ;-----------------------------------------------------------------------------------------------------
4936   F135             		;HL = (HL) word at memory location HL
4937   F135 7E          LD_HL_HL	MOV	A,M		;Fetch L from (HL)
4938   F136 23          		INX	H
4939   F137 66          		MOV	H,M		;Fetch H from (HL+1)
4940   F138 6F          		MOV	L,A
4941   F139 C9          		RET
4942   F13A             
4943   F13A             ;-----------------------------------------------------------------------------------------------------
4944   F13A             ;	FILL_BLOCK, Fills a block of RAM with value in A
4945   F13A             ;	Input:	A = value
4946   F13A             ;		HL = Start Address
4947   F13A             ;		B = Length of Fill (MAX = 0 = 256 bytes)
4948   F13A             ;-----------------------------------------------------------------------------------------------------
4949   F13A C5          FILL_BLOCK	PUSH	B
4950   F13B E5          		PUSH	H
4951   F13C 77          FB_LP		MOV	M,A
4952   F13D 23          		INX	H
4953   F13E 05          		DCR	B
4954   F13F C2 3C F1    		JNZ	FB_LP
4955   F142 E1          		POP	H
4956   F143 C1          		POP	B
4957   F144 C9          		RET
4958   F145             
4959   F145             ;-----------------------------------------------------------------------------------------------------
4960   F145 E9          VCALL		PCHL		;Jump to HL
4961   F146             
4962   F146             ;-----------------------------------------------------------------------------------------------------
4963   F146             ;Maximum number to divide is Logical Sector 2001/4 = 500
4964   F146             ;If dividing by powers of 2, then we can shift the number for fast divide
4965   F146 3A AC FD    DIV16BY8SPC	LDA	SEC_PER_CLUS
4966   F149             ;Input:	DE=Dividend, A=Divisor
4967   F149             ;Out:	DE=Result, A=Remainder
4968   F149 EB          DIV16BY8	XCHG		; HL = Dividend
4969   F14A 1E 00       		MVI	E,00	; Quotient = 0
4970   F14C             		;LHLD	2200H	; Get Dividend
4971   F14C             		;LDA	2300	; Get Divisor
4972   F14C 47          		MOV	B, A	; Store        Divisor
4973   F14D 0E 08       		MVI	C, 08	; Count = 8
4974   F14F 29          DIV16BY8_LP	DAD H		; Dividend = Dividend x 2
4975   F150 7B          		MOV	A, E
4976   F151 07          		RLC
4977   F152 5F          		MOV	E, A	; Quotient = Quotient x 2
4978   F153 7C          		MOV	A, H
4979   F154 90          		SUB	B	; Is most significant byte of Dividend > divisor
4980   F155 DA 5A F1    		JC	DIV16BY8_SK	; No, go to Next step
4981   F158 67          		MOV	H, A	; Yes, subtract divisor
4982   F159 1C          		INR	E	; and Quotient = Quotient + 1
4983   F15A 0D          DIV16BY8_SK	DCR	C	; Count = Count - 1
4984   F15B C2 4F F1    		JNZ	DIV16BY8_LP ; Is count =0 repeat
4985   F15E             		;MOV	A, E
4986   F15E             		;STA	2401H	; Store Quotient
4987   F15E 7C          		MOV	A, H
4988   F15F             		;STA	2410H	; Store remainder
4989   F15F 16 00       		MVI	D,0	; Quotient in DE
4990   F161 C9          		RET
4991   F162             
4992   F162             ;-----------------------------------------------------------------------------------------------------
4993   F162 3A 93 FD    DIVBYSHIFT	LDA	DF_SHIFTCNT	; DE = Dividend
4994   F165 47          		MOV	B,A
4995   F166 05          DBS_LP		DCR	B
4996   F167 C8          		RZ
4997   F168 B7          		ORA	A	;Clear Carry
4998   F169 7A          		MOV	A,D
4999   F16A 1F          		RAR
5000   F16B 57          		MOV	D,A
5001   F16C 7B          		MOV	A,E
5002   F16D 1F          		RAR
5003   F16E 5F          		MOV	E,A
5004   F16F C3 66 F1    		JMP	DBS_LP
5005   F172             
5006   F172             ;-----------------------------------------------------------------------------------------------------
5007   F172 3A 98 FD    MODBYMASK	LDA	MODMASK
5008   F175 A3          		ANA	E
5009   F176 C9          		RET
5010   F177             
5011   F177             		
5012   F177             ;-----------------------------------------------------------------------------------------------------
5013   F177             				
5014   F177             
5015   F177             
5016   F177             ;----------------------------------------------------------------------------------------------------; RAM SPACE
5017   F177             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
5018   F177             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
5019   F177             ;----------------------------------------------------------------------------------------------------; RAM SPACE
5020   F200             		.ORG	0F200H
5021   F200             TEMP_STACK	.EQU	$	;Temp stack at 0xFA00 (grows downward)
5022   F200             		.DSEG
5023   F200             		;DEFINE RAM AREAS FOR BDOS OPERATION
5024   F200             DIRBUF	.BLOCK	128
5025   F280             ALV0	.BLOCK	512
5026   F480             CSV0	.BLOCK	64
5027   F4C0             ALV1	.BLOCK	512
5028   F6C0             CSV1	.BLOCK	64
5029   F700             ALV2	.BLOCK	512
5030   F900             CSV2	.BLOCK	64
5031   F940             ALV3	.BLOCK	512
5032   FB40             CSV3	.BLOCK	64
5033   FB80             ;
5034   FB80             
5035   FB80             LOWSTACK	.EQU	$
5036   FB80             
5037   FB80             
5038   FD00             		.ORG	0FD00H
5039   FD00             HIGHSTACK			;Stack starts saveing at FCFFh and grows downward
5040   FD00             
5041   FD00             STACK_SIZE	.EQU	HIGHSTACK-LOWSTACK
5042   FD00             
5043   FD00             ;SDFCB:
5044   FD00             ;FSTAT		.BLOCK	1	;+0  Status of FCB, 00=File Not Open
5045   FD00             ;FNAME		.BLOCK	11	;+1
5046   FD00             ;AFClus0	.BLOCK	2	;+12 First Cluster of File as given by the Directory Entry.
5047   FD00             ;CRFClus	.BLOCK	2	;+14 Current Relative Cluster location in file, (0 to F for a system with 32 Sectors per Cluster)
5048   FD00             ;CAFClus	.BLOCK	2	;+16 Current Absolute Cluster location in file, set to AFClus0, then updated with FAT
5049   FD00             ;RFSec		.BLOCK	2	;+18 Relative Sector being addressed (0 to 500, based 26 sectors per track and 77 tracks Divide by 4)
5050   FD00             ;SSOC		.BLOCK	4	;+20 Starting Sector of Cluster, this is the first Sector for that Cluster
5051   FD00             ;ABS_SEC	.BLOCK	4	;+24 Absolute Sector of Current Relative Sector
5052   FD00             ;RESV		.BLOCK	4	;Filler for 32 bytes
5053   FD00             SDISKA		.BLOCK	32	;File Control Blocks for Disks A to D
5054   FD20             SDISKB		.BLOCK	32
5055   FD40             SDISKC		.BLOCK	32
5056   FD60             SDISKD		.BLOCK	32
5057   FD80             
5058   FD80             
5059   FD80             
5060   FD80             ; SPECIAL FLAGS.
5061   FD80             CONOTF		.BLOCK  1	;NO-PRINT FLAG (WHEN FF).
5062   FD81             ECHO_ON		.BLOCK	1	;Echo characters
5063   FD82             PROP_CHECK	.BLOCK	1	;Enable Propeller board when not zero
5064   FD83             FCB_PTR		.BLOCK	2	;Points to current FCB in use
5065   FD85             SEC_PER_TRACK	.BLOCK	2	;Sectors Per Track
5066   FD87             
5067   FD87             CLEAR_RAM	.EQU	$	;Clear all RAM after this point on INIT
5068   FD87             
5069   FD87             XMSEQ		.BLOCK	1	;XMODEM SEQUENCE NUMBER
5070   FD88             XMTYPE		.BLOCK	1	;XMODEM BLOCK TYPE (CRC/CS)
5071   FD89             XSECTOR		.BLOCK	1	;Sector of xmodem transfer
5072   FD8A             XTRACK		.BLOCK	1	;Track of xmodem transfer
5073   FD8B             XCOUNT		.BLOCK	2	;Count of sectors to read
5074   FD8D             XSUM		.BLOCK	2	;Sum of Staring Sector & Count
5075   FD8F             XPOS		.BLOCK	2	;Position of next read/write logical sector
5076   FD91             
5077   FD91             DIVIDE_FUNC	.BLOCK	2	;Pointer to the Divide Function
5078   FD93             DF_SHIFTCNT	.BLOCK	1	;Count of shifts required for Fast Divide
5079   FD94             MUL8		.BLOCK	1	;8 bit multiplier
5080   FD95             M_COUNTER	.BLOCK	1	;8 bit counter for multiply routine
5081   FD96             MOD_FUNC	.BLOCK	2	;Pointer to the Mod Function
5082   FD98             MODMASK		.BLOCK	1	;8 bit mask to get Relative Sector within a cluster from a Relative File sector
5083   FD99             
5084   FD99             LOGICAL_SEC	.BLOCK	2	;Logical Sector for next Read/Write Operation
5085   FD9B             
5086   FD9B             SD_CARD_TYPE	.BLOCK	1	;SD CARD TYPE
5087   FD9C             SDC_STATUS	.BLOCK	1	;SD Status Code returned
5088   FD9D             SD_PARAM	.BLOCK	4	;32 bit address parameter for SD Commands
5089   FDA1             SD_PART_TYPE	.BLOCK	1	;SD PARTITION TYPE
5090   FDA2             SD_PART_BASE	.BLOCK	4	;SD PARTITION STARTING RECORD
5091   FDA6             SD_PART_SIZE	.BLOCK	4	;SD PARTITION SIZE (Must follow SD_PART_BASE)
5092   FDAA             BYTE_P_SEC	.BLOCK	2	;0x0B Bytes per Sector (Almost always 512)
5093   FDAC             SEC_PER_CLUS	.BLOCK	1	;0x0D
5094   FDAD             RESERVED_SEC	.BLOCK	2	;0x0E - 0x0F
5095   FDAF             FAT_COPIES	.BLOCK	1	;0x10
5096   FDB0             ROOTDIR_SIZE	.BLOCK	2	;0x11 - 0x12
5097   FDB2             FILESYS_SEC	.BLOCK	4	;0x13 - 0x14 or 0x20 - 0x23
5098   FDB6             HIDDEN_SEC	.BLOCK	4	;0x1C - 0x1F
5099   FDBA             SEC_PER_FAT	.BLOCK	2	;0x16 - 0x17
5100   FDBC             FAT1START	.BLOCK	4	;Calculated Sector to FAT1
5101   FDC0             DIR_SECTOR	.BLOCK	4	;Calculated Sector to Root Directory
5102   FDC4             DATASTART	.BLOCK	4	;Calculated Sector to Data Area
5103   FDC8             FILENAME	.BLOCK	8	;File Name
5104   FDD0             FILEEXT		.BLOCK	3	;File Extension
5105   FDD3             SEC_PTR		.BLOCK	4	;Sector Pointer, general use variable that holds the last sector read
5106   FDD7             DIRTY_DATA	.BLOCK	1	;Indicates when data Read has been altered, ie. Requires flushing back to SD Card
5107   FDD8             ENT_COUNT	.BLOCK	2	;Directory Entry Counter, Counts down maximum directory entries in Find File
5108   FDDA             CLUSTER1	.BLOCK  2	;Cluster 1 of last opened file
5109   FDDC             FILESIZE	.BLOCK  4	;File Size of last opened file (must follow CLUSTER1)
5110   FDE0             FILESIZEHEX	.BLOCK  4
5111   FDE4             
5112   FDE4             
5113   FDE4             ; BIOS SCRATCH AREA.
5114   FDE4             ;
5115   FDE4             TRK:		.BLOCK   2		;CURRENT TRACK NUMBER.
5116   FDE6             SECT:		.BLOCK   1		;CURRENT SECTOR NUMBER.
5117   FDE7             DMAADD:		.BLOCK   2		;DISK TRANSFER ADDRESS.
5118   FDE9             DISKNO:		.BLOCK   1		;DISK NUMBER (TO CP/M).
5119   FDEA             TEMP:		.BLOCK   1		;TEMPORARY STORAGE.
5120   FDEB             
5121   FDEB             
5122   FE00             		.ORG	0FE00H
5123   FE00             SD_RAM_BUFFER	.BLOCK	512		;512 BYTE SD CARD BUFFER
5124   0000             
5125   0000             
5126   0000             		.end
5127   0000             
5128   0000             
5129   0000             
5130   0000             ;----------------------------------------------------------------------------------------------------; INSTRUCTION LIST REFERENCE
5131   0000             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
5132   0000             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
5133   0000             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
5134   0000             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
5135   0000             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
5136   0000             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
5137   0000             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
5138   0000             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
5139   0000             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
5140   0000             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
5141   0000             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
5142   0000             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
5143   0000             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
5144   0000             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
5145   0000             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
5146   0000             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
5147   0000             ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
5148   0000             ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
5149   0000             ;----------------------------------------------------------------------------------------------------;
5150   0000             
5151   0000             ;DATA TRANSFER GROUP
5152   0000             ;'Mnem.     'Description                 'Notes                '
5153   0000             ;'----------+----------------------------+---------------------'
5154   0000             ; MOV r1,r2 | r1 <- r2                   |r = A,B,C,D,E,H,L
5155   0000             ; MOV r,M   | r <- (HL)
5156   0000             ; MOV M,r   | (HL) <- r
5157   0000             ; HLT       | HALT
5158   0000             ; MVI r,d   | r <- d, Move Immediate data
5159   0000             ; MVI M     | (HL) <- d, Immediate data
5160   0000             ; INR r     | r <- r+1
5161   0000             ; DCR r     | r <- r-1
5162   0000             ; INR M     | (HL) <- (HL)+1
5163   0000             ; DCR M     | (HL) <- (HL)-1
5164   0000             ; ADD r     | A <- A+r
5165   0000             ; ADC r     | A <- A+r+CY                |Add with Carry
5166   0000             ; SUB r     | A <- A-r
5167   0000             ; SBB r     | A <- A-r-CY                |Subtract with Borrow
5168   0000             ; ANA r     | A <- A AND r
5169   0000             ; XRA r     | A <- A XOR r
5170   0000             ; ORA r     | A <- A OR r
5171   0000             ; CMP r     | A-r                        |Compare
5172   0000             ; ADD M     | A <- A+(HL)
5173   0000             ; ADC M     |
5174   0000             ; SUB M     |
5175   0000             ; SBB M     |
5176   0000             ; ANA M     |
5177   0000             ; XRA M     |
5178   0000             ; ORA M     |
5179   0000             ; CMP M     |
5180   0000             ; ADI d     | A <- A+d, ADD Immediate data
5181   0000             ; ACI d     |
5182   0000             ; SUI d     |
5183   0000             ; SBI d     |
5184   0000             ; ANI d     |
5185   0000             ; XRI d     |
5186   0000             ; ORI d     |
5187   0000             ; CPI d     |
5188   0000             ; RLC       | Rotate A Left, CY<-MSB   Only Carry Affected
5189   0000             ; RRC       | Rotate A Right, CY<-LSB  Only Carry Affected
5190   0000             ; RAL       | Rotate A Left through Carry  Only Carry Affected
5191   0000             ; RAR       | Rotate A Right through Carry Only Carry Affected
5192   0000             ; JMP addr  | Jump Address
5193   0000             ; JC  addr  | Jump on Carry
5194   0000             ; JNC addr  | Jump on NOT Cary
5195   0000             ; JZ  addr  | Jump on ZERO
5196   0000             ; JNZ addr  | Jump on NOT ZERO
5197   0000             ; JP  addr  | Jump on Positive (MSB=0)
5198   0000             ; JM  addr  | Jump on Minus (MSB=1)
5199   0000             ; JPE addr  | Jump on Parity Even (Parity bit =1)
5200   0000             ; JPO addr  | Jump on Parity Odd (Parity bit =0)
5201   0000             ; CALL addr | Call subroutine
5202   0000             ; CC  addr
5203   0000             ; CNC addr
5204   0000             ; CZ  addr
5205   0000             ; CNZ addr
5206   0000             ; CP  addr
5207   0000             ; CM  addr
5208   0000             ; CPE addr
5209   0000             ; CPO addr
5210   0000             ; RET       | Return from subroutine
5211   0000             ; RC
5212   0000             ; RNC
5213   0000             ; RZ
5214   0000             ; RNZ
5215   0000             ; RP
5216   0000             ; RM
5217   0000             ; RPE
5218   0000             ; RPO
5219   0000             ; RST n     | Restart to Vector n        | n=0,1,2,3,4,5,6,7
5220   0000             ; IN  p     | A <- Port p, Input
5221   0000             ; OUT p     | Port p <- A, Output
5222   0000             ; LXI B,dd  | BC <- dd, Load Immediate data, 16 bit to Register Pair
5223   0000             ; LXI D,dd  | DE <- dd
5224   0000             ; LXI H,dd  | HL <- dd
5225   0000             ; LXI SP,dd | SP <- dd
5226   0000             ; PUSH B    | PUSH BC register pair to STACK
5227   0000             ; PUSH D    | PUSH DE register pair to STACK
5228   0000             ; PUSH H    | PUSH HL register pair to STACK
5229   0000             ; PUSH PSW  | PUSH A,Flags register pair to STACK
5230   0000             ; POP B     | POP BC register pair from STACK
5231   0000             ; POP D     | POP DE register pair from STACK
5232   0000             ; POP H     | POP HL register pair from STACK
5233   0000             ; POP PSW   | POP A,Flags register pair from STACK
5234   0000             ; STA addr  | (addr) <- A, Store A Direct
5235   0000             ; LDA addr  | A <- (addr), Load A Direct
5236   0000             ; XCHG      | Exchange HL <> DE
5237   0000             ; XTHL      | Exchange HL <> (SP), Exchange HL with Top of Stack
5238   0000             ; SPHL      | SP <- HL, Move HL to SP
5239   0000             ; PCHL      | PC <- HL, Move HL to PC
5240   0000             ; DAD B     | HL <- HL+BC, Add 16 bit register pairs
5241   0000             ; DAD D     | HL <- HL+DE, Add 16 bit register pairs
5242   0000             ; DAD H     | HL <- HL+HL, Add 16 bit register pairs
5243   0000             ; DAD SP    | HL <- HL+SP, Add 16 bit register pairs
5244   0000             ; STAX B    | (BC) <- A, Store A Indirect
5245   0000             ; STAX D    | (DE) <- A, Store A Indirect
5246   0000             ; LDAX B    | A <- (BC), Load A Indirect
5247   0000             ; LDAX D    | A <- (DE), Load A Indirect
5248   0000             ; INX B     | BC <- BC+1, Increment 16 bit register pair
5249   0000             ; INX D     | DE <- DE+1, Increment 16 bit register pair
5250   0000             ; INX H     | HL <- HL+1, Increment 16 bit register pair
5251   0000             ; INX SP    | SP <- SP+1, Increment 16 bit register
5252   0000             ; DCX B     | BC <- BC-1, Decrement 16 bit register pair
5253   0000             ; DCX D     | DE <- DE-1, Decrement 16 bit register pair
5254   0000             ; DCX H     | HL <- HL-1, Decrement 16 bit register pair
5255   0000             ; DCX SP    | SP <- SP-1, Decrement 16 bit register
5256   0000             ; CMA       | A <- /A, Complement Accumulator
5257   0000             ; STC       | Set Carry
5258   0000             ; CMC       | Complement Carry
5259   0000             ; DAA       | Decimal Adjust Accumulator
5260   0000             ; SHLD addr | (addr) <- HL, Store HL Direct
5261   0000             ; LHLD addr | HL <- (addr), Load HL Direct
5262   0000             ; EI        | Enable Interrupts
5263   0000             ; DI        | Disable Interrupts
5264   0000             ; NOP       | No Op
5265   0000             
5266   0000             ;            #IFDEF  label1
5267   0000             ;            lda     byte1
5268   0000             ;            sta     byte2
5269   0000             ;            #ENDIF
5270   0000             ;
5271   0000             ;
5272   0000             ;            #ifdef  label1
5273   0000             ;            lda     byte1
5274   0000             ;            #else
5275   0000             ;            lda     byte2
5276   0000             ;            #endif
5277   0000             ;
5278   0000             ;            #ifndef label1
5279   0000             ;            lda     byte2
5280   0000             ;            #else
5281   0000             ;            lda     byte1
5282   0000             ;            #endif
5283   0000             ;
5284   0000             ;            #if ($ >= 1000h)
5285   0000             ;            ; generate an invalid statement to cause an error
5286   0000             ;            ;  when we go over the 4K boundary.
5287   0000             ;             !!! PROM bounds exceeded.
5288   0000             ;            #endif
tasm: Number of errors = 0
